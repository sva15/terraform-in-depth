# Chapter 5.3: Plan

## What This Chapter is About

This chapter explains the **Terraform plan stage** - the critical phase where Terraform analyzes your configuration, compares it with real infrastructure, and determines what changes need to be made. Understanding plans is essential for safe and predictable infrastructure management.

## Key Concept: Plan = Change Detection

Think of the plan stage like:
- **Architectural blueprints**: Showing what will be built before construction starts
- **GPS route planning**: Calculating the path before you start driving
- **Diff tool**: Showing what's different between desired and actual state

## Basic Plan Commands

### Running a Plan
```bash
# Basic plan (speculative - not saved)
terraform plan

# Save plan for later application
terraform plan -out=myplan.tfplan

# Plan with variables
terraform plan -var="environment=prod" -out=prod.tfplan

# Plan with variable file
terraform plan -var-file="prod.tfvars" -out=prod.tfplan
```

### Understanding Plan Output
```t
# Example configuration
resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t3.micro"
  
  tags = {
    Name = "WebServer"
  }
}
```

### Plan Output Symbols
```bash
Terraform will perform the following actions:

  # aws_instance.web will be created
  + resource "aws_instance" "web" {
      + ami                          = "ami-12345678"
      + instance_type                = "t3.micro"
      + id                           = (known after apply)
      + public_ip                    = (known after apply)
      + tags                         = {
          + "Name" = "WebServer"
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

**Symbols:**
- `+` : Create new resource
- `-` : Destroy resource
- `~` : Update in-place
- `-/+` : Replace (destroy then create)
- `+/-` : Create replacement then destroy

## Planning Modes

### 1. Default Mode
```bash
# Standard planning - create, update, delete as needed
terraform plan

# What it does:
# 1. Refresh state (check current infrastructure)
# 2. Compare desired vs actual
# 3. Generate changes needed
```

### 2. Destroy Mode
```bash
# Plan to destroy all resources
terraform plan -destroy -out=destroy.tfplan

# Output shows all resources marked for destruction:
# - aws_instance.web will be destroyed
# - aws_security_group.web will be destroyed
# Plan: 0 to add, 0 to change, 2 to destroy

# Apply the destroy plan
terraform apply destroy.tfplan
```

### 3. Refresh-Only Mode
```bash
# Only update state, no infrastructure changes
terraform plan -refresh-only

# Use cases:
# - Detect drift (manual changes)
# - Update state after out-of-band changes
# - Sync state without modifications
```

## Replace Resources

### Using -replace Flag
```bash
# Force replacement of specific resource
terraform plan -replace="aws_instance.web" -out=replace.tfplan

# Multiple replacements
terraform plan \
  -replace="aws_instance.web[0]" \
  -replace="aws_instance.web[1]" \
  -out=replace.tfplan
```

### Cascading Effects
```t
# Original resources
resource "aws_eip" "web" {
  instance = aws_instance.web.id
}

resource "aws_instance" "web" {
  # ...
}

# Planning to replace instance
$ terraform plan -replace="aws_instance.web"

# Output shows cascading changes:
# -/+ aws_instance.web (will be replaced)
# ~   aws_eip.web (will be updated)
#     ~ instance = "i-old" -> (known after apply)
```

## Resource Targeting (Use Sparingly!)

### Basic Targeting
```bash
# Target specific resources (AVOID IN PRODUCTION)
terraform plan -target="aws_instance.web"

# Multiple targets
terraform plan \
  -target="aws_instance.web" \
  -target="aws_security_group.web"

# Target all instances of a resource
terraform plan -target="aws_instance.web[*]"

# Target module resources
terraform plan -target="module.vpc"
```

### Why Avoid Targeting?
```t
# Dependencies might be missed
resource "aws_security_group" "web" {
  # ...
}

resource "aws_instance" "web" {
  vpc_security_group_ids = [aws_security_group.web.id]
}

# Targeting only instance might fail if security group needs updates
```

## Plan Options

### Disable Refresh
```bash
# Skip refresh phase (DANGEROUS!)
terraform plan -refresh=false

# Why dangerous?
# - Won't detect manual changes
# - Plan based on outdated state
# - Apply likely to fail

# Valid use case (rare):
# - Development environment
# - You're certain no external changes
# - Need faster iteration
```

### Plan Variables
```bash
# Pass variables to plan
terraform plan -var="instance_type=t3.large"

# Multiple variables
terraform plan \
  -var="instance_type=t3.large" \
  -var="environment=staging"

# Using var files
terraform plan -var-file="staging.tfvars"
```

## Understanding Plan Files

### Saved Plans
```bash
# Save plan
terraform plan -out=myplan.tfplan

# What's in a plan file?
# - Binary format (not human-readable)
# - Complete snapshot of:
#   - Current state
#   - Desired state
#   - Required changes
#   - Provider configurations

# Review saved plan
terraform show myplan.tfplan

# Convert to JSON for analysis
terraform show -json myplan.tfplan > plan.json
```

### Plan File Best Practices
```bash
# Include descriptive names
terraform plan -out="$(date +%Y%m%d)-add-loadbalancer.tfplan"

# Don't commit plan files to version control
echo "*.tfplan" >> .gitignore

# Plans expire - use promptly
terraform apply old.tfplan
# Error: Saved plan is stale
```

## Real-World Example: TLS Module

### Initial Plan (Creation)
```bash
$ terraform plan

Terraform will perform the following actions:

  # tls_private_key.ca_key will be created
  + resource "tls_private_key" "ca_key" {
      + algorithm = "ED25519"
      + id        = (known after apply)
    }

  # tls_self_signed_cert.ca_cert will be created
  + resource "tls_self_signed_cert" "ca_cert" {
      + cert_pem = (known after apply)
      + is_ca_certificate = true
    }

  # (Additional resources...)

Plan: 11 to add, 0 to change, 0 to destroy.
```

### Replace Plan
```bash
$ terraform plan -replace='tls_private_key.child_key["example.com"]'

# Shows cascading replacements:
# -/+ tls_private_key.child_key["example.com"] (requested)
# -/+ tls_cert_request.child_request["example.com"] (forced)
# -/+ tls_locally_signed_cert.child_certificate["example.com"] (forced)

Plan: 3 to add, 0 to change, 3 to destroy.
```

## Common Patterns

### Development Workflow
```bash
# 1. Make changes to .tf files

# 2. Preview changes
terraform plan

# 3. If looks good, save plan
terraform plan -out=changes.tfplan

# 4. Review again if needed
terraform show changes.tfplan

# 5. Apply
terraform apply changes.tfplan
```

### CI/CD Integration
```bash
# In CI pipeline
terraform plan -out=plan.tfplan -input=false

# Save plan artifact
# Human reviews plan

# In CD pipeline
terraform apply plan.tfplan -input=false
```

### Drift Detection
```bash
# Regular drift checks
terraform plan -refresh-only -out=drift.tfplan

# If drift detected:
terraform show drift.tfplan

# Decide whether to:
# 1. Update Terraform config to match reality
# 2. Apply to bring reality back to config
```

## Best Practices

### 1. Always Review Plans
```bash
# Never blind apply
# ❌ terraform apply -auto-approve

# ✅ Review first
terraform plan -out=reviewed.tfplan
# (Review the output)
terraform apply reviewed.tfplan
```

### 2. Use Descriptive Plan Names
```bash
# ❌ Bad
terraform plan -out=plan.tfplan

# ✅ Good
terraform plan -out="2024-01-15-add-rds-backup.tfplan"
```

### 3. Handle Sensitive Data
```t
variable "db_password" {
  type      = string
  sensitive = true
}

# Plan output shows:
# + password = (sensitive value)
```

### 4. Understand "known after apply"
```bash
# These values are computed during apply:
# - Auto-generated IDs
# - IP addresses
# - DNS names
# - Computed attributes

# Plan shows:
# + id = (known after apply)
# + public_ip = (known after apply)
```

## Troubleshooting Plans

### Cycle Errors
```bash
# Error: Cycle: aws_security_group.a, aws_security_group.b

# Debug with graph
terraform graph | dot -Tpng > cycle.png
# Review image to find circular dependency
```

### Large Plans
```bash
# For very large plans
terraform plan -out=large.tfplan 2>&1 | tee plan.log

# Review sections
grep "will be created" plan.log | wc -l
grep "will be destroyed" plan.log | wc -l
```

### Unexpected Changes
```bash
# Resource shows changes every plan?
# Check for:
# - Computed attributes
# - Provider bugs
# - External modifications

# Debug with:
terraform plan -refresh-only
terraform state show aws_instance.problem
```

## Key Takeaways

1. **Plan before apply** - Never skip the plan review
2. **Save critical plans** - Use -out for important changes
3. **Understand the symbols** - +, -, ~, -/+ each mean different things
4. **Three planning modes** - Default, destroy, refresh-only
5. **-replace is safer than taint** - Shows impact before changing state
6. **Avoid -target and -refresh=false** - Except in emergencies
7. **Plans are snapshots** - They can become stale
8. **Review cascading changes** - One replacement might trigger others

The plan stage is your safety net - it shows exactly what Terraform will do before any changes are made to your infrastructure.
