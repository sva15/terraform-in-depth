# **Chapter 10.1: Names and Domains**

## **What This Chapter is About**

This chapter explains why **consistent naming** is crucial for managing infrastructure with Terraform. It shows how to create a naming system that makes your resources easy to identify, organize, and manage, especially when you have hundreds of resources across different environments.

## **Key Concept: Consistency Through Code**

Think of naming like labeling moving boxes. If you write "Stuff" on every box, you'll never find anything. Terraform lets you create a smart, consistent labeling system directly in your code. This becomes essential when managing many resources across different applications and environments.

## **The Four Rules for Good Names**

Your resource names should be:

### **1. Unique**
- **Why:** Cloud platforms often prevent duplicate names
- **Example:** You can't have two S3 buckets with the same name globally
- **Importance:** Prevents errors and confusion between resources

### **2. Human Readable**
- **Why:** Humans need to understand names quickly when debugging
- **Good Example:** `prod-api-lb` (Production API Load Balancer)
- **Bad Example:** `a3d7b2` (Random, meaningless string)

### **3. Identifiable**
- **Why:** Names should describe what the resource is and does
- **Good Example:** `dev-backend-db` (Development backend database)
- **Bad Example:** `happy-penguin` (Cute but uninformative)

### **4. Sortable**
- **Why:** Helps group related resources together in lists
- **Example:** Using `prod-` and `dev-` prefixes makes all production resources list together
- **Benefit:** Easy filtering and management of environment-specific resources

## **The Solution: Hierarchical Naming**

### **What is Hierarchical Naming?**
Building names like paths or addresses, starting broad and getting more specific. This is the same pattern used in:
- **Domain Names:** `api.dev.example.com`
- **File Paths:** `/home/user/documents/work/report.pdf`
- **Terraform:** `module.api.module.load_balancer.aws_lb.main`

### **How to Implement Hierarchical Naming**

#### **Step 1: Start at the Top (Root Module)**
Define a base name for your project and environment:
```hcl
variable "environment" {
  description = "The environment name (dev, staging, prod)"
  type        = string
}

locals {
  application = "acme"  # Your project name
  base_name   = "${local.application}-${var.environment}"  # e.g., "acme-dev"
}
```

#### **Step 2: Pass Names to Submodules**
Add descriptors to create unique names for each module:
```hcl
module "api" {
  source = "./service"
  name   = "${local.base_name}-api"  # Becomes "acme-dev-api"
}

module "database" {
  source = "./db"
  name   = "${local.base_name}-db"   # Becomes "acme-dev-db"
}
```

#### **Step 3: Continue Inside Modules**
Modules build on the names they receive:
```hcl
variable "name" {
  description = "The service name passed from parent"
  type        = string
}

resource "aws_ecs_cluster" "main" {
  name = "${var.name}-cluster"  # e.g., "acme-dev-api-cluster"
}

module "load_balancer" {
  source = "./alb"
  name   = "${var.name}-lb"     # e.g., "acme-dev-api-lb"
}
```

### **Final Naming Structure**
This approach creates clear, descriptive names:
- `acme-dev-api-cluster`
- `acme-dev-api-lb` 
- `acme-dev-db-mysql`

## **Special Case: Adding Randomness**

### **When to Use Randomness**
Some resources need unique names for safety or security:
- **Secrets Manager:** Can't reuse deleted secret names immediately
- **S3 Buckets:** Global uniqueness required to prevent "namespace squatting"

### **How to Add Randomness**
```hcl
variable "name" {
  description = "Base name for the secret"
  type        = string
}

# Add a small random suffix
resource "random_string" "suffix" {
  length  = 6      # Short but unique enough
  special = false  # Only letters and numbers
  upper   = false  # Keep it simple, lowercase only
}

resource "aws_secretsmanager_secret" "main" {
  name = "${var.name}-${random_string.suffix.result}"  # e.g., "acme-dev-api-abc123"
}
```

## **Applying the Same Logic to Domains**

### **Domain Naming Pattern**
Use the same hierarchical approach for domain names:
```hcl
variable "environment" {
  type = string
}

variable "domain" {
  description = "Your company's base domain"
  type        = string
}

locals {
  application = "acme"
  base_domain = "${var.environment}.${local.application}.${var.domain}"  # e.g., "dev.acme.example.net"
}

module "api" {
  source = "./service"
  domain = "api.${local.base_domain}"  # Becomes "api.dev.acme.example.net"
}
```

### **Domain Segmentation Tips**
- **Public-facing:** Use `.com` domains (e.g., `api.acme.com`)
- **Internal use:** Use `.net` or other TLDs (e.g., `internal.acme.net`)
- **Environment-specific:** Include environment in subdomain (e.g., `dev.api.acme.com`)

## **Practical Tips and Caveats**

### **Avoid These Common Issues**
- **Deep nesting:** Too many module layers create very long names
- **Redundant words:** Don't say `logging_bucket` when `logs` is sufficient
- **Overly specific:** Don't include resource types that are obvious from context

### **Dealing with Third-Party Modules**
- You can't always control naming in external modules
- Establish naming conventions with other teams when possible
- Be flexible when using community or vendor-provided modules

## **Key Takeaways**

1. **Good names are unique, readable, identifiable, and sortable**
2. **Hierarchical naming mirrors your infrastructure structure**  
3. **Start broad at the root module and get more specific deeper in**
4. **Add randomness only when required by resource constraints**
5. **Use the same hierarchical pattern for both resource names and domains**
6. **Keep names concise but descriptive to avoid excessive length**

This approach ensures your Terraform-managed infrastructure remains organized and understandable as it grows in complexity.
