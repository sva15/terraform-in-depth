# Chapter 10.2: Network Management

## What This Chapter is About

This chapter explains how to use Terraform to create and manage cloud networks. It focuses on the core concepts of subnetting, common network designs (topologies), and how to build a flexible, reusable Terraform module that can automatically create complex network structures for you.

## Key Concepts

*   **Cloud Networking Basics**: In the cloud, you build your own virtual network. This starts with a **VPC (Virtual Private Cloud)**, which is your private space, and is divided into smaller **Subnets** for organizing your resources.
*   **CIDR and Subnetting**: **CIDR** ("cider") is a way to define a range of IP addresses (e.g., `10.0.0.0/16`). **Subnetting** is the process of slicing a large network range into smaller ones.
*   **Terraform's Network Functions**: Terraform has built-in functions like `cidrsubnet` that do the complicated math of subnetting for you automatically.
*   **Network Topologies**: These are standard designs for your network layout, usually focused on security and separating public services from private ones.
*   **High Availability**: To make sure your application doesn't go down if a data center has an issue, you spread your network across multiple physical locations, known as **Availability Zones**.
*   **Reusable Modules**: The end goal is to package all this logic into a simple, reusable module. This allows anyone on your team to create a standardized, complex network just by changing a few variables.

## Subnetting with Classless Inter-Domain Routing (CIDR)

### What is CIDR?

CIDR is a standard for defining a network's IP address range with a single string.
`192.168.0.0/16`

*   `192.168.0.0`: The starting IP address of the network.
*   `/16`: The prefix size. This defines how big the network is. A smaller number means a bigger network with more IP addresses.

### Slicing a Network

A `/16` network is huge, containing over 65,000 addresses. This is often too big. Subnetting is like slicing this giant network into smaller, more manageable pieces. By increasing the prefix size (e.g., from `/16` to `/18`), you "borrow" bits to create more, smaller networks.

*   Taking 1 bit lets you create 2 subnets.
*   Taking 2 bits lets you create 4 subnets.
*   Taking 3 bits lets you create 8 subnets, and so on.

### The `cidrsubnet` Function

Terraform's `cidrsubnet` function makes this easy. It calculates the new network range for you.

`cidrsubnet(base_network, new_bits, network_number)`

*   **`base_network`**: The original, large network range (e.g., `"192.168.0.0/16"`).
*   **`new_bits`**: The number of bits to borrow for subnetting (e.g., `2` for 4 subnets).
*   **`network_number`**: The index of the subnet you want (starting from `0`).

```t
# To get 4 subnets from our /16 network
> cidrsubnet("192.168.0.0/16", 2, 0)
"192.168.0.0/18"  # First subnet

> cidrsubnet("192.168.0.0/16", 2, 1)
"192.168.64.0/18" # Second subnet

> cidrsubnet("192.168.0.0/16", 2, 2)
"192.168.128.0/18" # Third subnet

> cidrsubnet("192.168.0.0/16", 2, 3)
"192.168.192.0/18" # Fourth subnet
```

## Common Network Topologies

Before building, you need a blueprint. Here are the most common designs.

### Design Considerations

1.  **Segmentation of services**: Keep resources separate for security.
2.  **High availability**: Spread resources across locations to prevent outages.
3.  **Size of the network**: Plan for growth without wasting IP addresses.

### Two-Segment Network (Public/Private)

This is the most common pattern, focused on security.
*   **Public Subnet**: For resources that need to be reached from the internet, like a load balancer. Resources here get a public IP address.
*   **Private Subnet**: For internal resources that should NOT be reached from the internet, like databases and application servers.
*   **NAT Gateway**: A service that lives in the public subnet and allows resources in the private subnet to securely access the internet (e.g., for software updates) without being exposed.



### Three-Segment Network (Public/Private/Isolated)

For even higher security needs.
*   **Public and Private Subnets**: Same as the two-segment design.
*   **Isolated Subnet**: A "vault" for extremely sensitive data. It has **no internet connection at all**, inbound or outbound.



### High Availability Design

To protect against outages, you replicate your chosen network topology across multiple physical locations (Availability Zones). The standard is to use three locations.



## Building a Reusable Network Module

We will create a flexible module that can build these topologies automatically.

### Module Structure

The design uses a high-level "wrapper" module that calls smaller submodules. This hides the complexity from the end-user.



### The Two-Segment Submodule (`az_2`)

This submodule creates a public and private network for a single location.

*   **Goal**: Create one public and one private subnet.
*   **Logic**: Uses `cidrsubnet(var.cidr_block, 1, ...)` to split the incoming network block into two halves.
*   **Public Subnet**: Created with `map_public_ip_on_launch = true`. A `aws_nat_gateway` is placed here.
*   **Private Subnet**: Created without public IPs. A route table is added to direct its internet-bound traffic through the NAT gateway.
*   **Outputs**: `public_subnet_id` and `private_subnet_id`.

### The Three-Segment Submodule (`az_3`)

This submodule creates a public, private, and isolated network for a single location.

*   **Goal**: Create three subnets with different security levels.
*   **Logic (The Trick)**: Since you can't easily divide by three, it gets creative:
    1.  The main block is split in half. The first half becomes the larger **private subnet**.
    2.  The second half is split in half *again*. These two smaller quarters become the **public subnet** and the **isolated subnet**.
*   **Isolated Subnet**: Created with no public IPs and no route to the NAT gateway, making it completely offline.
*   **Outputs**: `public_subnet_id`, `private_subnet_id`, and `isolated_subnet_id`.

### The High-Level "Wrapper" Module

This module is what the end-user interacts with. It's smart enough to build the right network across multiple locations.

*   **Goal**: Make it simple to deploy a highly available network with a chosen topology.
*   **Key Inputs**:
    *   `cidr_block`: The overall network range.
    *   `availability_zones`: How many locations to deploy to (e.g., `3`).
    *   `enable_isolated_subnet`: A true/false switch to choose between the 2-segment and 3-segment topology.
*   **Logic**:
    1.  **Calculates Subnet Slices**: Determines how to divide the main `cidr_block` to give each availability zone its own slice.
    2.  **Chooses the Submodule**: Uses the `count` meta-argument as a toggle. If `enable_isolated_subnet` is `true`, it sets `count` on the `three_tier_subnets` module. If `false`, it sets `count` on the `two_tier_subnets` module. The other module gets `count = 0` and is ignored.
    3.  **Loops and Creates**: It creates one instance of the chosen submodule for each availability zone.
    4.  **Provides Final Outputs**: It uses the splat operator (`[*]`) to gather the subnet IDs from all the created submodule instances and returns them as clean lists (e.g., `public_subnet_ids`).

## Example Usage

After building the module, creating a complex network is incredibly simple. To create a 3-segment network across 3 availability zones:

```t
module "network" {
  # Change this to your module's location
  source = "./top_level"

  # Choose the 3-segment topology
  enable_isolated_subnet = true

  # Deploy across 3 locations for high availability
  availability_zones = 3

  # Define the total IP address space for the entire VPC
  cidr_block = "192.168.0.0/16"
}
```

## Key Takeaways

1.  **Network Fundamentals**: VPCs and Subnets are the building blocks of cloud infrastructure.
2.  **`cidrsubnet` is Your Friend**: It automates the complex and error-prone task of network address calculation.
3.  **Standardize with Topologies**: Use common patterns like 2-segment and 3-segment networks for consistent security.
4.  **Modules Hide Complexity**: The true power of Terraform is building modules that make complex tasks simple for others to use.
5.  **Build for Flexibility**: A well-designed module allows users to choose between simple, low-cost setups (one AZ) and robust, highly available ones (multiple AZs) with a simple variable change.
