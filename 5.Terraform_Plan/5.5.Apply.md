# Chapter 5.5: Apply

## What This Chapter is About

This chapter explains the **Terraform apply stage** - where your plans become reality. After understanding DAGs (5.1), resource graphs (5.2), planning (5.3), and variables (5.4), apply is where Terraform actually creates, updates, or destroys your infrastructure.

## Key Concept: Apply = Making Changes Real

Think of the apply stage like:
- **Construction execution**: Following the blueprint to build the actual building
- **Recipe cooking**: Taking the recipe and actually making the meal
- **GPS navigation**: Actually driving the route that was planned

## How Apply Works

### The Apply Process
```bash
# Apply follows the dependency graph from Chapter 5.1
# Uses the resource graph from Chapter 5.2
# Executes the plan from Chapter 5.3
# With variables from Chapter 5.4

terraform apply
```

### Understanding Apply Output

When you run apply, Terraform shows you exactly what's happening:

```bash
# TLS Module Example - Creating Certificate Infrastructure
tls_private_key.child_key["example.com"]: Creating...                       ①
tls_private_key.child_key["charlie.example.com"]: Creating...               ① 
tls_private_key.ca_key: Creating...                                         ①
tls_private_key.child_key["bravo.example.com"]: Creating...                 ①

tls_private_key.child_key["bravo.example.com"]: Creation complete after 0s  ②
[id=df0cff0803f57bf5eb1380531b6178eac6cb19ae]                              ②
tls_private_key.child_key["example.com"]: Creation complete after 0s        ②
[id=a2c8fa2c3a818ba5ef4d99a7a51f751e029cfd15]                              ②

tls_cert_request.child_request["example.com"]: Creating...                  ③
tls_cert_request.child_request["charlie.example.com"]: Creating...          ③
tls_cert_request.child_request["bravo.example.com"]: Creating...            ③

tls_self_signed_cert.ca_cert: Creating...                                   ④

tls_locally_signed_cert.child_certificate["charlie.example.com"]: Creating... ⑤
tls_locally_signed_cert.child_certificate["bravo.example.com"]: Creating...   ⑤
tls_locally_signed_cert.child_certificate["example.com"]: Creating...        ⑥

Apply complete! Resources: 11 added, 0 changed, 0 destroyed.                ⑥
```

**What's Happening:**
1. **① Parallel Creation**: Private keys have no dependencies, so they all start simultaneously
2. **② Unique IDs**: Each resource gets a unique identifier when created
3. **③ Dependency Chain**: Certificate requests wait for private keys to complete
4. **④ CA Certificate**: Special certificate that will sign the others
5. **⑤ Final Certificates**: Wait for both requests and CA certificate
6. **⑥ Summary**: Total count of changes made

## Three Ways to Apply Changes

### 1. Plan and Apply in One Command (Quick Development)
```bash
# Terraform creates a plan and shows it to you
terraform apply

# You see the plan output, then get prompted:
# Do you want to perform these actions?
#   Terraform will perform the actions described above.
#   Only 'yes' will be accepted to approve.
#   Enter a value: yes
```

**How it works:**
- Terraform runs `plan` internally
- Shows you what will change
- Asks for confirmation
- Applies if you type "yes"

**Good for:**
- Development and testing
- Small, simple changes
- When you want to see and apply changes quickly

**You can still use all plan options:**
```bash
# With variables (from Chapter 5.4)
terraform apply -var="environment=dev"

# With variable files
terraform apply -var-file="dev.tfvars"

# Target specific resources (use carefully!)
terraform apply -target="aws_instance.web"
```

### 2. Auto-Approve (Dangerous!)
```bash
# Skips the confirmation prompt
terraform apply -auto-approve
```

**⚠️ Warning: Use with extreme caution!**
- No chance to review before changes happen
- Can't catch mistakes before they affect infrastructure
- Good for:
  - Automated CI/CD pipelines (with proper safeguards)
  - Destroying test environments
  - When you're absolutely certain of the changes

**Bad for:**
- Production environments
- When you haven't reviewed the plan
- Any time you're unsure about changes

### 3. Using a Plan File (Recommended for Production)
```bash
# Step 1: Create and save a plan
terraform plan -out=mychanges.tfplan

# Step 2: Review the plan (optional but recommended)
terraform show mychanges.tfplan

# Step 3: Apply the exact plan you reviewed
terraform apply mychanges.tfplan
```

**Key Benefits:**
- **Separation of concerns**: Planning and applying are separate steps
- **Review time**: You can take time to review before applying
- **Team collaboration**: Others can review the plan file
- **Consistency**: Exactly what you planned is what gets applied
- **Automation friendly**: Perfect for CI/CD pipelines

**Important Notes:**
- When using a plan file, Terraform **doesn't ask for confirmation**
- It assumes you already approved the plan when you created it
- File extension doesn't matter, but `.tfplan` is the standard
- Plan files are binary format (not human-readable)

**Common Workflow:**
```bash
# Development
terraform plan -out="$(date +%Y%m%d)-add-database.tfplan"
terraform show add-database.tfplan  # Review
terraform apply add-database.tfplan  # Apply

# Production (with team review)
terraform plan -out="prod-changes.tfplan"
# Team reviews the plan
terraform apply prod-changes.tfplan  # Deploy
```

## Destroying Infrastructure

### The Destroy Command
```bash
# terraform destroy is actually just:
terraform apply -destroy

# Both commands do the same thing:
terraform destroy
terraform apply -destroy
```

**How Destroy Works:**
1. Creates a destroy plan (shows what will be deleted)
2. Asks for confirmation
3. Destroys resources in reverse dependency order

### Destroy Process Example
```bash
$ terraform destroy

# First, Terraform refreshes state to see what exists
tls_private_key.ca_key: Refreshing state...
tls_self_signed_cert.ca_cert: Refreshing state...
# ... (all resources)

# Then shows the destroy plan
Terraform will perform the following actions:
  # All resources will be destroyed
  - resource "tls_private_key" "ca_key" { ... }
  - resource "tls_self_signed_cert" "ca_cert" { ... }
  # ... (all resources marked with -)

Plan: 0 to add, 0 to change, 11 to destroy.

# Asks for confirmation
Do you really want to destroy all resources?
  Enter a value: yes

# Then destroys in reverse order
tls_locally_signed_cert.child_certificate["example.com"]: Destroying...
# ... (certificates first)
tls_private_key.ca_key: Destroying...
# ... (keys last)

Destroy complete! Resources: 11 destroyed.
```

### Destroy Safety Tips

**⚠️ Destroy is VERY dangerous:**
- Deletes infrastructure **permanently**
- Usually **cannot be undone**
- Happens **very quickly**
- Easy to run in wrong directory/environment

**Safety Practices:**
```bash
# ✅ Good - Always review first
terraform destroy  # Review the plan, then confirm

# ⚠️ Risky - Auto-approve (only for test environments)
terraform destroy -auto-approve

# ✅ Better - Use plan files for important destroys
terraform plan -destroy -out=destroy.tfplan
terraform show destroy.tfplan  # Review what will be destroyed
terraform apply destroy.tfplan  # Execute the destroy
```

**When Auto-Approve Might Be OK:**
- Personal development environments
- Temporary test resources
- CI/CD cleanup of test environments
- When you're 100% certain of what you're destroying

**When to NEVER Use Auto-Approve:**
- Production environments
- Shared development environments
- When you're not sure which environment you're in
- Resources that contain important data

### Understanding Destroy Order

Terraform destroys resources in **reverse dependency order** - the opposite of creation:

```bash
# Creation order (from Chapter 5.1 DAG):
# 1. Private keys (no dependencies)
# 2. CA certificate (depends on CA key)
# 3. Certificate requests (depend on domain keys)
# 4. Signed certificates (depend on requests + CA)

# Destroy order (reversed):
# 1. Signed certificates (destroyed first)
# 2. Certificate requests
# 3. CA certificate
# 4. Private keys (destroyed last)
```

**Why This Order Matters:**
- Resources that depend on others are destroyed first
- Dependencies are destroyed last
- Prevents "resource in use" errors
- Follows the DAG from Chapter 5.1, but backwards

### Destroy Example Output
```bash
$ terraform destroy -auto-approve

# 1. Refresh phase - check current state
tls_private_key.child_key["example.com"]: Refreshing state...
tls_self_signed_cert.ca_cert: Refreshing state...
# ... (all resources)

# 2. Plan phase - show what will be destroyed
Plan: 0 to add, 0 to change, 11 to destroy.

# 3. Apply phase - destroy in reverse order
# First: Certificates that depend on others
tls_locally_signed_cert.child_certificate["example.com"]: Destroying...
tls_locally_signed_cert.child_certificate["example.com"]: Destruction complete

# Then: Certificate requests
tls_cert_request.child_request["example.com"]: Destroying...
tls_cert_request.child_request["example.com"]: Destruction complete

# Finally: Private keys (no dependencies)
tls_private_key.child_key["example.com"]: Destroying...
tls_private_key.child_key["example.com"]: Destruction complete

Destroy complete! Resources: 11 destroyed.
```

With that one command, we’ve now destroyed all of the resources that we were managing with Terraform. Running terraform destroy is one of the scariest things you can do. You are going to wipe out a lot of infrastructure very, very quickly. Reviewing the plan is one way to prevent mistakes. Using a centralized CI/CD system for managing your production environments, and then removing any direct logins to those environments from your machine, is another way to prevent you from accidentally making a very bad mistake when running a destroy command. If you can’t even access the infrastructure from your development machine, you can’t accidentally destroy it.

## Best Practices for Safe Apply Operations

### 1. Always Review Before Applying
```bash
# ✅ Good - Review first
terraform plan -out=changes.tfplan
terraform show changes.tfplan  # Review the changes
terraform apply changes.tfplan  # Apply what you reviewed

# ❌ Dangerous - Blind apply
terraform apply -auto-approve
```

### 2. Use Descriptive Plan Names
```bash
# ✅ Good - Clear naming
terraform plan -out="2024-01-15-add-database-backup.tfplan"

# ❌ Bad - Generic naming
terraform plan -out="plan.tfplan"
```

### 3. Environment Safety
```bash
# Verify you're in the right environment
echo $TF_VAR_environment  # Check environment variable
terraform workspace show  # Check workspace
pwd                       # Check directory

# Use different AWS profiles for different environments
export AWS_PROFILE=dev      # For development
export AWS_PROFILE=prod     # For production
```

### 4. Production Safety Measures

**Centralized CI/CD:**
- Remove direct access to production from developer machines
- All production changes go through CI/CD pipeline
- Require approvals before applying changes
- Use separate AWS accounts/subscriptions for environments

**Plan File Workflow:**
```bash
# Development team creates plan
terraform plan -out=prod-changes.tfplan

# Operations team reviews and applies
terraform show prod-changes.tfplan  # Review
terraform apply prod-changes.tfplan  # Apply
```

### 5. Destroy Safety

**The Golden Rule: If you can't access it, you can't accidentally destroy it**

```bash
# ✅ Safe patterns
# - Use separate AWS accounts for prod
# - Remove prod access from dev machines
# - Require MFA for production access
# - Use CI/CD for all prod changes

# ⚠️ Risky patterns
# - Same credentials for all environments
# - Direct prod access from laptops
# - Auto-approve in production
```

## Common Apply Workflows

### Development Workflow
```bash
# Quick iteration
terraform apply  # Review and confirm

# Or with plan file
terraform plan -out=dev.tfplan
terraform apply dev.tfplan
```

### Production Workflow
```bash
# 1. Create plan
terraform plan -var-file="prod.tfvars" -out="prod-$(date +%Y%m%d).tfplan"

# 2. Team review (via CI/CD or manual)
terraform show "prod-$(date +%Y%m%d).tfplan"

# 3. Apply after approval
terraform apply "prod-$(date +%Y%m%d).tfplan"
```

### Emergency Workflow
```bash
# For urgent fixes (still be careful!)
terraform plan -target="aws_security_group.emergency_fix"
terraform apply -target="aws_security_group.emergency_fix"

# Follow up with full plan later
terraform plan  # Ensure no other changes needed
```

## Key Takeaways

1. **Apply executes your plans** - It's where infrastructure changes become real
2. **Three apply methods** - Direct, auto-approve, and plan files
3. **Plan files are safest** - Separate planning from execution
4. **Destroy is dangerous** - Always review, consider auto-approve carefully
5. **Dependencies matter** - Resources are created/destroyed in proper order
6. **Safety first** - Review plans, use proper environments, limit access
7. **Consistency helps** - Use the same workflow patterns across your team

The apply stage is where your infrastructure code becomes real infrastructure. Use it wisely, and always remember: you can create quickly, but mistakes can be costly to fix!