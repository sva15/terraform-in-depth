# Chapter 5.6: Apply and Plan Options

## What This Chapter is About

This chapter explains **advanced options for terraform plan and apply commands** - special flags that can help with debugging, automation, and specific scenarios. While you won't use these daily, they're valuable tools when you need them.

## Key Concept: Fine-Tuning Terraform Behavior

Think of these options like:
- **Car settings**: Adjusting mirrors, seat position, and radio for different driving conditions
- **Camera controls**: Manual settings for special photography situations
- **Kitchen tools**: Specialized utensils you don't use every day, but are perfect for specific tasks

## Parallelism Control

### Understanding Terraform's Parallel Execution

By default, Terraform runs **up to 10 operations simultaneously**:

```bash
# Default behavior (10 parallel operations)
terraform apply

# Custom parallelism
terraform plan -parallelism=5   # Run 5 operations at once
terraform apply -parallelism=1  # Run operations one at a time
```

### What Counts as an "Operation"?
- Creating a resource
- Updating a resource  
- Deleting a resource
- Reading resource status
- Data source queries

### Why More Isn't Always Better

**1. Dependencies Limit Parallelism (from Chapter 5.1 DAGs)**
```bash
# These MUST happen in order:
# 1. VPC created first
# 2. Subnets created after VPC
# 3. Instances created after subnets

# Even with -parallelism=100, this still takes 3 steps
resource "aws_vpc" "main" { ... }           # Step 1
resource "aws_subnet" "private" { ... }     # Step 2 (waits for VPC)
resource "aws_instance" "app" { ... }       # Step 3 (waits for subnet)
```

**2. API Rate Limits**
```bash
# Cloud providers limit how fast you can make API calls
# AWS: ~10-20 requests/second per service
# Azure: Varies by service
# GCP: Varies by service

# Higher parallelism might hit rate limits and actually slow things down
terraform apply -parallelism=50  # Might trigger rate limiting
```

### When to Adjust Parallelism

**Increase Parallelism (Rare):**
```bash
# When you have many independent resources
terraform apply -parallelism=20

# Good for:
# - Many S3 buckets (no dependencies)
# - Multiple DNS records
# - Independent security groups
```

**Decrease Parallelism (Common for Debugging):**
```bash
# Much easier to read logs when things happen one at a time
TF_LOG=DEBUG terraform plan -parallelism=1

# Good for:
# - Debugging complex errors
# - Understanding execution order
# - Troubleshooting provider issues
```

### Practical Debugging Example
```bash
# Hard to debug (10 things happening at once)
$ terraform apply
aws_instance.web[0]: Creating...
aws_instance.web[1]: Creating...
aws_security_group.app: Creating...
aws_db_instance.main: Creating...
# ... 6 more resources creating simultaneously
# Error messages get mixed together!

# Easy to debug (one at a time)
$ TF_LOG=DEBUG terraform apply -parallelism=1
aws_vpc.main: Creating...
aws_vpc.main: Creation complete after 2s
aws_subnet.private: Creating...
aws_subnet.private: Creation complete after 1s
# Clear, sequential execution - easy to see where problems occur
```

## State Locking

### What is State Locking?

Terraform **automatically locks the state file** during operations to prevent conflicts:

```bash
# When you run this...
terraform apply

# Terraform does this internally:
# 1. Lock the state file
# 2. Run the operation
# 3. Unlock the state file
```

**Why Locking Matters:**
- Prevents two people from running Terraform simultaneously
- Avoids state file corruption
- Ensures operations don't conflict with each other

### The Problem Without Locking
```bash
# Scenario: Two team members run terraform apply at the same time

# Person A starts:
terraform apply  # Creates aws_instance.web

# Person B starts (at the same time):
terraform apply  # Also tries to create aws_instance.web

# Result: Conflicting operations, corrupted state, broken infrastructure!
```

### Disabling Locks (Usually a Bad Idea!)
```bash
# Disable locking
terraform plan -lock=false
terraform apply -lock=false
```

**⚠️ Warning: This is dangerous!**
- Can corrupt your state file
- Can cause infrastructure conflicts
- Should almost never be used

### When Disabling Locks Might Be OK

**Speculative Plans (Safe):**
```bash
# For testing/PR reviews - not applying changes
terraform plan -lock=false -out=speculative.tfplan

# Safe because:
# - You're not making changes
# - Just generating a plan to review
# - No risk of state corruption
```

**Common Use Cases:**
- CI/CD pull request checks
- Testing configuration changes
- Generating plans for review
- Educational/learning purposes

### Lock Troubleshooting
```bash
# If you get a lock error:
# Error: Error locking state: Error acquiring the state lock

# Check who has the lock
terraform force-unlock LOCK_ID

# Only use force-unlock if you're certain no one else is running Terraform!
```

## JSON Output

### Why JSON Output Matters

Terraform CLI is the **only way** to run Terraform - there's no separate SDK:

```bash
# All automation must use the CLI
# - CI/CD pipelines
# - Custom scripts
# - Infrastructure management tools
```

### Human vs Machine Output

**Human-Readable (Default):**
```bash
$ terraform plan

Terraform will perform the following actions:

  # aws_instance.web will be created
  + resource "aws_instance" "web" {
      + ami           = "ami-12345678"
      + instance_type = "t3.micro"
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

**Machine-Readable (JSON):**
```bash
$ terraform plan -json
{"@level":"info","@message":"Terraform 1.5.0","@module":"terraform.ui"}
{"type":"planned_change","change":{"resource":{"addr":"aws_instance.web"}}}
# ... structured data that programs can easily parse
```

### Using JSON Output
```bash
# Get plan in JSON format
terraform plan -json > plan.json

# Get apply output in JSON
terraform apply -json > apply.json

# Show saved plan as JSON
terraform show -json plan.tfplan > plan-details.json
```

**Perfect for:**
- CI/CD automation
- Custom tooling
- Integration with other systems
- Programmatic analysis

**Note:** We'll cover JSON integration in detail in Chapter 11.

## Output Formatting Options

### Simple Formatting Flags

These flags change **how** Terraform displays information, not **what** it does:

### Remove Colors
```bash
# Default (with colors)
terraform plan
# Output has green +, red -, yellow ~ symbols

# No colors (plain text)
terraform plan -no-color
# Output is plain black and white text
```

**When to use `-no-color`:**
- CI/CD systems that don't support colors
- Log files (colors show as weird characters)
- Email reports
- Text processing scripts

### Compact Warnings
```bash
# Default warnings (verbose)
terraform plan
# Shows full warning messages with explanations

# Compact warnings (shorter)
terraform plan -compact-warnings
# Shows abbreviated warning messages
```

**Example:**
```bash
# Default warning:
│ Warning: Argument is deprecated
│ 
│   on main.tf line 15, in resource "aws_instance" "web":
│   15:   availability_zone = "us-east-1a"
│ 
│ Use of availability_zone is deprecated. Use subnet_id instead.

# Compact warning:
│ Warning: Argument is deprecated (main.tf:15)
```

### Combining Options
```bash
# Multiple formatting options together
terraform plan -no-color -compact-warnings -parallelism=1

# Perfect for CI/CD logs
terraform apply -no-color -compact-warnings -json > deployment.log
```

## Best Practices for Options

### Development Environment
```bash
# Keep defaults for interactive use
terraform plan
terraform apply

# Use parallelism=1 only for debugging
TF_LOG=DEBUG terraform plan -parallelism=1
```

### CI/CD Environment
```bash
# Automation-friendly settings
terraform plan -no-color -compact-warnings -json -lock=false
terraform apply -no-color -compact-warnings -json plan.tfplan
```

### Debugging Environment
```bash
# Maximum visibility for troubleshooting
TF_LOG=DEBUG terraform plan -parallelism=1 -no-color > debug.log
```

## Key Takeaways

1. **Parallelism default is 10** - Usually perfect, adjust only for specific needs
2. **Dependencies limit parallelism** - DAGs from Chapter 5.1 determine execution order
3. **State locking prevents conflicts** - Automatic protection, rarely disable
4. **JSON output enables automation** - Essential for CI/CD and tooling
5. **Formatting flags help readability** - Especially important for logs and automation
6. **Debugging benefits from parallelism=1** - Easier to read sequential logs
7. **Most options are for special cases** - Default behavior works for daily use

These options are your "power tools" - you won't need them every day, but when you do need them, they're invaluable for debugging, automation, and specific scenarios.