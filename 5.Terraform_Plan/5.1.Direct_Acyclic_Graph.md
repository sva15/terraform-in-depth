# Chapter 5.1: Directed Acyclic Graphs

## What This Chapter is About

This chapter explains **Directed Acyclic Graphs (DAGs)** - the fundamental data structure that Terraform uses to understand dependencies between resources and determine the order of operations. Understanding DAGs helps you comprehend how Terraform plans and applies changes.

## Key Concept: Infrastructure as a Graph

Think of DAGs like:
- **Family trees**: Parents must exist before children, no circular relationships
- **Recipe steps**: Some steps depend on others, but you can't have circular dependencies
- **Construction blueprints**: Foundation before walls, walls before roof

## Understanding Graphs

### Basic Graph Components

```
Nodes (Vertices) = Resources/Infrastructure components
Edges (Connections) = Dependencies between resources
```

### Real-World Graph Examples

```t
# Family Tree (Directed Acyclic)
#     Grandparents
#      /        \
#   Parent1   Parent2
#      \        /
#       Children

# Organization Chart (Directed Acyclic)
#        CEO
#     /   |   \
#   VP1  VP2  VP3
#   /\    |    /\
# Mgr1 Mgr2 Mgr3 Mgr4

# Social Network (Undirected Cyclic)
# Alice ←→ Bob
#   ↑  \  / ↑
#   ↓   X   ↓
# Carol ←→ Dave
```

## Directed vs Undirected

### Directed Graphs
```t
# Dependencies have direction
# A → B means "B depends on A" or "A must be created before B"

# Example: VPC → Subnet → Instance
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "private" {
  vpc_id = aws_vpc.main.id  # Subnet depends on VPC
  cidr_block = "10.0.1.0/24"
}

resource "aws_instance" "app" {
  subnet_id = aws_subnet.private.id  # Instance depends on Subnet
}

# Dependency graph:
# VPC → Subnet → Instance
```

### Why Direction Matters
```t
# Creation order: VPC → Subnet → Instance
# Deletion order: Instance → Subnet → VPC (reversed)

# Terraform automatically determines this from the graph
```

## Acyclic vs Cyclic

### Acyclic (No Cycles)
```t
# ✅ Valid - No circular dependencies
resource "aws_s3_bucket" "logs" {
  bucket = "my-logs"
}

resource "aws_s3_bucket" "data" {
  bucket = "my-data"
  
  logging {
    target_bucket = aws_s3_bucket.logs.id  # data depends on logs
  }
}

# Graph: logs → data (one-way dependency)
```

### Cyclic (Has Cycles - NOT ALLOWED)
```t
# ❌ Invalid - Circular dependency
resource "aws_security_group" "app" {
  name = "app-sg"
  
  ingress {
    from_port       = 3000
    to_port         = 3000
    protocol        = "tcp"
    security_groups = [aws_security_group.db.id]  # app depends on db
  }
}

resource "aws_security_group" "db" {
  name = "db-sg"
  
  ingress {
    from_port       = 5432
    to_port         = 5432
    protocol        = "tcp"
    security_groups = [aws_security_group.app.id]  # db depends on app
  }
}

# Graph: app ←→ db (circular - Terraform will error!)
```

## TLS Certificate Example

### Understanding the Dependencies
```t
variable "domains" {
  type    = set(string)
  default = ["example.com", "app.example.com", "api.example.com"]
}

# 1. CA Private Key (no dependencies)
resource "tls_private_key" "ca_key" {
  algorithm = "ED25519"
}

# 2. CA Certificate (depends on CA key)
resource "tls_self_signed_cert" "ca_cert" {
  private_key_pem   = tls_private_key.ca_key.private_key_pem
  is_ca_certificate = true
  
  subject {
    common_name  = "TiD CA"
    organization = "Terraform in Depth"
  }
  
  validity_period_hours = 24
  
  allowed_uses = [
    "digital_signature",
    "cert_signing",
    "crl_signing"
  ]
}

# 3. Domain Private Keys (one per domain, no dependencies)
resource "tls_private_key" "domain_key" {
  for_each  = var.domains
  algorithm = "ECDSA"
}

# 4. Certificate Requests (depends on domain keys)
resource "tls_cert_request" "domain_request" {
  for_each        = var.domains
  private_key_pem = tls_private_key.domain_key[each.value].private_key_pem
  
  subject {
    common_name  = each.value
    organization = "Terraform in Depth"
  }
}

# 5. Signed Certificates (depends on requests, CA key, and CA cert)
resource "tls_locally_signed_cert" "domain_certificate" {
  for_each           = var.domains
  cert_request_pem   = tls_cert_request.domain_request[each.value].cert_request_pem
  ca_private_key_pem = tls_private_key.ca_key.private_key_pem
  ca_cert_pem        = tls_self_signed_cert.ca_cert.cert_pem
  
  validity_period_hours = 12
  
  allowed_uses = [
    "key_encipherment",
    "digital_signature",
    "server_auth",
  ]
}
```

### Visualizing the DAG
```
                    Provider (TLS)
                    /     |      \
                   /      |       \
           ca_key    domain_key[*]  (no dependencies on each other)
              |           |
           ca_cert   domain_request[*]
               \         /
                \       /
             domain_certificate[*]
```

## How Terraform Uses DAGs

### Dependency Resolution
```t
# Terraform automatically detects dependencies
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id  # Implicit dependency
}

resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block             = "10.0.1.0/24"
  map_public_ip_on_launch = true
  
  depends_on = [aws_internet_gateway.main]  # Explicit dependency
}

# Terraform builds this DAG:
# vpc → internet_gateway
#  ↓          ↓
#  → → subnet ←
```

### Parallel Execution
```t
# Resources with no dependencies between them can be created in parallel

resource "aws_s3_bucket" "logs" {
  bucket = "${var.prefix}-logs"
}

resource "aws_s3_bucket" "data" {
  bucket = "${var.prefix}-data"
}

resource "aws_s3_bucket" "backups" {
  bucket = "${var.prefix}-backups"
}

# All three buckets can be created simultaneously
# DAG: Three independent nodes
```

### Complex Dependencies
```t
# Multi-tier application infrastructure
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index)
  availability_zone = data.aws_availability_zones.available.names[count.index]
}

resource "aws_subnet" "private" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index + 100)
  availability_zone = data.aws_availability_zones.available.names[count.index]
}

resource "aws_security_group" "web" {
  vpc_id = aws_vpc.main.id
  # ... rules
}

resource "aws_security_group" "app" {
  vpc_id = aws_vpc.main.id
  # ... rules
}

resource "aws_lb" "main" {
  subnets         = aws_subnet.public[*].id
  security_groups = [aws_security_group.web.id]
}

resource "aws_instance" "app" {
  count                  = 2
  subnet_id              = aws_subnet.private[count.index].id
  vpc_security_group_ids = [aws_security_group.app.id]
}

# The resulting DAG allows Terraform to:
# 1. Create VPC first
# 2. Create subnets and security groups in parallel
# 3. Create load balancer and instances after their dependencies
```

## Practical Implications

### 1. Automatic Ordering
```t
# You can write resources in any order
# Terraform figures out the correct execution order

# This works even though DB is defined after the app
resource "aws_instance" "app" {
  # ...
  user_data = <<-EOF
    #!/bin/bash
    echo "DB_HOST=${aws_db_instance.database.address}" > /etc/app.conf
  EOF
}

resource "aws_db_instance" "database" {
  # ...
}

# Terraform knows: database must be created before app
```

### 2. Parallelization
```t
# Independent resources are created/updated in parallel
# This speeds up operations significantly

# These will all be processed in parallel:
resource "aws_route53_zone" "main" {
  name = "example.com"
}

resource "aws_acm_certificate" "cert" {
  domain_name = "example.com"
}

resource "aws_wafv2_web_acl" "main" {
  name  = "rate-limit"
  scope = "CLOUDFRONT"
  # ...
}
```

### 3. Understanding Errors
```t
# When Terraform shows cycle errors, visualize the graph

# Error: Cycle: aws_security_group.a, aws_security_group.b

# This means you have: a → b → a (circular dependency)
# Solution: Break the cycle (often using separate security group rules)
```

## Best Practices

### 1. Keep Dependencies Clear
```t
# ✅ Good - Clear dependency chain
resource "aws_vpc" "main" {}
resource "aws_subnet" "main" { vpc_id = aws_vpc.main.id }
resource "aws_instance" "main" { subnet_id = aws_subnet.main.id }
```

### 2. Avoid Unnecessary Dependencies
```t
# ❌ Bad - Unnecessary depends_on
resource "aws_s3_bucket" "data" {
  bucket = "my-data"
  depends_on = [aws_s3_bucket.logs]  # Not needed!
}

# ✅ Good - Let Terraform figure it out
resource "aws_s3_bucket" "data" {
  bucket = "my-data"
}
```

### 3. Break Circular Dependencies
```t
# ❌ Problem: Circular security groups
# ✅ Solution: Use separate rule resources

resource "aws_security_group" "app" {
  name   = "app"
  vpc_id = aws_vpc.main.id
}

resource "aws_security_group" "db" {
  name   = "db"
  vpc_id = aws_vpc.main.id
}

# Separate rules prevent cycles
resource "aws_security_group_rule" "app_to_db" {
  type                     = "egress"
  from_port                = 5432
  to_port                  = 5432
  protocol                 = "tcp"
  security_group_id        = aws_security_group.app.id
  source_security_group_id = aws_security_group.db.id
}

resource "aws_security_group_rule" "db_from_app" {
  type                     = "ingress"
  from_port                = 5432
  to_port                  = 5432
  protocol                 = "tcp"
  security_group_id        = aws_security_group.db.id
  source_security_group_id = aws_security_group.app.id
}
```

## Key Takeaways

1. **Terraform represents infrastructure as a DAG** - This enables automatic ordering
2. **Directed = Dependencies have direction** - Creation flows one way
3. **Acyclic = No circular dependencies** - Prevents impossible situations
4. **Nodes = Resources, Edges = Dependencies** - Clear mental model
5. **DAGs enable parallelization** - Independent resources process simultaneously
6. **Understanding DAGs helps debugging** - Especially cycle errors
7. **Let Terraform build the graph** - Avoid unnecessary explicit dependencies

Understanding DAGs is key to understanding how Terraform "thinks" about your infrastructure and why it makes certain decisions about ordering and parallelization.
