# Chapter 5.4: Root-Level Module Input Variables

## What This Chapter is About

This chapter explains **root-level module input variables** - how to provide values to your Terraform configurations to customize deployments. These inputs are what make your code reusable across different environments and scenarios.

## Key Concept: Input Variables = Configuration Flexibility

Think of input variables like:
- **Recipe adjustments**: Same recipe, different portion sizes or substitutions
- **Application settings**: Same app configured differently for dev/staging/prod
- **Template parameters**: Fill in the blanks to customize the output

## Methods for Setting Variables

### 1. Interactive Input
```bash
# When variable has no default and no value provided
$ terraform plan

var.instance_type
  Enter a value: t3.micro

var.environment
  Enter a value: production
```

**Characteristics:**
- Terraform prompts for missing values
- Good for testing/development
- Bad for automation
- Error-prone in production

**Disable Interactive Mode:**
```bash
# Fail instead of prompting
terraform plan -input=false
# Error: No value for required variable
```

### 2. Command Line Variables (-var)
```bash
# Single variable
terraform plan -var="instance_type=t3.micro"

# Multiple variables
terraform plan \
  -var="instance_type=t3.micro" \
  -var="environment=production" \
  -var="instance_count=3"

# Complex types (gets messy!)
terraform plan -var='tags={"Environment":"prod","Team":"platform"}'
```

**Pros:**
- Quick for testing
- Can copy/paste commands
- Version control friendly (in scripts)

**Cons:**
- Shell escaping issues
- Complex types are painful
- Different syntax across OS
- Visible in shell history

### 3. Variable Files (.tfvars)

#### HCL Format (.tfvars)
```hcl
# production.tfvars
# Production environment configuration

instance_type  = "t3.large"
instance_count = 5
environment    = "production"

# Complex types are easy
tags = {
  Environment = "production"
  Team        = "platform"
  CostCenter  = "engineering"
}

database_config = {
  engine         = "postgres"
  version        = "14.7"
  instance_class = "db.r5.xlarge"
  multi_az       = true
}

allowed_cidrs = [
  "10.0.0.0/8",
  "172.16.0.0/12"
]
```

#### JSON Format (.tfvars.json)
```json
{
  "instance_type": "t3.large",
  "instance_count": 5,
  "environment": "production",
  "tags": {
    "Environment": "production",
    "Team": "platform",
    "CostCenter": "engineering"
  },
  "database_config": {
    "engine": "postgres",
    "version": "14.7",
    "instance_class": "db.r5.xlarge",
    "multi_az": true
  },
  "allowed_cidrs": [
    "10.0.0.0/8",
    "172.16.0.0/12"
  ]
}
```

#### Using Variable Files
```bash
# Explicit file
terraform plan -var-file="production.tfvars"

# Multiple files
terraform plan \
  -var-file="common.tfvars" \
  -var-file="production.tfvars"

# Auto-loaded files (no -var-file needed)
# - terraform.tfvars
# - terraform.tfvars.json
# - *.auto.tfvars
# - *.auto.tfvars.json
```

### 4. Environment Variables
```bash
# Set variables with TF_VAR_ prefix
export TF_VAR_instance_type="t3.micro"
export TF_VAR_environment="production"
export TF_VAR_instance_count=3

# Complex types via environment variables
export TF_VAR_tags='{"Environment":"prod","Team":"platform"}'

# Now run terraform without specifying vars
terraform plan
```

**Common Use Cases:**
- CI/CD pipelines
- Provider credentials
- Secrets (with caution)

## Variable Precedence (Highest to Lowest)

```bash
# 1. Command line flags (last one wins)
terraform plan -var="env=dev" -var="env=prod"  # prod wins

# 2. *.auto.tfvars files (alphabetical order)
# - common.auto.tfvars
# - production.auto.tfvars  # wins if both define same var

# 3. terraform.tfvars.json

# 4. terraform.tfvars

# 5. Environment variables
export TF_VAR_env="staging"

# 6. Default values in configuration
variable "env" {
  default = "dev"
}

# 7. Interactive input (if enabled)
```

## Real-World Patterns

### Environment-Specific Files
```bash
# Directory structure
terraform/
├── main.tf
├── variables.tf
├── environments/
│   ├── dev.tfvars
│   ├── staging.tfvars
│   └── production.tfvars
└── common.auto.tfvars

# Usage
terraform plan -var-file="environments/dev.tfvars"
terraform plan -var-file="environments/production.tfvars"
```

### Common + Environment Pattern
```hcl
# common.auto.tfvars - Shared across all environments
project_name = "myapp"
region       = "us-east-1"
tags = {
  ManagedBy = "Terraform"
  Project   = "MyApp"
}

# production.tfvars - Production-specific
environment    = "production"
instance_type  = "t3.xlarge"
instance_count = 10
enable_backups = true
backup_retention_days = 30

# dev.tfvars - Development-specific
environment    = "dev"
instance_type  = "t3.micro"
instance_count = 1
enable_backups = false
backup_retention_days = 0
```

### CI/CD Integration
```yaml
# GitHub Actions example
env:
  TF_VAR_environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
  
steps:
  - name: Terraform Plan
    run: |
      terraform plan \
        -var-file="environments/${TF_VAR_environment}.tfvars" \
        -out=plan.tfplan
```

## Handling Secrets

### Problem: Variables Can Leak
```bash
# ❌ Bad - Visible in logs, history
terraform plan -var="db_password=supersecret123"

# ❌ Bad - In version control
# secrets.tfvars
db_password = "supersecret123"

# ❌ Bad - In environment
export TF_VAR_db_password="supersecret123"
env | grep TF_VAR  # Exposed!
```

### Solution 1: CI/CD Secret Management
```yaml
# GitHub Actions
steps:
  - name: Terraform Plan
    env:
      TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
    run: terraform plan

# GitLab CI
variables:
  TF_VAR_db_password: $DB_PASSWORD  # From GitLab secrets
```

### Solution 2: Secret Manager References
```hcl
# Instead of password, pass secret path
variable "db_password_secret_name" {
  description = "Name of secret in AWS Secrets Manager"
  type        = string
}

# Retrieve in Terraform
data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = var.db_password_secret_name
}

resource "aws_db_instance" "main" {
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}
```

### Solution 3: Provider Authentication
```bash
# Use provider-specific auth methods
# AWS - IAM roles
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/TerraformRole

# Azure - Service Principal
az login --service-principal \
  --username $ARM_CLIENT_ID \
  --password $ARM_CLIENT_SECRET \
  --tenant $ARM_TENANT_ID

# These avoid putting credentials in Terraform
```

## Best Practices

### 1. Choose One Primary Method
```bash
# Consistency prevents confusion
# Example: Always use var files for configuration

# ✅ Good - Consistent pattern
terraform plan -var-file="environments/prod.tfvars"

# ❌ Avoid - Mixing methods
terraform plan \
  -var="env=prod" \
  -var-file="some-values.tfvars" \
  # Plus ENV vars and auto.tfvars...
```

### 2. Document Variables
```hcl
# variables.tf
variable "instance_type" {
  description = "EC2 instance type (e.g., t3.micro, t3.small)"
  type        = string
  
  validation {
    condition     = can(regex("^t3\\.", var.instance_type))
    error_message = "Instance type must be from t3 family."
  }
}

# In README or tfvars template
# instance_type - EC2 instance type
# Options: t3.micro (dev), t3.small (staging), t3.large (prod)
# Default: none (required)
```

### 3. Use Validation
```hcl
variable "environment" {
  type = string
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}
```

### 4. Organize Variable Files
```bash
# Good structure
terraform/
├── tfvars/
│   ├── README.md           # Documentation
│   ├── template.tfvars     # Example with all variables
│   ├── dev.tfvars
│   ├── staging.tfvars
│   └── production.tfvars
├── common.auto.tfvars      # Shared values
└── terraform.tfvars        # Local overrides (gitignored)
```

### 5. Sensitive Value Handling
```hcl
# Mark sensitive in variable definition
variable "api_key" {
  description = "API key for external service"
  type        = string
  sensitive   = true  # Won't show in logs
}

# .gitignore
*.tfvars        # If contains secrets
terraform.tfvars # Local secrets
```

## Common Patterns

### Multi-Region Deployment
```hcl
# regions.tfvars
regions = {
  primary = {
    name = "us-east-1"
    azs  = ["us-east-1a", "us-east-1b", "us-east-1c"]
  }
  secondary = {
    name = "eu-west-1"
    azs  = ["eu-west-1a", "eu-west-1b", "eu-west-1c"]
  }
}

# Usage in configuration
provider "aws" {
  alias  = "primary"
  region = var.regions.primary.name
}

provider "aws" {
  alias  = "secondary"
  region = var.regions.secondary.name
}
```

### Feature Flags
```hcl
# features.tfvars
features = {
  enable_monitoring   = true
  enable_backups     = true
  enable_auto_scaling = false
  enable_cdn         = true
}

# In configuration
resource "aws_cloudwatch_dashboard" "main" {
  count = var.features.enable_monitoring ? 1 : 0
  # ...
}
```

## Key Takeaways

1. **Multiple input methods** - Interactive, CLI, files, environment variables
2. **Variable files are best for most cases** - Versionable and readable
3. **Precedence matters** - CLI flags override everything
4. **Auto-loading is convenient** - *.auto.tfvars and terraform.tfvars
5. **Don't commit secrets** - Use secret managers or CI/CD systems
6. **Be consistent** - Pick a method and stick with it
7. **Environment variables for CI/CD** - Especially for authentication
8. **Validation prevents errors** - Catch bad inputs early

Input variables are what make your Terraform code truly reusable - the same code can deploy to dev, staging, or production just by changing the inputs.
