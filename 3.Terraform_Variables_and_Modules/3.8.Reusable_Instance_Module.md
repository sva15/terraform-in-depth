# Chapter 3.8: A Reusable Instance Module

## What This Chapter is About

This chapter demonstrates building a **reusable module** by converting a simple EC2 instance program into a flexible, configurable module that others can use. It shows the complete process from refactoring to publishing.

## Key Concept: From Program to Module

Think of this transformation like:
- **Recipe to cookbook**: Converting a single recipe into a flexible template others can customize
- **Prototype to product**: Taking a working prototype and making it configurable for different users
- **Script to library**: Converting a one-off script into a reusable library function

## The Goal: Making Code Reusable

### Original Limitations
```t
# Before - Hardcoded values, single use
resource "aws_instance" "hello_world" {
  ami           = data.aws_ami.ubuntu.id
  subnet_id     = data.aws_subnets.default.ids[0]  # Always default subnet
  instance_type = "t3.micro"                        # Always t3.micro
}
```

### Target Improvements
1. **Configurable subnet** - Support custom VPC setups
2. **Selectable instance type** - Support different workloads
3. **Expose instance metadata** - Allow integration with other resources

## Step 1: Refactoring for Module Use

### Remove Provider Configuration
```t
# providers.tf - BEFORE (root module)
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {              # ❌ DELETE THIS BLOCK
  region = var.aws_region     # Provider blocks only in root modules
}

# providers.tf - AFTER (reusable module)
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
# NO provider block - that's the user's responsibility
```

## Step 2: Adding Input Variables

### Create variables.tf
```t
# variables.tf
variable "instance_type" {
  type        = string
  description = "The type of instance to launch"
  default     = "t3.micro"  # Sensible default
}

variable "subnet_id" {
  type        = string
  description = "The ID of the Subnet to launch the instance into"
  
  validation {
    condition = length(regexall("^subnet-[\\d|\\w]+$", var.subnet_id)) == 1
    error_message = "The subnet_id must match the pattern ^subnet-[\\d|\\w]+$"
  }
}
```

### Update main.tf to Use Variables
```t
# main.tf
resource "aws_instance" "hello_world" {
  ami           = data.aws_ami.ubuntu.id
  subnet_id     = var.subnet_id      # Now configurable
  instance_type = var.instance_type  # Now configurable
}
```

## Step 3: Adding Outputs

### Create outputs.tf
```t
# outputs.tf
output "aws_instance_arn" {
  description = "The ARN of the created instance"
  value       = aws_instance.hello_world.arn
}

output "aws_instance_ip" {
  description = "The private IP address of the instance"
  value       = aws_instance.hello_world.private_ip
}

output "aws_instance" {
  description = "The complete instance resource"
  value       = aws_instance.hello_world
}
```

## Step 4: Testing the Module

### Create Test Workspace Structure
```
terraform-aws-in-depth/
├── modules/
│   └── ec2_instance/
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       └── providers.tf
└── example/
    ├── providers.tf
    └── main.tf
```

### Example providers.tf
```t
# example/providers.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

variable "region" {
  type        = string
  default     = "us-east-1"
  description = "The AWS Region to connect and run the tests in"
}

provider "aws" {
  region = var.region
}
```

### Example main.tf
```t
# example/main.tf
# Look up default VPC and subnets
data "aws_vpc" "default" {
  default = true
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# Use our module
module "test_instance" {
  source    = "../"
  subnet_id = data.aws_subnets.default.ids[0]
  # instance_type uses default value
}

# Display outputs
output "aws_instance_arn" {
  value = module.test_instance.aws_instance_arn
}
```

### Running the Test
```bash
cd example
terraform init
terraform apply
```

## Step 5: Publishing to GitHub

### Repository Structure
```
terraform-aws-in-depth/           # Repository name
└── modules/
    └── ec2_instance/
        ├── README.md
        ├── main.tf
        ├── variables.tf
        ├── outputs.tf
        └── example/
            ├── main.tf
            └── providers.tf
```

### Using the Published Module
```t
module "my_instance" {
  source = "github.com/YOUR_USERNAME/terraform-aws-in-depth//modules/ec2_instance"
  
  subnet_id     = var.subnet_id
  instance_type = "t3.large"  # Override default
}

output "instance_arn" {
  value = module.my_instance.aws_instance_arn
}
```

## Complete Module Example

### Final Module Structure

**variables.tf**
```t
variable "instance_type" {
  type        = string
  description = "The EC2 instance type"
  default     = "t3.micro"
  
  validation {
    condition     = can(regex("^[a-z][0-9][a-z]?\\..*", var.instance_type))
    error_message = "Must be a valid EC2 instance type."
  }
}

variable "subnet_id" {
  type        = string
  description = "The subnet to launch the instance in"
  
  validation {
    condition     = can(regex("^subnet-[a-f0-9]+$", var.subnet_id))
    error_message = "Must be a valid subnet ID."
  }
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to the instance"
  default     = {}
}
```

**main.tf**
```t
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]  # Canonical
  
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
  
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

resource "aws_instance" "hello_world" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type
  subnet_id     = var.subnet_id
  
  tags = merge(var.tags, {
    Name      = "HelloWorld"
    ManagedBy = "Terraform"
  })
}
```

**outputs.tf**
```t
output "instance_id" {
  description = "The ID of the instance"
  value       = aws_instance.hello_world.id
}

output "instance_arn" {
  description = "The ARN of the instance"
  value       = aws_instance.hello_world.arn
}

output "private_ip" {
  description = "The private IP of the instance"
  value       = aws_instance.hello_world.private_ip
}

output "instance" {
  description = "The complete instance object"
  value       = aws_instance.hello_world
}
```

## Using the Module in Different Scenarios

### Development Environment
```t
module "dev_server" {
  source = "github.com/YOUR_USERNAME/terraform-aws-in-depth//modules/ec2_instance"
  
  subnet_id     = data.aws_subnet.dev.id
  instance_type = "t3.micro"  # Small instance for dev
  
  tags = {
    Environment = "development"
    Owner       = "dev-team"
  }
}
```

### Production Environment
```t
module "prod_server" {
  source = "github.com/YOUR_USERNAME/terraform-aws-in-depth//modules/ec2_instance"
  
  subnet_id     = data.aws_subnet.private.id
  instance_type = "m5.xlarge"  # Larger instance for prod
  
  tags = {
    Environment = "production"
    Owner       = "ops-team"
    CostCenter  = "engineering"
  }
}
```

## Best Practices Demonstrated

### 1. Sensible Defaults
```t
variable "instance_type" {
  default = "t3.micro"  # Safe, cheap default
}
```

### 2. Input Validation
```t
validation {
  condition     = can(regex("^subnet-[a-f0-9]+$", var.subnet_id))
  error_message = "Must be a valid subnet ID."
}
```

### 3. Flexible Outputs
```t
# Specific values for common use
output "instance_id" { }
output "private_ip" { }

# Full object for advanced use
output "instance" { }
```

### 4. Clear Documentation
```t
variable "subnet_id" {
  description = "The subnet to launch the instance in"
  # Clear, actionable description
}
```

## Key Takeaways

1. **Remove provider blocks** - Modules shouldn't configure providers
2. **Add input variables** - Make hardcoded values configurable
3. **Provide useful outputs** - Export data others will need
4. **Include validation** - Help users avoid mistakes
5. **Test your module** - Create example usage to verify it works
6. **Document clearly** - Help others understand how to use your module

This transformation from a single-use program to a reusable module is the foundation of building larger, maintainable Terraform infrastructures.
