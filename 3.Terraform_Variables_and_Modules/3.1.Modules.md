# Chapter 3.1: Modules 

## What This Chapter is About

This chapter dives deep into **modules** - Terraform's way of packaging infrastructure code for reuse. If Chapter 2 introduced modules briefly, this chapter explains them thoroughly as the standard way to share and organize Terraform code.

## Key Concept: Modules as Reusable Infrastructure Packages

Think of modules like:
- **Python**: Packages you import
- **JavaScript**: npm modules
- **Cooking**: Recipe cards you can use repeatedly

A module is both:
1. **Like a package**: A collection of related infrastructure
2. **Like a function**: Takes inputs, does work, returns outputs

## Types of Modules

### 1. Root Modules
- **What**: The starting point of any Terraform project
- **Where**: Your current working directory with `.tf` files
- **Special power**: Only place you can configure providers

```t
# This is a root module (your main project)
provider "aws" {
  region = "us-east-1"
}

module "networking" {
  source = "./modules/vpc"
}
```

### 2. Shared Modules
- **What**: Modules downloaded from registries or Git
- **Purpose**: Reuse code across projects
- **Sources**: Public registry, private registry, or Git repos

```t
# Using a shared module from the registry
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
}
```

### 3. Submodules
- **What**: Modules inside other modules
- **Where**: Usually in a `modules/` directory
- **Purpose**: Break complex modules into smaller pieces

```
my-infrastructure/
├── main.tf
├── modules/
│   ├── networking/
│   │   └── main.tf
│   └── compute/
│       └── main.tf
```

## Using Modules

### Basic Module Block
```t
module "name" {
  source = "where/to/find/it"
  
  # Module inputs (like function arguments)
  variable_name = "value"
}
```

### Module Meta-Arguments

#### 1. Source (Required)
Where to find the module:

```t
# From Terraform Registry
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
}

# From local filesystem
module "app" {
  source = "./modules/application"
}

# From Git
module "database" {
  source = "git::https://github.com/company/terraform-modules.git//rds"
}
```

#### 2. Version
Control which version to use:

```t
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"  # Use 5.x, but not 6.0
}
```

Version constraints:
- `"~> 5.0"` = Version 5.0 or higher, but less than 6.0
- `">= 5.0"` = Version 5.0 or any higher
- `"= 5.0.0"` = Exactly version 5.0.0

#### 3. Providers
Pass provider configurations to modules:

```t
module "us_resources" {
  source = "./modules/regional"
  
  providers = {
    aws = aws.us_east_1
  }
}
```

## Real Example: Using a VPN Module

Instead of writing dozens of resources for a VPN:

```t
module "vpn" {
  source  = "tedivm/cloudinit/general"
  version = "~> 1.0"
  
  # Module inputs
  services = ["consul", "nomad"]
}
```

This single module might create:
- VPN server instance
- Security groups
- Network routes
- Configuration files
- And more!

## Module File Structure

### Standard Layout
```
my-module/
├── main.tf          # Main resources
├── variables.tf     # Input variables
├── outputs.tf       # Output values
├── README.md        # Documentation
├── modules/         # Submodules
├── templates/       # Config templates
└── examples/        # Usage examples
```

### File Purposes

| File | Purpose |
|------|---------|
| `variables.tf` | Define all inputs the module accepts |
| `outputs.tf` | Define values the module exports |
| `main.tf` | Main entry point, core resources |
| `*.tf` | Additional resources (named by function) |
| `README.md` | Documentation (shown in registries) |

### Example Module Structure
```t
# variables.tf
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

# main.tf
resource "aws_instance" "app" {
  instance_type = var.instance_type
  # ... more configuration
}

# outputs.tf
output "instance_id" {
  value = aws_instance.app.id
}
```

## Module Registries

### Public Registry (Terraform Registry)
- **Location**: [registry.terraform.io](https://registry.terraform.io)
- **Content**: ~12,000 public modules
- **Usage**: Free, no authentication needed

```t
# Using a public module
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
}
```

### Private Registries
- **Purpose**: Share modules within your organization
- **Options**: Terraform Cloud, Spacelift, Artifactory
- **Authentication**: Use `terraform login`

```t
# Using a private module
module "company_vpc" {
  source  = "app.terraform.io/company/vpc/aws"
  version = "1.0.0"
}
```

### Evaluating Modules
When choosing a module, consider:
- **Update frequency**: Is it actively maintained?
- **Backwards compatibility**: Will updates break your code?
- **Maintainer**: Company or individual?
- **Code quality**: Well-written and secure?
- **Documentation**: Clear usage instructions?

## Complete Example: Building with Modules

```t
# Root module using multiple shared modules

# Networking module from public registry
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["us-east-1a", "us-east-1b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
}

# Local submodule for application
module "web_app" {
  source = "./modules/web-application"
  
  vpc_id         = module.vpc.vpc_id
  subnet_ids     = module.vpc.private_subnets
  instance_count = 3
}

# Another team's module from private registry
module "monitoring" {
  source  = "app.terraform.io/company/monitoring/aws"
  version = "2.1.0"
  
  application_name = "web-app"
  instance_ids     = module.web_app.instance_ids
}
```

## Best Practices

### 1. Version Your Modules
Always specify versions for registry modules:
```t
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"  # Always include version!
}
```

### 2. Keep Modules Focused
Each module should do one thing well:
- ❌ One giant module for everything
- ✅ Separate modules for networking, compute, storage

### 3. Document Your Modules
Include clear documentation:
- What the module does
- Required inputs
- Outputs provided
- Usage examples

### 4. Test Your Modules
Create examples that test module functionality:
```
modules/vpc/
├── main.tf
├── examples/
│   ├── basic/
│   └── complete/
```

## Key Takeaways

1. **Modules are Terraform's packages** - Reusable infrastructure components
2. **Three types exist** - Root (your project), shared (from registries), submodules (nested)
3. **Standard structure helps** - Follow conventions for easier maintenance
4. **Registries enable sharing** - Public for community, private for teams
5. **Modules are both packages and functions** - They bundle resources and accept inputs/outputs

Modules transform Terraform from a tool for managing individual resources into a system for building complex, reusable infrastructure patterns.
