# Chapter 3.7: Validating Inputs

## What This Chapter is About

This chapter explains **input validation** - how to ensure users provide correct values to your modules. Validation catches configuration errors early, before they cause deployment failures or security issues.

## Key Concept: Validation = Error Prevention

Think of validation like:
- **Form validation**: Checking email format before submitting
- **Airport security**: Checking tickets before boarding
- **Recipe requirements**: Ensuring you have the right ingredients before cooking

## The validation Block

### Basic Structure
```t
variable "name" {
  type = string
  
  validation {
    condition     = boolean_expression  # Must evaluate to true/false
    error_message = "Clear error message ending with period."
  }
}
```

### Simple Example
```t
variable "instance_count" {
  type        = number
  description = "Number of instances to create"
  
  validation {
    condition     = var.instance_count > 0
    error_message = "Instance count must be greater than zero."
  }
}
```

## Real-World Examples

### String Validation
```t
# Length restrictions
variable "project_name" {
  type        = string
  description = "Name of the project"
  
  validation {
    condition     = length(var.project_name) <= 32
    error_message = "Project name must be 32 characters or less."
  }
  
  validation {
    condition     = length(var.project_name) >= 3
    error_message = "Project name must be at least 3 characters."
  }
}

# Pattern matching
variable "environment" {
  type        = string
  description = "Deployment environment"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

# Regular expression
variable "s3_bucket_name" {
  type        = string
  description = "S3 bucket name"
  
  validation {
    condition     = can(regex("^[a-z0-9][a-z0-9-]*[a-z0-9]$", var.s3_bucket_name))
    error_message = "Bucket name must start and end with lowercase letter or number, and can contain hyphens."
  }
}
```

### Number Validation
```t
# Range validation
variable "port" {
  type        = number
  description = "Port number"
  
  validation {
    condition     = var.port >= 1 && var.port <= 65535
    error_message = "Port must be between 1 and 65535."
  }
}

# Integer validation
variable "cpu_count" {
  type        = number
  description = "Number of CPUs"
  
  validation {
    condition     = floor(var.cpu_count) == var.cpu_count
    error_message = "CPU count must be a whole number."
  }
  
  validation {
    condition     = var.cpu_count >= 1
    error_message = "CPU count must be at least 1."
  }
}

# Multiple constraints
variable "memory_gb" {
  type        = number
  description = "Memory in GB"
  
  validation {
    condition     = var.memory_gb >= 0.5
    error_message = "Memory must be at least 0.5 GB."
  }
  
  validation {
    condition     = var.memory_gb <= 128
    error_message = "Memory cannot exceed 128 GB."
  }
  
  validation {
    condition     = floor(var.memory_gb * 2) == var.memory_gb * 2
    error_message = "Memory must be in 0.5 GB increments."
  }
}
```

### List/Set Validation
```t
# List length
variable "availability_zones" {
  type        = list(string)
  description = "List of availability zones"
  
  validation {
    condition     = length(var.availability_zones) >= 2
    error_message = "At least 2 availability zones required for high availability."
  }
  
  validation {
    condition     = length(var.availability_zones) == length(distinct(var.availability_zones))
    error_message = "Availability zones must be unique."
  }
}

# List element validation
variable "cidr_blocks" {
  type        = list(string)
  description = "CIDR blocks for subnets"
  
  validation {
    condition = alltrue([
      for cidr in var.cidr_blocks : can(cidrhost(cidr, 0))
    ])
    error_message = "All values must be valid CIDR blocks."
  }
}
```

### Complex Validation (Terraform 1.9+)
```t
# Cross-variable validation (requires Terraform 1.9+)
variable "min_size" {
  type = number
}

variable "max_size" {
  type = number
  
  validation {
    condition     = var.max_size >= var.min_size
    error_message = "Max size must be greater than or equal to min size."
  }
}

# Conditional requirements
variable "enable_backups" {
  type = bool
}

variable "backup_retention_days" {
  type    = number
  default = 7
  
  validation {
    condition = (
      !var.enable_backups || 
      (var.backup_retention_days >= 1 && var.backup_retention_days <= 365)
    )
    error_message = "When backups are enabled, retention must be between 1 and 365 days."
  }
}
```

## Advanced Patterns

### Using can() for Safe Validation
```t
variable "json_config" {
  type        = string
  description = "JSON configuration"
  
  validation {
    condition     = can(jsondecode(var.json_config))
    error_message = "Value must be valid JSON."
  }
}

variable "ip_address" {
  type = string
  
  validation {
    # can() prevents errors if regex fails
    condition     = can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$", var.ip_address))
    error_message = "Must be a valid IPv4 address."
  }
}
```

### Domain-Specific Validation
```t
# EC2 instance type validation
variable "instance_type" {
  type = string
  
  validation {
    condition = can(regex("^[a-z][0-9][a-z]?\\..*", var.instance_type))
    error_message = "Must be a valid EC2 instance type (e.g., t3.micro, m5.large)."
  }
}

# Database engine validation
variable "db_config" {
  type = object({
    engine  = string
    version = string
  })
  
  validation {
    condition = contains(
      ["mysql", "postgres", "mariadb", "sqlserver"],
      var.db_config.engine
    )
    error_message = "Database engine must be mysql, postgres, mariadb, or sqlserver."
  }
  
  validation {
    condition = (
      var.db_config.engine != "mysql" || 
      can(regex("^[5-8]\\.[0-9]+", var.db_config.version))
    )
    error_message = "MySQL version must be 5.x or 8.x."
  }
}
```

## Complete Module Example

```t
# === variables.tf with comprehensive validation ===

variable "application_name" {
  type        = string
  description = "Name of the application"
  
  validation {
    condition = can(regex("^[a-z][a-z0-9-]*[a-z0-9]$", var.application_name))
    error_message = "Application name must start with a letter, end with a letter or number, and contain only lowercase letters, numbers, and hyphens."
  }
  
  validation {
    condition     = length(var.application_name) >= 3 && length(var.application_name) <= 32
    error_message = "Application name must be between 3 and 32 characters."
  }
}

variable "environment" {
  type        = string
  description = "Deployment environment"
  
  validation {
    condition     = contains(["development", "staging", "production"], var.environment)
    error_message = "Environment must be development, staging, or production."
  }
}

variable "instance_config" {
  type = object({
    type  = string
    count = number
  })
  
  description = "EC2 instance configuration"
  
  validation {
    condition = can(regex("^[a-z][0-9][a-z]?\\..*", var.instance_config.type))
    error_message = "Instance type must be valid (e.g., t3.micro, m5.large)."
  }
  
  validation {
    condition     = var.instance_config.count >= 1 && var.instance_config.count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}

variable "networking" {
  type = object({
    vpc_cidr     = string
    subnet_count = number
    enable_nat   = bool
  })
  
  description = "Network configuration"
  
  validation {
    condition     = can(cidrhost(var.networking.vpc_cidr, 0))
    error_message = "VPC CIDR must be a valid CIDR block."
  }
  
  validation {
    condition = can(regex("^10\\.|^172\\.(1[6-9]|2[0-9]|3[01])\\.|^192\\.168\\.", var.networking.vpc_cidr))
    error_message = "VPC CIDR must be in private IP range (10.0.0.0/8, 172.16.0.0/12, or 192.168.0.0/16)."
  }
  
  validation {
    condition     = var.networking.subnet_count >= 2 && var.networking.subnet_count <= 6
    error_message = "Subnet count must be between 2 and 6."
  }
  
  validation {
    condition     = pow(2, 32 - tonumber(split("/", var.networking.vpc_cidr)[1])) >= var.networking.subnet_count * 256
    error_message = "VPC CIDR block is too small for the requested number of subnets."
  }
}

variable "backup_config" {
  type = object({
    enabled        = bool
    retention_days = number
    schedule       = string
  })
  
  description = "Backup configuration"
  default = {
    enabled        = false
    retention_days = 7
    schedule       = "cron(0 3 * * ? *)"
  }
  
  validation {
    condition = (
      !var.backup_config.enabled || 
      (var.backup_config.retention_days >= 1 && var.backup_config.retention_days <= 365)
    )
    error_message = "When backups are enabled, retention must be between 1 and 365 days."
  }
  
  validation {
    condition = (
      !var.backup_config.enabled || 
      can(regex("^cron\\(", var.backup_config.schedule))
    )
    error_message = "Backup schedule must be a valid cron expression."
  }
}

variable "tags" {
  type        = map(string)
  description = "Resource tags"
  default     = {}
  
  validation {
    condition = alltrue([
      for key in keys(var.tags) : can(regex("^[A-Za-z][A-Za-z0-9_-]*$", key))
    ])
    error_message = "Tag keys must start with a letter and contain only letters, numbers, hyphens, and underscores."
  }
  
  validation {
    condition = alltrue([
      for value in values(var.tags) : length(value) <= 256
    ])
    error_message = "Tag values must be 256 characters or less."
  }
}
```

## Best Practices

### 1. Provide Clear Error Messages
```t
# ❌ Bad - vague error
validation {
  condition     = var.port >= 1 && var.port <= 65535
  error_message = "Invalid port."
}

# ✅ Good - specific guidance
validation {
  condition     = var.port >= 1 && var.port <= 65535
  error_message = "Port must be between 1 and 65535."
}
```

### 2. Use can() for Complex Checks
```t
# ❌ Bad - might throw error
validation {
  condition     = regex("^[a-z]+$", var.name) != null
  error_message = "Name must contain only lowercase letters."
}

# ✅ Good - safe with can()
validation {
  condition     = can(regex("^[a-z]+$", var.name))
  error_message = "Name must contain only lowercase letters."
}
```

### 3. Validate Early and Often
```t
variable "database_size_gb" {
  type = number
  
  # Multiple specific validations
  validation {
    condition     = var.database_size_gb >= 20
    error_message = "Database size must be at least 20 GB."
  }
  
  validation {
    condition     = var.database_size_gb <= 16384
    error_message = "Database size cannot exceed 16384 GB."
  }
  
  validation {
    condition     = contains([20, 100, 500, 1024, 2048, 4096, 8192, 16384], var.database_size_gb)
    error_message = "Database size must be one of: 20, 100, 500, 1024, 2048, 4096, 8192, 16384 GB."
  }
}
```

## Key Takeaways

1. **Validation prevents errors early** - Catch misconfigurations before deployment
2. **Multiple validations allowed** - Chain validations for comprehensive checks
3. **Clear error messages are crucial** - Help users fix problems quickly
4. **Use can() for safety** - Prevent validation expressions from throwing errors
5. **Think about edge cases** - Validate for all possible problematic inputs
6. **Version 1.9+ adds flexibility** - Cross-variable validation now possible

Good validation is the difference between a module that's frustrating to use and one that guides users to success.
