# Chapter 3.2: Input, Output, and Local Variables 

## What This Chapter is About

This chapter explains Terraform's three types of variables and how they work with modules. Think of variables as containers for values that make your infrastructure code flexible and reusable.

## Key Concept: Variables and Module Scope

Terraform variables work like a function in programming:
- **Input variables** = Function parameters (values going IN)
- **Output variables** = Return values (values coming OUT)
- **Local variables** = Variables inside the function (internal use only)

### Important: All Terraform Variables are Constants!
Once set, variables cannot change during a run. This is because Terraform is declarative - it describes the end state, not step-by-step instructions.

## The Three Types of Variables

### 1. Input Variables (Inputs)
**Purpose**: Allow users to customize module behavior

```t
# Defining an input variable
variable "instance_type" {
  description = "The type of EC2 instance"
  type        = string
  default     = "t3.micro"
}

# Using the input variable
resource "aws_instance" "web" {
  instance_type = var.instance_type
}
```

**How users provide values**:
```t
# When calling a module
module "web_server" {
  source = "./modules/web"
  
  instance_type = "t3.large"  # Providing input
}
```

### 2. Output Variables (Outputs)
**Purpose**: Export values from modules for others to use

```t
# Defining an output
output "instance_ip" {
  description = "The public IP of the instance"
  value       = aws_instance.web.public_ip
}

# Using the output from a module
module "web_server" {
  source = "./modules/web"
}

# Accessing the output
resource "aws_route53_record" "web" {
  name    = "web.example.com"
  type    = "A"
  records = [module.web_server.instance_ip]  # Using output
}
```

### 3. Local Variables (Locals)
**Purpose**: Store intermediate values within a module

```t
# Defining locals
locals {
  common_tags = {
    Project     = "MyApp"
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
  
  # Computed value
  instance_name = "${var.project}-${var.environment}-web"
}

# Using locals
resource "aws_instance" "web" {
  tags = local.common_tags  # Note: "local" not "locals"
  
  tags = merge(local.common_tags, {
    Name = local.instance_name
  })
}
```

## Module Scope Visualization

```
┌─────────────────────────────────────┐
│          Outside Module             │
│                                     │
│  module "example" {                 │
│    source = "./my-module"          │
│    instance_type = "t3.large" ────┼──┐ Input
│  }                                 │  │
│                                    │  │
│  ip = module.example.public_ip ◄───┼──┼─ Output
│                                    │  │
└────────────────────────────────────┘  │
                                        │
┌────────────────────────────────────┐  │
│          Inside Module             │  │
│                                    │  │
│  variable "instance_type" { } ◄────┼──┘
│                                    │
│  locals {                          │
│    name = "web-server"  ← Internal │
│  }                                 │
│                                    │
│  output "public_ip" {              │
│    value = aws_instance.web.ip ───┼───┘
│  }                                 │
└────────────────────────────────────┘
```

## Real-World Example: Complete Module

```t
# === variables.tf ===
variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod"
  }
}

variable "instance_count" {
  description = "Number of instances to create"
  type        = number
  default     = 1
}

variable "enable_monitoring" {
  description = "Enable CloudWatch monitoring"
  type        = bool
  default     = false
}

# === main.tf ===
locals {
  # Common tags for all resources
  base_tags = {
    Environment = var.environment
    ManagedBy   = "Terraform"
    CreatedAt   = timestamp()
  }
  
  # Compute instance type based on environment
  instance_type = var.environment == "prod" ? "t3.large" : "t3.micro"
  
  # Create name prefix
  name_prefix = "myapp-${var.environment}"
}

resource "aws_instance" "app" {
  count = var.instance_count
  
  ami           = data.aws_ami.app.id
  instance_type = local.instance_type
  
  monitoring = var.enable_monitoring
  
  tags = merge(local.base_tags, {
    Name = "${local.name_prefix}-${count.index + 1}"
  })
}

# === outputs.tf ===
output "instance_ids" {
  description = "IDs of created instances"
  value       = aws_instance.app[*].id
}

output "instance_ips" {
  description = "Public IPs of instances"
  value       = aws_instance.app[*].public_ip
}

output "load_balancer_dns" {
  description = "DNS name of load balancer"
  value       = aws_lb.main.dns_name
}
```

## Using the Module

```t
# Using all three variable types
module "production_app" {
  source = "./modules/web-app"
  
  # Providing inputs
  environment       = "prod"
  instance_count    = 3
  enable_monitoring = true
}

# Using outputs
output "app_url" {
  value = "https://${module.production_app.load_balancer_dns}"
}

# Note: You CANNOT access locals from outside
# This would fail: module.production_app.base_tags
```

## Common Patterns

### 1. Default Values with Overrides
```t
variable "instance_type" {
  type    = string
  default = "t3.micro"  # Sensible default
}

# User can override or use default
module "web" {
  source = "./modules/web"
  # instance_type not specified, uses default
}
```

### 2. Computed Locals
```t
locals {
  # Combine multiple inputs
  full_name = "${var.project}-${var.environment}-${var.component}"
  
  # Conditional logic
  use_https = var.environment == "prod" ? true : false
  
  # Resource calculations
  total_storage_gb = var.instances * var.storage_per_instance
}
```

### 3. Output Everything Useful
```t
output "instance_details" {
  value = {
    ids        = aws_instance.app[*].id
    ips        = aws_instance.app[*].public_ip
    dns_names  = aws_instance.app[*].public_dns
  }
}
```

## Variable Types Quick Reference

| Variable Type | Keyword | Access From | Purpose |
|--------------|---------|-------------|---------|
| Input | `variable` | `var.name` | Accept values from users |
| Output | `output` | `module.name.output` | Export values from module |
| Local | `locals` | `local.name` | Internal calculations |

## Best Practices

### 1. Always Describe Variables
```t
variable "vpc_cidr" {
  description = "CIDR block for VPC (e.g., 10.0.0.0/16)"
  type        = string
}
```

### 2. Use Meaningful Defaults
```t
variable "instance_type" {
  type    = string
  default = "t3.micro"  # Cheap default prevents accidents
}
```

### 3. Validate Inputs
```t
variable "environment" {
  type = string
  
  validation {
    condition     = length(var.environment) <= 10
    error_message = "Environment name must be 10 characters or less"
  }
}
```

### 4. Group Related Values in Locals
```t
locals {
  # Group all tags together
  common_tags = {
    Project     = var.project
    Environment = var.environment
    CostCenter  = var.cost_center
  }
}
```

## Key Takeaways

1. **Three variable types serve different purposes**:
   - Inputs: Module parameters
   - Outputs: Module return values
   - Locals: Internal module values

2. **Variables are constants** - Set once, never changed during execution

3. **Scope is strict**:
   - Only inputs can be set from outside
   - Only outputs can be read from outside
   - Locals are completely internal

4. **Variables make modules flexible** - Same module, different configurations

5. **Think functionally** - Modules are like functions with inputs and outputs

Understanding these three variable types is essential for building reusable, maintainable Terraform modules.
