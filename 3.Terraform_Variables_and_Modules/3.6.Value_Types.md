# Chapter 3.6: Value Types

## What This Chapter is About

This chapter explains **value types** in Terraform - the different kinds of data that variables, outputs, and expressions can hold. Understanding types helps you write more robust code by catching errors early and ensuring data is in the expected format.

## Key Concept: Types = Data Categories

Think of types like:
- **Container shapes**: Different containers for different contents (bottles for liquids, boxes for solids)
- **Form fields**: Phone number fields only accept numbers, email fields need @ symbols
- **Tool categories**: Hammers for nails, screwdrivers for screws - each tool has its purpose

## Basic Types

### Strings - Text Data
```t
variable "name" {
  type        = string
  description = "Any text value"
}

# String examples
locals {
  simple       = "hello"
  with_spaces  = "hello world"
  with_unicode = "Hello ‰∏ñÁïå üåç"
  empty        = ""
}

# String interpolation (embedding variables)
variable "prefix" {
  type    = string
  default = "prod"
}

locals {
  # Creates "prod-service"
  identifier = "${var.prefix}-service"
}
```

### Numbers - Numeric Values
```t
variable "port" {
  type    = number
  default = 8080      # Whole number
}

variable "price" {
  type    = number
  default = 19.99     # Decimal number
}

variable "temperature" {
  type    = number
  default = -5        # Negative number
}

# Note: Terraform doesn't distinguish between integers and floats!
```

### Booleans - True/False
```t
variable "enable_backups" {
  type    = bool
  default = true
}

variable "is_public" {
  type    = bool
  default = false
}

# Using booleans for conditional logic
resource "aws_instance" "example" {
  monitoring = var.enable_backups  # true or false
}
```

## Collection Types

### Lists - Ordered Collections
```t
# List of strings
variable "availability_zones" {
  type = list(string)
  default = [
    "us-east-1a",    # Index 0
    "us-east-1b",    # Index 1
    "us-east-1c"     # Index 2
  ]
}

# List of numbers
variable "allowed_ports" {
  type    = list(number)
  default = [22, 80, 443, 8080]
}

# List of lists (nested)
variable "subnet_cidrs" {
  type = list(list(string))
  default = [
    ["10.0.1.0/24", "10.0.2.0/24"],    # Public subnets
    ["10.0.101.0/24", "10.0.102.0/24"]  # Private subnets
  ]
}

# ‚ùå This will error - mixed types!
variable "mixed_list" {
  type    = list(any)
  default = ["text", 123]  # Can't mix strings and numbers
}
```

### Sets - Unique, Unordered Collections
```t
# Set removes duplicates and loses order
variable "unique_regions" {
  type = set(string)
  default = [
    "us-east-1",
    "us-west-2",
    "us-east-1",  # Duplicate - will be removed
    "eu-west-1"
  ]
  # Result: {"eu-west-1", "us-east-1", "us-west-2"} (no duplicates, no guaranteed order)
}

# Common use: security group rules
variable "ingress_cidrs" {
  type        = set(string)
  description = "Unique CIDR blocks for ingress"
  default     = ["10.0.0.0/8", "172.16.0.0/12"]
}
```

### Tuples - Fixed-Length, Mixed Types
```t
# Tuple with specific types at each position
variable "server_config" {
  type = tuple([string, string, number])
  default = [
    "web-server",    # Position 0: name (string)
    "t3.micro",      # Position 1: instance type (string)
    80               # Position 2: port (number)
  ]
}

# More complex tuple
variable "database_settings" {
  type = tuple([
    string,           # engine
    number,           # port
    bool,             # multi-az
    list(string)      # backup_windows
  ])
  default = ["postgres", 5432, true, ["03:00-04:00", "04:00-05:00"]]
}
```

### Maps - Key-Value Pairs (Same Type)
```t
# Map of strings (common for tags)
variable "tags" {
  type = map(string)
  default = {
    Environment = "production"
    Team        = "platform"
    CostCenter  = "engineering"
  }
}

# Map of numbers
variable "instance_counts" {
  type = map(number)
  default = {
    web = 3
    api = 2
    db  = 1
  }
}

# Map of objects (all values must match structure)
variable "environment_configs" {
  type = map(object({
    instance_type = string
    min_size      = number
    max_size      = number
  }))
  
  default = {
    dev = {
      instance_type = "t3.micro"
      min_size      = 1
      max_size      = 2
    }
    prod = {
      instance_type = "t3.large"
      min_size      = 3
      max_size      = 10
    }
  }
}
```

### Objects - Structured Data
```t
# Simple object
variable "database_config" {
  type = object({
    engine   = string
    version  = string
    size     = string
    multi_az = bool
  })
  
  default = {
    engine   = "postgres"
    version  = "13.7"
    size     = "db.t3.micro"
    multi_az = false
  }
}

# Object with optional fields
variable "app_config" {
  type = object({
    name        = string
    port        = number
    enable_ssl  = optional(bool)          # Can be omitted
    ssl_cert    = optional(string, null)  # Default if omitted
    log_level   = optional(string, "info")
  })
  
  default = {
    name = "my-app"
    port = 8080
    # enable_ssl omitted - will be null
    # ssl_cert omitted - will be null
    # log_level omitted - will be "info"
  }
}

# Nested objects
variable "cluster_config" {
  type = object({
    name = string
    network = object({
      vpc_cidr     = string
      subnet_count = number
    })
    nodes = object({
      instance_type = string
      min_count     = number
      max_count     = number
    })
  })
  
  default = {
    name = "prod-cluster"
    network = {
      vpc_cidr     = "10.0.0.0/16"
      subnet_count = 4
    }
    nodes = {
      instance_type = "t3.large"
      min_count     = 3
      max_count     = 10
    }
  }
}
```

## Special Types

### Null - Absence of Value
```t
# Using null for optional variables
variable "backup_retention" {
  type    = number
  default = null  # Not set by default
}

variable "description" {
  type    = string
  default = null  # Explicitly no value
}

# Checking for null
locals {
  # Use default if not set
  retention_days = var.backup_retention != null ? var.backup_retention : 7
  
  # Different behavior based on null
  backup_enabled = var.backup_retention != null
}
```

### Any - Accept Any Type
```t
# Variable accepts any type
variable "custom_data" {
  type = any
  # Could be string, number, list, object, etc.
}

# List of any (but all elements must be same type)
variable "values" {
  type    = list(any)
  default = ["one", "two", "three"]  # All strings OK
  # default = ["one", 2, true]  # ‚ùå Mixed types ERROR
}

# Map of any
variable "settings" {
  type = map(any)
  # All values must be same type
}
```

## Complete Example

```t
# === Complex module with various types ===

variable "project_name" {
  type        = string
  description = "Name of the project"
}

variable "environment" {
  type        = string
  description = "Deployment environment"
  default     = "dev"
}

variable "enable_monitoring" {
  type        = bool
  description = "Enable CloudWatch monitoring"
  default     = true
}

variable "instance_count" {
  type        = number
  description = "Number of instances"
  default     = 2
}

variable "allowed_ports" {
  type        = list(number)
  description = "Ports to allow in security group"
  default     = [80, 443]
}

variable "availability_zones" {
  type        = set(string)
  description = "AZs to deploy into"
  default     = ["us-east-1a", "us-east-1b"]
}

variable "server_config" {
  type = tuple([string, string, number])
  description = "Server [name, type, port]"
  default     = ["web", "t3.micro", 80]
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources"
  default = {
    Terraform = "true"
  }
}

variable "network_config" {
  type = object({
    vpc_cidr = string
    subnets = list(object({
      cidr = string
      az   = string
      type = string
    }))
    enable_nat = bool
  })
  
  description = "Network configuration"
  default = {
    vpc_cidr = "10.0.0.0/16"
    subnets = [
      {
        cidr = "10.0.1.0/24"
        az   = "us-east-1a"
        type = "public"
      },
      {
        cidr = "10.0.2.0/24"
        az   = "us-east-1b"
        type = "public"
      }
    ]
    enable_nat = false
  }
}

# Using the variables
resource "aws_instance" "web" {
  count = var.instance_count
  
  instance_type = var.server_config[1]  # "t3.micro"
  monitoring    = var.enable_monitoring
  
  tags = merge(var.tags, {
    Name        = "${var.project_name}-${var.environment}-${count.index}"
    Environment = var.environment
  })
}

resource "aws_security_group_rule" "ingress" {
  for_each = toset([for port in var.allowed_ports : tostring(port)])
  
  type        = "ingress"
  from_port   = tonumber(each.value)
  to_port     = tonumber(each.value)
  protocol    = "tcp"
  cidr_blocks = ["0.0.0.0/0"]
}
```

## Best Practices

### 1. Always Specify Types
```t
# ‚ùå Bad - no type specified
variable "instance_type" {
  default = "t3.micro"
}

# ‚úÖ Good - explicit type
variable "instance_type" {
  type    = string
  default = "t3.micro"
}
```

### 2. Use Appropriate Types
```t
# ‚ùå Using string for structured data
variable "subnet_ids" {
  type    = string
  default = "subnet-123,subnet-456"  # Requires parsing
}

# ‚úÖ Using list for multiple values
variable "subnet_ids" {
  type    = list(string)
  default = ["subnet-123", "subnet-456"]
}
```

### 3. Keep Objects Simple
```t
# ‚ùå Overly complex nesting
variable "config" {
  type = object({
    a = object({
      b = object({
        c = object({
          d = string  # Too deep!
        })
      })
    })
  })
}

# ‚úÖ Flatter structure
variable "config" {
  type = object({
    name     = string
    settings = map(string)
  })
}
```

## Key Takeaways

1. **Types enforce data structure** - Catch errors before they cause problems
2. **Choose the right type** - Lists for ordered data, maps for lookups, objects for structured data
3. **All list/set elements must match** - Even with `any`, all elements must be the same type
4. **Maps vs Objects** - Maps have flexible keys but same-type values; objects have fixed keys but different-type values
5. **Null is special** - Represents absence of value, useful for optional configurations
6. **Keep it simple** - Complex nested types make code harder to understand and maintain

Understanding Terraform's type system helps you build more reliable modules by ensuring data is always in the expected format.
