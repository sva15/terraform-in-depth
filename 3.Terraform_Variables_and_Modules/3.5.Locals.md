# Chapter 3.5: Locals

## What This Chapter is About

This chapter explains **local variables (locals)** - private variables that exist only inside a module. Locals help modules organize internal logic and avoid repetition, but they can't be accessed from outside the module.

## Key Concept: Locals = Module's Private Variables

Think of locals like:
- **Kitchen prep work**: The cutting board and mixing bowls you use while cooking, but don't serve to guests
- **Scratch paper**: Calculations you do to solve a problem, but only the answer matters
- **Behind-the-scenes work**: Stage crew in a theater - essential but invisible to the audience

## The Unique locals Block

### What Makes It Special
```t
locals {
  # No name/label needed (unlike other blocks)
  # Can appear multiple times
  # Each argument becomes a local variable
}
```

### Basic Structure
```t
locals {
  alpha   = 1          # Creates local.alpha
  bravo   = "two"      # Creates local.bravo  
  charlie = false      # Creates local.charlie
}

# Can have multiple blocks
locals {
  delta = ["four", "five"]
  echo = {
    "foxtrot" = "six",
    "golf"    = "seven"
  }
}

# Locals can reference other locals
locals {
  hotel = local.bravo  # References bravo from above
}
```

## Real Examples

### Avoiding Repetition
```t
# Without locals - repetitive
resource "aws_instance" "web" {
  tags = {
    Author    = "Rob"
    ManagedBy = "Terraform"
    Project   = "webapp"
  }
}

resource "aws_instance" "db" {
  tags = {
    Author    = "Rob"      # Same tags repeated
    ManagedBy = "Terraform"
    Project   = "webapp"
  }
}

# With locals - DRY (Don't Repeat Yourself)
locals {
  common_tags = {
    Author    = "Rob"
    ManagedBy = "Terraform"
    Project   = "webapp"
  }
}

resource "aws_instance" "web" {
  tags = local.common_tags  # Reuse the tags
}

resource "aws_instance" "db" {
  tags = local.common_tags  # Same tags, no repetition
}
```

### Complex Calculations
```t
variable "environment" {
  type = string
}

variable "project" {
  type = string
}

locals {
  # Compute values once, use many times
  name_prefix = "${var.project}-${var.environment}"
  
  # Conditional logic
  instance_type = var.environment == "prod" ? "t3.large" : "t3.micro"
  
  # Building complex structures
  default_tags = {
    Environment = var.environment
    Project     = var.project
    Terraform   = "true"
    CreatedOn   = timestamp()
  }
}

# Use the computed values
resource "aws_instance" "app" {
  instance_type = local.instance_type
  
  tags = merge(local.default_tags, {
    Name = "${local.name_prefix}-app"
  })
}

resource "aws_s3_bucket" "data" {
  bucket = "${local.name_prefix}-data"
  tags   = local.default_tags
}
```

## Important Rules

### 1. No Duplicate Names
```t
locals {
  alpha = 1
}

locals {
  alpha = 2  # ❌ ERROR: "alpha" already defined
}
```

### 2. Reference Pattern
```t
locals {
  my_value = "hello"
}

# Reference using 'local' (singular), not 'locals'
output "greeting" {
  value = local.my_value  # ✅ Correct: local.my_value
  # value = locals.my_value  # ❌ Wrong
}
```

### 3. Module Scope Only
```t
# In module/main.tf
locals {
  internal_value = "secret"
}

# In root main.tf
module "example" {
  source = "./module"
  
  # Can't access module.example.local.internal_value ❌
  # Locals are completely private to their module
}
```

## Complete Module Example

```t
# === variables.tf ===
variable "app_name" {
  type = string
}

variable "environment" {
  type = string
}

variable "team" {
  type = string
}

variable "enable_monitoring" {
  type    = bool
  default = true
}

# === locals.tf ===
locals {
  # Naming convention
  full_name = "${var.app_name}-${var.environment}"
  
  # Resource naming
  bucket_name     = "${local.full_name}-data"
  function_name   = "${local.full_name}-processor"
  role_name       = "${local.full_name}-role"
  
  # Environment-specific settings
  is_production = var.environment == "prod"
  
  instance_settings = {
    instance_type = local.is_production ? "t3.large" : "t3.micro"
    volume_size   = local.is_production ? 100 : 20
    multi_az      = local.is_production
  }
  
  # Common tags for all resources
  base_tags = {
    Application = var.app_name
    Environment = var.environment
    Team        = var.team
    ManagedBy   = "Terraform"
  }
  
  # Monitoring configuration
  monitoring_config = var.enable_monitoring ? {
    detailed_monitoring = true
    log_retention_days  = local.is_production ? 90 : 7
    alarm_email        = "${var.team}@company.com"
  } : null
}

# === main.tf ===
resource "aws_instance" "app" {
  instance_type = local.instance_settings.instance_type
  monitoring    = local.monitoring_config != null
  
  root_block_device {
    volume_size = local.instance_settings.volume_size
  }
  
  tags = merge(local.base_tags, {
    Name = "${local.full_name}-instance"
    Type = "application-server"
  })
}

resource "aws_s3_bucket" "data" {
  bucket = local.bucket_name
  tags   = local.base_tags
}

resource "aws_iam_role" "app" {
  name = local.role_name
  tags = local.base_tags
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })
}

# Only create monitoring resources if enabled
resource "aws_cloudwatch_log_group" "app" {
  count = local.monitoring_config != null ? 1 : 0
  
  name              = "/aws/application/${local.full_name}"
  retention_in_days = local.monitoring_config.log_retention_days
  
  tags = local.base_tags
}
```

## Common Use Cases

### 1. Computed Values
```t
locals {
  # Combine multiple inputs
  connection_string = "postgres://${var.db_user}:${var.db_pass}@${var.db_host}:${var.db_port}/${var.db_name}"
  
  # Format conversions
  cidr_blocks = [for ip in var.allowed_ips : "${ip}/32"]
  
  # Date calculations
  backup_date = formatdate("YYYY-MM-DD", timestamp())
}
```

### 2. Configuration Maps
```t
locals {
  # Environment-specific configurations
  env_config = {
    dev = {
      instance_count = 1
      enable_backups = false
      log_level      = "debug"
    }
    staging = {
      instance_count = 2
      enable_backups = true
      log_level      = "info"
    }
    prod = {
      instance_count = 4
      enable_backups = true
      log_level      = "error"
    }
  }
  
  # Select based on environment
  config = local.env_config[var.environment]
}

resource "aws_instance" "app" {
  count = local.config.instance_count
  # ... use other config values
}
```

### 3. Conditional Logic
```t
locals {
  # Feature flags
  enable_cdn = var.environment == "prod" && var.region == "us-east-1"
  
  # Conditional resource names
  lb_name = var.use_alb ? "${local.full_name}-alb" : "${local.full_name}-nlb"
  
  # Optional configurations
  ssl_cert = var.domain != "" ? data.aws_acm_certificate.cert[0].arn : null
}
```

## Best Practices

### 1. Use Locals for Repeated Values
```t
# ❌ Bad - repeated string
resource "aws_instance" "web" {
  tags = { App = "my-awesome-app" }
}

resource "aws_s3_bucket" "data" {
  tags = { App = "my-awesome-app" }  # Same string repeated
}

# ✅ Good - defined once
locals {
  app_name = "my-awesome-app"
}

resource "aws_instance" "web" {
  tags = { App = local.app_name }
}

resource "aws_s3_bucket" "data" {
  tags = { App = local.app_name }
}
```

### 2. Group Related Locals
```t
# ✅ Good - grouped by purpose
locals {
  # Naming conventions
  name_prefix = "${var.project}-${var.environment}"
  
  # Resource names
  bucket_name   = "${local.name_prefix}-data"
  function_name = "${local.name_prefix}-processor"
  
  # Configuration values
  retention_days = var.environment == "prod" ? 90 : 7
  backup_enabled = var.environment != "dev"
}
```

### 3. Keep Locals Simple
```t
# ❌ Avoid overly complex locals
locals {
  complex_mess = {
    for k, v in var.inputs : k => {
      for k2, v2 in v : k2 => merge(v2, {
        for k3, v3 in local.other : k3 => v3 if v3 != null
      }) if can(v2.enabled)
    } if v != null
  }
}

# ✅ Break down complex logic
locals {
  filtered_inputs = {
    for k, v in var.inputs : k => v if v != null
  }
  
  processed_inputs = {
    for k, v in local.filtered_inputs : k => process_input(v)
  }
}
```

## Key Takeaways

1. **Locals are module-private** - They can't be accessed from outside the module
2. **Use for internal logic** - Perfect for calculations and avoiding repetition
3. **No naming restrictions** - Use multiple `locals` blocks as needed
4. **Reference with `local`** - Use `local.name` not `locals.name`
5. **Can reference each other** - Build complex values from simpler ones
6. **Not for external sharing** - Use outputs if you need to expose values

Locals are your module's workspace - use them to keep your code DRY (Don't Repeat Yourself) and organize complex logic that doesn't need to be exposed to module users.
