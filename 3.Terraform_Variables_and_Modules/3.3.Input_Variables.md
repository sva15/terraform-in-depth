# Chapter 3.3: Input Variables 

## What This Chapter is About

This chapter explains **input variables** - how modules accept customization from users. Input variables are what make modules flexible and reusable, allowing the same module to work in different scenarios without changing its code.

## Key Concept: Input Variables = Module Customization

Think of input variables like:
- **Recipe ingredients**: Same recipe, different ingredients = different dish
- **Function parameters**: Same function, different inputs = different outputs
- **Car options**: Same model, different options = personalized vehicle

## Defining Input Variables

### Basic Structure
```t
variable "name" {
  type        = string
  description = "What this variable does"
  default     = "optional default value"
}
```

### All Variable Arguments

```t
variable "complete_example" {
  description = "A complete variable example"  # Documentation
  type        = string                        # Data type restriction
  default     = "default-value"               # Optional default
  sensitive   = true                          # Hide from logs
  nullable    = false                         # Can't be null
  
  validation {                                # Custom rules
    condition     = length(var.complete_example) > 5
    error_message = "Value must be longer than 5 characters"
  }
}
```

## Real Examples

### Simple Configuration Variables
```t
# Basic instance configuration
variable "ami" {
  type        = string
  description = "The Amazon Machine Image to use"
}

variable "instance_type" {
  type        = string
  description = "The type of instance to launch"
  default     = "t3.micro"  # Sensible default
}

variable "enable_monitoring" {
  type        = bool
  description = "Enable detailed monitoring"
  default     = false
}
```

### Using Variables in Resources
```t
resource "aws_instance" "web" {
  ami           = var.ami           # Required - no default
  instance_type = var.instance_type # Optional - has default
  monitoring    = var.enable_monitoring
}
```

## Sensitive Variables

### When to Use
Mark variables as sensitive when they contain:
- Passwords
- API keys
- Private certificates
- Personal information

### Example
```t
variable "database_password" {
  description = "Password for the RDS instance"
  type        = string
  sensitive   = true  # Terraform won't display this
}

variable "api_key" {
  description = "API key for external service"
  type        = string
  sensitive   = true
}

# Using sensitive variables
resource "aws_db_instance" "main" {
  password = var.database_password  # Won't show in logs
}
```

### How Sensitive Works
```t
# Sensitive values "infect" derived values
variable "secret" {
  type      = string
  sensitive = true
}

locals {
  # This becomes sensitive too!
  connection_string = "postgres://user:${var.secret}@host/db"
}
```

**Important**: Sensitive values are still stored in state files! Protect your state.

## Variable Types

### Basic Types
```t
# String
variable "name" {
  type    = string
  default = "my-app"
}

# Number
variable "port" {
  type    = number
  default = 8080
}

# Boolean
variable "enable_https" {
  type    = bool
  default = true
}
```

### Collection Types
```t
# List of strings
variable "availability_zones" {
  type    = list(string)
  default = ["us-east-1a", "us-east-1b"]
}

# Set of numbers (no duplicates)
variable "allowed_ports" {
  type    = set(number)
  default = [80, 443, 8080]
}

# Map of strings
variable "tags" {
  type = map(string)
  default = {
    Environment = "dev"
    Project     = "web-app"
  }
}
```

### Complex Types
```t
# Object with specific structure
variable "database_config" {
  type = object({
    engine         = string
    version        = string
    instance_class = string
    storage_gb     = number
    multi_az       = bool
  })
  
  default = {
    engine         = "postgres"
    version        = "13.7"
    instance_class = "db.t3.micro"
    storage_gb     = 20
    multi_az       = false
  }
}

# List of objects
variable "ingress_rules" {
  type = list(object({
    port        = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  
  default = [
    {
      port        = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      port        = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  ]
}
```

## Complete Module Example

```t
# === variables.tf ===

variable "project_name" {
  description = "Name of the project"
  type        = string
  
  validation {
    condition     = can(regex("^[a-z0-9-]+$", var.project_name))
    error_message = "Project name must contain only lowercase letters, numbers, and hyphens"
  }
}

variable "environment" {
  description = "Deployment environment"
  type        = string
  default     = "dev"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod"
  }
}

variable "instance_count" {
  description = "Number of instances to create"
  type        = number
  default     = 1
  
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10"
  }
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "enable_backups" {
  description = "Enable automated backups"
  type        = bool
  default     = true
}

variable "backup_retention_days" {
  description = "Days to retain backups"
  type        = number
  default     = 7
  nullable    = true  # Can be set to null to disable
}

variable "allowed_ssh_ips" {
  description = "CIDR blocks allowed for SSH access"
  type        = list(string)
  default     = []  # Empty by default for security
}

variable "database_password" {
  description = "Master password for database"
  type        = string
  sensitive   = true  # Won't show in logs
}

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# === Using the variables ===

locals {
  # Compute full name from inputs
  full_name = "${var.project_name}-${var.environment}"
  
  # Merge user tags with standard tags
  all_tags = merge(var.tags, {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
  })
}

resource "aws_instance" "app" {
  count = var.instance_count
  
  instance_type = var.instance_type
  
  tags = merge(local.all_tags, {
    Name = "${local.full_name}-${count.index + 1}"
  })
}
```

## Using the Module

```t
module "web_app" {
  source = "./modules/web-app"
  
  # Required variables (no defaults)
  project_name      = "my-app"
  database_password = var.db_password  # From parent
  
  # Optional variables (have defaults)
  environment       = "prod"
  instance_count    = 3
  instance_type     = "t3.large"
  
  # Using complex types
  allowed_ssh_ips = ["10.0.0.0/8", "192.168.1.0/24"]
  
  tags = {
    CostCenter = "engineering"
    Owner      = "web-team"
  }
}
```

## Best Practices

### 1. Always Include Descriptions
```t
# âŒ Bad
variable "subnet_id" {
  type = string
}

# âœ… Good
variable "subnet_id" {
  description = "ID of the subnet where instances will be launched"
  type        = string
}
```

### 2. Use Sensible Defaults
```t
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"  # Cheap default prevents accidents
}
```

### 3. Validate User Input
```t
variable "environment" {
  type = string
  
  validation {
    condition     = contains(["dev", "test", "prod"], var.environment)
    error_message = "Environment must be dev, test, or prod"
  }
}
```

### 4. Group Related Variables
```t
variable "database_config" {
  type = object({
    engine   = string
    version  = string
    size     = string
    multi_az = bool
  })
}
```

### 5. Be Careful with Sensitive Data
```t
variable "api_key" {
  description = "API key for external service"
  type        = string
  sensitive   = true
  
  validation {
    condition     = length(var.api_key) == 32
    error_message = "API key must be exactly 32 characters"
  }
}
```

## Key Takeaways

1. **Input variables make modules flexible** - Same module, different configurations
2. **Always specify types** - Catch errors early with type constraints
3. **Use descriptions** - Document what each variable does
4. **Provide defaults when sensible** - Make modules easier to use
5. **Mark sensitive data** - Protect passwords and secrets from logs
6. **Validate inputs** - Catch configuration errors before they cause problems

Input variables are the key to building reusable modules that can adapt to different requirements without code changes.
