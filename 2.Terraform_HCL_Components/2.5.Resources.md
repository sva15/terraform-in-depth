# Chapter 2.5: Resources

## What This Chapter is About

This chapter covers the heart of Terraform - **resources**. If Terraform is a tool for building infrastructure, then resources are the actual building blocks. Every server, database, network, or other infrastructure component you create is represented by a resource.

## Key Concept: Resources = Infrastructure

Think of resources as the "things" you want to create:
- A virtual machine
- A database
- A network
- A DNS record
- A storage bucket

**Important:** Everything else in Terraform (providers, variables, data sources) exists to support resources. Resources are the reason Terraform exists.

## Understanding Resource Structure

Every resource follows this pattern:

```t
resource "resource_type" "your_name" {
  # Configuration goes here
}
```

### Breaking It Down:
1. `resource` - The keyword that starts every resource
2. `"resource_type"` - What kind of thing you're creating (from the provider)
3. `"your_name"` - Your unique name for this specific resource
4. `{ }` - Configuration specific to that resource type

### Real Example:
```t
resource "aws_instance" "web_server" {
  ami           = "ami-12345"
  instance_type = "t3.micro"
  
  tags = {
    Name = "My Web Server"
  }
}
```

This creates:
- **What**: An AWS EC2 instance (virtual machine)
- **Type**: `aws_instance`
- **Name**: `web_server`
- **Full ID**: `resource.aws_instance.web_server`

## Resource Arguments

Each resource type has its own set of arguments (settings):

### Different Argument Types:
```t
resource "example_resource" "demo" {
  # String argument
  name = "my-resource"
  
  # Number argument
  size = 100
  
  # Boolean argument
  enable_logging = true
  
  # List argument
  security_groups = ["web", "ssh"]
  
  # Object/Map argument
  configuration = {
    timeout = 30
    retries = 3
  }
  
  # Null argument (explicitly no value)
  optional_setting = null
}
```

## Resource Types by Provider

Different providers offer different resource types:

### AWS Examples:
- `aws_instance` - EC2 virtual machines
- `aws_s3_bucket` - Storage buckets
- `aws_db_instance` - RDS databases
- `aws_security_group` - Firewall rules

### Google Cloud Examples:
- `google_compute_instance` - Virtual machines
- `google_storage_bucket` - Storage buckets
- `google_sql_database_instance` - Databases

### Other Examples:
- `github_repository` - GitHub repos
- `cloudflare_record` - DNS records
- `kubernetes_deployment` - K8s deployments

## The Lifecycle Meta-Argument

Every resource can have a special `lifecycle` block that controls how Terraform manages it:

```t
resource "aws_instance" "database" {
  ami           = "ami-12345"
  instance_type = "t3.large"
  
  lifecycle {
    # Create new instance before destroying old one
    create_before_destroy = true
    
    # Don't destroy this even if terraform destroy is run
    prevent_destroy = true
    
    # Ignore changes to these attributes
    ignore_changes = [ami, tags]
    
    # Replace this resource when any attribute changes
    replace_triggered_by = [aws_instance.web_server.id]
  }
}
```

## Unique Identifiers

Resources must have unique identifiers within a module:

```t
# ✅ This is OK - different types
resource "aws_instance" "main" {
  # ...
}

resource "aws_security_group" "main" {
  # ...
}

# ❌ This is NOT OK - same type and name
resource "aws_instance" "main" {
  # ...
}

resource "aws_instance" "main" {  # Error: Duplicate!
  # ...
}
```

## Real-World Example

Here's a complete example creating a web server with security group:

```t
# Security group (firewall rules)
resource "aws_security_group" "web" {
  name        = "web-server-sg"
  description = "Security group for web server"
  
  # Allow HTTP
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  # Allow HTTPS
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  # Allow all outbound
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# EC2 Instance
resource "aws_instance" "web" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type
  
  # Reference the security group above
  vpc_security_group_ids = [aws_security_group.web.id]
  
  # User data script to install web server
  user_data = <<-EOF
    #!/bin/bash
    apt-get update
    apt-get install -y nginx
    systemctl start nginx
  EOF
  
  tags = {
    Name        = "Web Server"
    Environment = "Production"
  }
}
```

## How Resources Work Together

Resources often reference each other:

```t
# Create a VPC
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

# Create a subnet in that VPC
resource "aws_subnet" "web" {
  vpc_id     = aws_vpc.main.id  # Reference the VPC
  cidr_block = "10.0.1.0/24"
}

# Create an instance in that subnet
resource "aws_instance" "web" {
  subnet_id = aws_subnet.web.id  # Reference the subnet
  # ... other config ...
}
```

## Finding Resource Documentation

With hundreds of thousands of resource types available:

1. **Start with your provider's documentation**
   - Example: [AWS Provider Docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)

2. **Look for the infrastructure you need**
   - Want an EC2 instance? Search for "instance"
   - Need a database? Search for "database" or "rds"

3. **Check required vs optional arguments**
   - Required = Must provide
   - Optional = Has defaults

## Best Practices

1. **Use meaningful names** - `web_server` not `instance1`
2. **Group related resources** - Keep resources that work together in the same file
3. **Use consistent naming** - Pick a convention and stick to it
4. **Reference other resources** - Don't hardcode IDs
5. **Read the docs** - Each resource type has unique features

## Key Takeaways

1. **Resources are the core of Terraform** - Everything else supports them
2. **Each resource represents real infrastructure** - VMs, databases, networks, etc.
3. **Resource types come from providers** - AWS provider gives AWS resources
4. **Resources can reference each other** - Building complex systems
5. **Unique identifiers matter** - Type + name must be unique

Remember: When you write `resource` blocks, you're defining actual infrastructure that will be created in the real world. That's the power of Infrastructure as Code!
