# Chapter 2.1: Hello World - Explained Simply

## What This Chapter is About

This chapter teaches you how to create your very first Terraform project - launching a virtual machine (VM) on Amazon Web Services (AWS). Think of it like learning to write "Hello World" when you first learn programming, but for infrastructure.

## Key Concept: Infrastructure as Code

Before diving in, understand that:
- **Terraform** is like a remote control for creating cloud infrastructure
- **You** are the architect who designs what to build
- **Infrastructure** refers to cloud resources like virtual machines, networks, and databases

## The Project: Launching an AWS Virtual Machine

### Step 1: Research and Design

Before building anything, you need to know what you're building. The chapter identifies three essential pieces of information needed to create an AWS virtual machine:

1. **AMI (Amazon Machine Image)** - Think of this as the operating system template (like choosing Windows or Linux)
2. **Instance Type** - This determines how powerful your VM is (how much CPU and memory)
3. **Subnet ID** - This tells AWS which network to put your VM in

**Where to find this information:**
- AWS documentation
- AWS web console (for manual practice)
- Terraform provider documentation

### Step 2: Creating the Project Structure

Just like organizing files in folders, you need to set up your project:

```bash
# Create a new folder
mkdir terraform_aws_modules
cd terraform_aws_modules

# Initialize Git (for version control)
git init

# Create three Terraform files
touch main.tf lookups.tf providers.tf
```

**File purposes:**
- `providers.tf` - Tells Terraform which cloud services to use
- `lookups.tf` - Finds information we need (like the latest operating system)
- `main.tf` - Contains the main instructions for creating our VM

### Step 3: Setting Up Providers

Think of providers as plugins that let Terraform talk to different cloud services. For AWS:

```t
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"  # Which AWS datacenter to use
}
```

### Step 4: Looking Up Configuration Values

Instead of hardcoding values (which makes code inflexible), we use "data sources" to look up information dynamically:

**Finding the network (VPC and Subnet):**
```t
data "aws_vpc" "default" {
  default = true  # Use the default network
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]  # Reference the VPC we found
  }
}
```

**Finding the latest Ubuntu operating system:**
```t
data "aws_ami" "ubuntu" {
  owners      = ["099720109477"]  # Ubuntu's AWS account
  most_recent = true              # Get the newest version
  
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
  
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}
```

### Step 5: Creating the Instance

Now we combine everything to create our VM:

```t
resource "aws_instance" "hello_world" {
  ami           = data.aws_ami.ubuntu.id        # Use the Ubuntu we found
  subnet_id     = data.aws_subnets.default.ids[0]  # Use first subnet found
  instance_type = "t3.micro"                    # Small, cheap instance
}
```

### Step 6: Running Terraform

Three commands to remember:

1. **`terraform init`** - Downloads necessary plugins (run once at start)
2. **`terraform plan`** - Shows what Terraform will do (like a preview)
3. **`terraform apply`** - Actually creates the infrastructure

## Key Takeaways

1. **Reusability**: This same code can create VMs in any AWS account without changes
2. **Dynamic lookups**: Using data sources means your code automatically uses the latest operating system
3. **Scalability**: The difference between launching one VM and an entire system is just more configuration - the process is the same

## Why This Matters

- **No manual clicking**: Everything is defined in code
- **Repeatable**: Run the same code multiple times to get identical infrastructure
- **Shareable**: One person writes it, hundreds can use it
- **Version controlled**: Track changes over time with Git

This "Hello World" example is simple but demonstrates the fundamental power of Infrastructure as Code - turning manual, error-prone processes into automated, reliable ones.
