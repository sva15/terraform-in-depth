# Chapter 2.8: Modules 

## What This Chapter is About

This chapter introduces **modules** - Terraform's way of packaging and reusing code. Think of modules as reusable templates or blueprints for infrastructure that you or others have created.

## Key Concept: Modules = Reusable Infrastructure Templates

Imagine you're building with LEGO:
- **Resources** = Individual LEGO blocks
- **Modules** = Pre-built LEGO sets that you can use in your larger creation

Instead of building everything from scratch, modules let you use pre-built, tested infrastructure components.

## Basic Module Structure

```t
module "name_of_instance" {
  source = "where/to/get/module"
  
  # Module inputs (like function parameters)
  some_variable = "some_value"
  another_variable = data.source.attribute
}
```

## Module-Specific Meta Arguments

Modules have special meta arguments not found in resources:

### 1. Source (Required)
Tells Terraform where to find the module:

```t
# From Terraform Registry
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
}

# From local file system
module "web_server" {
  source = "./modules/web-server"
}

# From Git repository
module "database" {
  source = "git::https://github.com/company/terraform-modules.git//database"
}
```

### 2. Version
Controls which version of the module to use:

```t
module "vpn" {
  source  = "tedivm/dev-vpn/aws"
  version = "~> 1.0"  # Use version 1.x, but not 2.0
}
```

Version constraints:
- `"~> 1.0"` = 1.0 or higher, but less than 2.0
- `">= 1.0"` = 1.0 or any higher version
- `"= 1.0.0"` = Exactly version 1.0.0

### 3. Providers
Pass provider configurations to modules:

```t
module "us_infrastructure" {
  source = "./modules/regional-setup"
  
  providers = {
    aws = aws.us_east
  }
}
```

## Real Example: VPN Module

The chapter shows using a VPN module from the registry:

```t
# Instead of writing dozens of resources for a VPN...
module "vpn" {
  source  = "tedivm/dev-vpn/aws"
  version = "~> 1.0"
  
  # Module inputs
  identifier = "my-vpn"
  subnet_ids = data.aws_subnets.default.ids
}
```

This single module block might create:
- VPN gateway
- Security groups
- Routes
- VPN connections
- And more!

## How Modules Work

### 1. Module Inputs (Variables)
Modules accept inputs through variables:

```t
# Using the module
module "web_app" {
  source = "./modules/web-app"
  
  app_name     = "my-application"
  instance_type = "t3.micro"
  enable_https = true
}
```

### 2. Module Outputs
Modules can export values:

```t
# After creating the module
output "vpn_endpoint" {
  value = module.vpn.endpoint_url
}

output "vpn_client_config" {
  value = module.vpn.client_configuration
}
```

### 3. Module Resources
Inside, modules contain regular Terraform resources:

```t
# Inside the module (simplified)
resource "aws_instance" "app" {
  ami           = var.ami_id
  instance_type = var.instance_type
  
  tags = {
    Name = var.app_name
  }
}
```

## Why Use Modules?

### 1. Don't Repeat Yourself (DRY)
Instead of copying the same resources multiple times:

```t
# Without modules - repetitive
resource "aws_instance" "web1" {
  # 20 lines of configuration
}

resource "aws_instance" "web2" {
  # Same 20 lines of configuration
}

# With modules - clean and reusable
module "web1" {
  source = "./modules/web-server"
  name   = "web1"
}

module "web2" {
  source = "./modules/web-server"
  name   = "web2"
}
```

### 2. Use Community Solutions
Why reinvent the wheel?

```t
# Use a battle-tested VPC module
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["us-east-1a", "us-east-1b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = true
}
```

### 3. Standardization
Teams can create standard modules:

```t
# Company-standard web server
module "web_server" {
  source = "git::https://github.com/company/terraform-modules.git//web-server"
  
  app_name    = "customer-portal"
  environment = "production"
  # All security, monitoring, and compliance built-in!
}
```

## Module Sources

### Terraform Registry
```t
module "consul" {
  source = "hashicorp/consul/aws"
}
```

### Local Path
```t
module "vpc" {
  source = "./modules/networking/vpc"
}
```

### Git Repository
```t
module "app" {
  source = "git::https://github.com/company/modules.git//app?ref=v1.0.0"
}
```

### HTTP URL
```t
module "storage" {
  source = "https://example.com/terraform/modules/storage.zip"
}
```

## Simple Module Example

Here's what a basic module might look like:

```t
# Using a module to create a complete web application stack
module "web_application" {
  source  = "company/web-app/aws"
  version = "2.0.0"
  
  # Input variables for the module
  application_name = "customer-portal"
  environment      = "production"
  instance_count   = 3
  instance_type    = "t3.medium"
  
  # Pass data from our infrastructure
  vpc_id     = data.aws_vpc.main.id
  subnet_ids = data.aws_subnets.private.ids
  
  # Feature flags
  enable_monitoring = true
  enable_backups    = true
}

# Use outputs from the module
output "app_load_balancer_dns" {
  value = module.web_application.load_balancer_dns
}
```

## Key Takeaways

1. **Modules are reusable infrastructure templates** - Write once, use many times
2. **Three special arguments** - source (required), version, and providers
3. **Modules can come from many places** - Registry, local files, Git, HTTP
4. **Inputs and outputs** - Modules accept variables and can export values
5. **Leverage the community** - Thousands of modules available in the registry

While this chapter provides just an introduction, modules are one of Terraform's most powerful features. Chapter 3 will dive deep into creating and using modules effectively.
