# Chapter 2.2: Block Syntax

## What This Chapter is About

This chapter explains the fundamental building blocks of Terraform code - literally called "blocks." If you think of Terraform as a language for describing infrastructure, blocks are like the sentences that make up that language.

## Key Concept: Blocks as Nouns

The chapter uses a helpful analogy:
- **Blocks = Nouns** (things/objects in your infrastructure)
- **Arguments & Subblocks = Adjectives** (descriptions of those things)

Just like in English where nouns represent people, places, or things, in Terraform, blocks represent configuration settings, cloud resources, or data lookups.

## Basic Block Structure

Every block follows the same pattern:

```t
type "label" {
  parameter = "value"    # Arguments (descriptions)
  
  subblock {            # Nested blocks
    more_parameters = "value"
  }
}
```

### Real Example:
```t
resource "aws_instance" "hello_world" {
  ami           = "ami-12345"
  instance_type = "t3.micro"
}
```

This creates an AWS virtual machine named "hello_world".

## The 12 Block Types

Terraform has 12 different block types, each with a specific purpose:

### Essential Blocks:
1. **terraform** - Project settings (like which Terraform version to use)
2. **provider** - Configures cloud services (AWS, Azure, Google Cloud)
3. **resource** - Creates actual infrastructure (VMs, databases, networks)
4. **data** - Looks up existing infrastructure information

### Configuration Blocks:
5. **variable** - Accepts input from users
6. **locals** - Internal variables for your code
7. **output** - Exports information to share

### Organization Blocks:
8. **module** - Reusable infrastructure templates
9. **import** - Brings existing infrastructure under Terraform control
10. **moved** - Renames resources without recreating them
11. **removed** - Marks resources as removed safely
12. **check** - Validates your infrastructure

## Understanding Labels

Labels are how you name and identify blocks. Different blocks use labels differently:

### No Labels
```t
terraform {
  # No label needed - only one per project
}
```

### Single Label
```t
provider "aws" {
  # One label: "aws"
}

variable "instance_type" {
  # One label: "instance_type"
}
```

### Two Labels (Type + Name)
```t
resource "aws_instance" "web_server" {
  # First label: resource type (aws_instance)
  # Second label: your name for it (web_server)
}

data "aws_vpc" "main" {
  # First label: data source type (aws_vpc)
  # Second label: your name for it (main)
}
```

## Arguments vs Subblocks

### Arguments
- Use `=` sign
- Can only appear once
- Set specific values

```t
resource "aws_instance" "example" {
  ami           = "ami-12345"    # Argument
  instance_type = "t3.micro"     # Argument
}
```

### Subblocks
- No `=` sign
- Can appear multiple times
- Group related settings

```t
data "aws_ami" "ubuntu" {
  filter {                       # Subblock
    name   = "name"
    values = ["ubuntu-*"]
  }
  
  filter {                       # Another subblock
    name   = "virtualization-type"
    values = ["hvm"]
  }
}
```

## How Blocks Connect: Attributes

Blocks can share information through attributes:

```t
# This data block finds a VPC
data "aws_vpc" "default" {
  default = true
}

# This data block uses the VPC's ID
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]  # Using an attribute
  }
}
```

The second block references `data.aws_vpc.default.id` - this is how blocks share information.

## Order Doesn't Matter!

Unlike traditional programming, you can write Terraform blocks in any order:

```t
# This works fine even though the instance comes before the data lookup
resource "aws_instance" "web" {
  ami = data.aws_ami.ubuntu.id
}

data "aws_ami" "ubuntu" {
  most_recent = true
  # ... filters ...
}
```

Terraform automatically figures out dependencies and runs things in the correct order.

## Style Guidelines

Terraform has recommended formatting:

1. **Meta arguments** first (like `provider`, `depends_on`)
2. **Regular arguments** next (aligned with `=` signs)
3. **Subblocks** after arguments
4. **Special subblocks** last (like `lifecycle`)

```t
resource "aws_instance" "example" {
  provider = aws.west              # Meta argument

  ami           = "ami-12345"      # Regular arguments (aligned)
  instance_type = "t3.micro"       # Notice the = signs line up
  
  root_block_device {              # Subblock
    volume_size = 20
  }
  
  lifecycle {                      # Special subblock
    ignore_changes = [ami]
  }
}
```

Use `terraform fmt` to automatically format your code!

## Key Takeaways

1. **Blocks are the foundation** - Everything in Terraform is built with blocks
2. **Each block type has a purpose** - Resources create things, data looks things up
3. **Labels make blocks unique** - So you can reference them
4. **Blocks connect through attributes** - Sharing information between blocks
5. **Order is flexible** - Terraform figures out dependencies automatically
6. **Consistent style helps** - Makes code easier to read and maintain

This foundation helps you understand how Terraform code is structured, setting you up to write your own infrastructure as code.
