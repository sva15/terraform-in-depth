# Chapter 2.7: Meta Arguments 

## What This Chapter is About

This chapter covers **meta arguments** - special arguments that control HOW Terraform manages your infrastructure, not WHAT infrastructure to create. Think of them as "instructions to Terraform" rather than "settings for your infrastructure."

## Key Concept: Meta Arguments vs Regular Arguments

- **Regular Arguments**: Configure the infrastructure itself (like instance size, network settings)
- **Meta Arguments**: Tell Terraform how to handle the infrastructure (like "create new before destroying old")

### Analogy
If creating infrastructure is like cooking:
- Regular arguments = ingredients and cooking temperature
- Meta arguments = instructions like "prepare backup ingredients" or "don't throw away leftovers"

## The Main Meta Arguments

### 1. Provider - Choosing Your Connection

When you have multiple AWS accounts or regions configured:

```t
# Two AWS providers configured
provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "europe"
  region = "eu-west-1"
}

# Using the provider meta argument
resource "aws_instance" "us_server" {
  # Uses default provider (us-east-1)
  ami           = "ami-12345"
  instance_type = "t3.micro"
}

resource "aws_instance" "eu_server" {
  provider = aws.europe  # Meta argument!
  ami           = "ami-67890"
  instance_type = "t3.micro"
}
```

### 2. Lifecycle Block - Resource Management Rules

The lifecycle block contains several important settings:

#### create_before_destroy
```t
resource "aws_instance" "web" {
  ami           = data.aws_ami.latest.id
  instance_type = "t3.micro"
  
  lifecycle {
    create_before_destroy = true
  }
}
```

**What it does**: Creates the new instance BEFORE destroying the old one
**When to use**: For high-availability systems where downtime must be minimized
**When NOT to use**: When resources can't coexist (like unique names or IP addresses)

#### prevent_destroy
```t
resource "aws_db_instance" "production" {
  engine         = "postgres"
  instance_class = "db.t3.large"
  
  lifecycle {
    prevent_destroy = true
  }
}
```

**What it does**: Prevents Terraform from destroying this resource
**When to use**: Critical resources like production databases
**Limitations**: 
- Only accepts `true` or `false` (no variables)
- Doesn't prevent deletion if you remove the entire resource block

#### ignore_changes
```t
resource "aws_instance" "app" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
  
  tags = {
    Name = "App Server"
  }
  
  lifecycle {
    ignore_changes = [ami, tags]
  }
}
```

**What it does**: Tells Terraform to ignore changes to specific fields
**Common uses**:
- Ignore AMI updates (avoid unexpected replacements)
- Ignore tag changes (when other systems modify tags)
- Ignore any external modifications

**Special case - ignore everything**:
```t
lifecycle {
  ignore_changes = all  # Note: 'all' is not in brackets
}
```

#### replace_triggered_by
```t
resource "random_id" "config" {
  keepers = {
    config_hash = md5(file("app-config.json"))
  }
}

resource "aws_instance" "app" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
  
  lifecycle {
    replace_triggered_by = [
      random_id.config
    ]
  }
}
```

**What it does**: Forces resource replacement when other resources change
**Use case**: Replace instances when configuration files change

### 3. depends_on - Explicit Dependencies

Sometimes Terraform can't figure out dependencies automatically:

```t
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
}

resource "aws_nat_gateway" "private" {
  subnet_id = aws_subnet.public.id
  
  # NAT Gateway needs Internet Gateway but doesn't reference it
  depends_on = [
    aws_internet_gateway.main
  ]
}
```

**What it does**: Explicitly tells Terraform "create this after that"
**When to use**: When resources depend on each other but don't share data

## Real-World Example: Auto-Scaling Web Server

```t
# Look up the latest AMI
data "aws_ami" "app" {
  most_recent = true
  owners      = ["self"]
  
  filter {
    name   = "name"
    values = ["my-app-*"]
  }
}

# Production database - never destroy
resource "aws_db_instance" "main" {
  identifier     = "prod-database"
  engine         = "postgres"
  instance_class = "db.t3.medium"
  
  lifecycle {
    prevent_destroy = true
  }
}

# Web server instances
resource "aws_instance" "web" {
  count         = 2
  ami           = data.aws_ami.app.id
  instance_type = var.instance_type
  
  lifecycle {
    # Create new instances before destroying old ones
    create_before_destroy = true
    
    # Don't replace just because new AMI is available
    ignore_changes = [ami]
  }
  
  # Make sure RDS is ready first
  depends_on = [
    aws_db_instance.main
  ]
}
```

## Important Limitations

### 1. Literal Values Only
Many lifecycle arguments only accept literal values:
```t
# ❌ This won't work
lifecycle {
  create_before_destroy = var.zero_downtime
}

# ✅ This works
lifecycle {
  create_before_destroy = true
}
```

### 2. Planning Time Evaluation
Meta arguments are evaluated early, so they can't use values that aren't known until after resources are created.

### 3. Resource References in depends_on
The `depends_on` argument uses resource references without the `resource.` prefix:
```t
# ❌ Wrong
depends_on = [resource.aws_instance.web]

# ✅ Correct
depends_on = [aws_instance.web]
```

## Best Practices

### 1. Use ignore_changes for External Systems
```t
resource "aws_instance" "k8s_node" {
  # ... configuration ...
  
  lifecycle {
    # Kubernetes adds its own tags
    ignore_changes = [tags]
  }
}
```

### 2. Minimize Downtime in Production
```t
resource "aws_instance" "prod" {
  # ... configuration ...
  
  lifecycle {
    create_before_destroy = true
  }
}
```

### 3. Document Why You Use Meta Arguments
```t
resource "aws_db_instance" "audit" {
  # ... configuration ...
  
  lifecycle {
    # Required for compliance - audit logs must be retained
    prevent_destroy = true
  }
}
```

## Key Takeaways

1. **Meta arguments control Terraform's behavior**, not infrastructure settings
2. **Use lifecycle rules to manage updates** - prevent destruction, ignore changes, control replacement order
3. **depends_on handles hidden dependencies** - when Terraform can't figure it out automatically
4. **Most lifecycle arguments need literal values** - no variables allowed
5. **Think about production needs** - minimize downtime, prevent accidents, handle external changes

Meta arguments give you fine-grained control over how Terraform manages your infrastructure, making it safer and more reliable for production use.
