# Chapter 4.7: Try and Can

## What This Chapter is About

This chapter explains the **try and can functions** - two special functions in Terraform designed to handle potential errors gracefully. They allow you to work with expressions that might fail without causing your entire configuration to error.

## Key Concept: Error Handling Functions

Think of these functions like:
- **Safety nets**: Catching potential falls before they cause damage
- **Circuit breakers**: Preventing one failure from bringing down the system
- **Fallback options**: Having a Plan B when Plan A might not work

## The try Function

### Basic Usage - Fallback Values
```t
# try(expression1, expression2, ...) - returns first non-error result

locals {
  # Simple fallback
  safe_number = try(tonumber(var.input), 0)  # Returns 0 if conversion fails
  
  # Multiple fallbacks
  config_value = try(
    var.override_config,           # First choice
    local.default_config,          # Second choice
    "fallback"                     # Final fallback
  )
}
```

### Handling Optional Resources
```t
# Common pattern: optional resources with count
resource "aws_instance" "optional" {
  count = var.enable_instance ? 1 : 0
  # ... configuration
}

# Safe output when resource might not exist
output "instance_id" {
  description = "ID of the instance if created"
  value       = try(aws_instance.optional[0].id, null)
}

output "instance_ip" {
  description = "IP of the instance if created"
  value       = try(aws_instance.optional[0].private_ip, "No instance created")
}
```

### Complex Resource Lookups
```t
# Multiple optional resources
resource "aws_eip" "public" {
  count = var.assign_public_ip ? 1 : 0
}

resource "aws_instance" "main" {
  count = var.instance_count
}

# Safe access to nested attributes
output "public_ip" {
  value = try(
    aws_eip.public[0].public_ip,              # If EIP exists
    aws_instance.main[0].public_ip,           # If instance has public IP
    aws_instance.main[0].private_ip,          # Fallback to private
    "No IP available"                         # Final fallback
  )
}
```

### Working with Data Structures
```t
variable "config" {
  type    = any
  default = {}
}

locals {
  # Safe nested access
  database_host = try(var.config.database.host, "localhost")
  database_port = try(var.config.database.port, 5432)
  
  # Handle different structure possibilities
  api_endpoint = try(
    var.config.api.endpoint,                   # New structure
    var.config.api_endpoint,                   # Old structure
    "https://api.example.com"                  # Default
  )
}
```

## The can Function

### Basic Validation Usage
```t
# can(expression) - returns true if no error, false if error

variable "port_string" {
  type = string
  
  validation {
    condition     = can(tonumber(var.port_string))
    error_message = "Port must be a numeric string."
  }
  
  validation {
    condition = can(tonumber(var.port_string)) ? tonumber(var.port_string) >= 1 && tonumber(var.port_string) <= 65535 : false
    error_message = "Port must be between 1 and 65535."
  }
}
```

### Regex Validation
```t
variable "resource_name" {
  type = string
  
  validation {
    condition     = can(regex("^[a-z][a-z0-9-]*$", var.resource_name))
    error_message = "Name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens."
  }
}

variable "email" {
  type = string
  
  validation {
    # Multiple validation approaches
    condition = can(regex("^[^@]+@[^@]+\\.[^@]+$", var.email)) && length(var.email) <= 254
    error_message = "Must be a valid email address under 254 characters."
  }
}
```

### Type Checking
```t
variable "flexible_input" {
  type = any
  
  validation {
    condition = can(tostring(var.flexible_input)) || can(tonumber(var.flexible_input))
    error_message = "Input must be convertible to either string or number."
  }
}

variable "json_string" {
  type = string
  
  validation {
    condition     = can(jsondecode(var.json_string))
    error_message = "Must be valid JSON."
  }
}
```

## Practical Patterns

### Conditional Module Outputs
```t
# Module with optional components
resource "aws_lb" "main" {
  count = var.create_load_balancer ? 1 : 0
  # ... configuration
}

resource "aws_lb_listener" "http" {
  count = var.create_load_balancer && var.enable_http ? 1 : 0
  # ... configuration
}

# Safe outputs
output "load_balancer_dns" {
  description = "DNS name of load balancer if created"
  value       = try(aws_lb.main[0].dns_name, null)
}

output "load_balancer_endpoints" {
  description = "Available endpoints"
  value = {
    http  = try(aws_lb_listener.http[0].arn, null)
    https = try(aws_lb_listener.https[0].arn, null)
  }
}
```

### Dynamic Configuration Handling
```t
# Handle different configuration formats
variable "database_config" {
  type    = any
  default = {}
}

locals {
  # Support multiple configuration structures
  db_connection = {
    host = try(
      var.database_config.endpoint,        # RDS style
      var.database_config.host,           # Traditional style
      var.database_config.hostname,       # Alternative naming
      "localhost"                         # Default
    )
    
    port = try(
      var.database_config.port,
      var.database_config.database_port,
      5432
    )
    
    name = try(
      var.database_config.db_name,
      var.database_config.database,
      var.database_config.name,
      "postgres"
    )
  }
}
```

### Safe Resource Attribute Access
```t
# Multiple resources that might or might not exist
data "aws_ami" "custom" {
  count = var.use_custom_ami ? 1 : 0
  # ... filters
}

data "aws_ami" "default" {
  most_recent = true
  owners      = ["amazon"]
  # ... filters
}

locals {
  # Try custom AMI first, fall back to default
  selected_ami = try(
    data.aws_ami.custom[0].id,
    data.aws_ami.default.id
  )
  
  # Safe attribute access
  ami_details = {
    id   = local.selected_ami
    name = try(
      data.aws_ami.custom[0].name,
      data.aws_ami.default.name,
      "unknown"
    )
  }
}
```

## Advanced Examples

### Complex Input Validation
```t
variable "network_config" {
  type = object({
    vpc_cidr     = string
    subnet_count = number
    subnet_bits  = optional(number)
  })
  
  validation {
    condition = can(cidrhost(var.network_config.vpc_cidr, 0))
    error_message = "VPC CIDR must be a valid CIDR block."
  }
  
  validation {
    condition = can(
      [for i in range(var.network_config.subnet_count) : 
        cidrsubnet(var.network_config.vpc_cidr, var.network_config.subnet_bits, i)]
    )
    error_message = "VPC CIDR too small for requested subnet count and size."
  }
}
```

### Graceful Degradation
```t
# Support optional features gracefully
module "application" {
  source = "./modules/app"
  
  # Core configuration
  name = var.app_name
  
  # Optional features with graceful fallbacks
  database_url = try(
    module.database[0].connection_string,
    var.external_database_url,
    null
  )
  
  cache_endpoint = try(
    aws_elasticache_cluster.redis[0].cache_nodes[0].address,
    var.external_cache_endpoint,
    null
  )
  
  cdn_domain = try(
    aws_cloudfront_distribution.cdn[0].domain_name,
    var.custom_domain,
    null
  )
}
```

## Best Practices

### 1. Use can() Primarily for Validation
```t
# ✅ Good - validation use case
variable "config_json" {
  type = string
  
  validation {
    condition     = can(jsondecode(var.config_json))
    error_message = "Must be valid JSON."
  }
}

# ❌ Avoid - using can() for general logic
locals {
  # Don't do this - use try() instead
  has_value = can(var.optional_map["key"])
}
```

### 2. Document Why You're Using try()
```t
# ✅ Good - clear reasoning
output "endpoint" {
  # Use public endpoint if available, otherwise private
  # This handles cases where public access is optionally disabled
  value = try(
    aws_lb.public[0].dns_name,
    aws_lb.internal[0].dns_name
  )
}

# ❌ Bad - hiding potential issues
locals {
  # Don't hide real errors
  value = try(broken_expression, "default")
}
```

### 3. Avoid Overuse
```t
# ❌ Bad - too many try() calls
locals {
  nested = try(try(try(var.a.b.c, var.d.e.f), var.g.h), "default")
}

# ✅ Good - restructure for clarity
locals {
  source_value = var.use_primary ? var.primary_config : var.secondary_config
  final_value  = try(local.source_value.nested.value, "default")
}
```

### 4. Prefer Explicit Conditionals When Possible
```t
# Sometimes explicit is better than try()

# ❌ Overusing try
output "ip" {
  value = try(aws_instance.main[0].public_ip, aws_instance.main[0].private_ip)
}

# ✅ More explicit
output "ip" {
  value = aws_instance.main[0].public_ip != "" ? 
          aws_instance.main[0].public_ip : 
          aws_instance.main[0].private_ip
}
```

## Common Pitfalls

### Don't Hide Real Errors
```t
# ❌ Bad - hiding configuration errors
resource "aws_instance" "bad" {
  instance_type = try(var.instance_types[var.environment], "t3.micro")
  # If environment is misspelled, error is hidden
}

# ✅ Good - validate inputs properly
variable "environment" {
  validation {
    condition     = contains(keys(var.instance_types), var.environment)
    error_message = "Environment must be one of: ${join(", ", keys(var.instance_types))}"
  }
}

resource "aws_instance" "good" {
  instance_type = var.instance_types[var.environment]
}
```

### Be Careful with Type Conversions
```t
# can() with type conversion can be tricky
variable "numeric_string" {
  type = string
  
  validation {
    # This passes for "123abc" because tonumber partially succeeds!
    condition = can(tonumber(var.numeric_string))
    # Better to use regex for strict validation
    condition = can(regex("^\\d+$", var.numeric_string))
  }
}
```

## Key Takeaways

1. **try() returns first non-error result** - Great for fallback values
2. **can() converts errors to false** - Primarily for validation blocks
3. **Common for optional resources** - Handle count = 0 cases gracefully
4. **Don't hide real errors** - Use for expected failures, not bugs
5. **Document your reasoning** - Explain why errors are expected
6. **Prefer explicit conditionals** - When the logic is clearer that way
7. **Validation is can()'s main use** - Avoid using it elsewhere

These functions are powerful tools for handling Terraform's dynamic nature, especially when dealing with optional resources and flexible module interfaces.
