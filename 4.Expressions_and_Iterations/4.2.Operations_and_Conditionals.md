# Chapter 4.2: Operators and Conditionals

## What This Chapter is About

This chapter explains **operators and conditionals** in Terraform - the symbols and expressions that let you perform calculations, make comparisons, and create dynamic logic in your configurations.

## Key Concept: Operators = Actions on Values

Think of operators like:
- **Math symbols**: +, -, ×, ÷ for calculations
- **Comparison tools**: Checking if one value is greater, equal, or different
- **Logic gates**: Combining true/false conditions to make decisions

## Mathematical Operators

### Basic Math Operations
```t
# Table of math operators
# + : Addition
# - : Subtraction  
# * : Multiplication
# / : Division
# % : Modulus (remainder)

locals {
  # Basic calculations
  total_instances = 5 + 3                    # 8
  remaining_capacity = 100 - 37              # 63
  total_storage = 20 * 5                     # 100 GB
  instances_per_zone = 12 / 3                # 4
  remainder = 17 % 5                         # 2 (17 ÷ 5 = 3 remainder 2)
}
```

### Real-World Example
```t
locals {
  # Ensure no more than 3 availability zones
  availability_zones = min(var.active_availability_zones, 3)
  
  # Calculate total subnets needed (2 per AZ)
  needed_subnets = local.availability_zones * 2
  
  # Calculate instance distribution
  instances_per_zone = floor(var.total_instances / local.availability_zones)
  extra_instances = var.total_instances % local.availability_zones
}

# Using calculations in resources
resource "aws_subnet" "main" {
  count = local.needed_subnets
  
  cidr_block = cidrsubnet(
    var.vpc_cidr,
    4,  # Add 4 bits to mask
    count.index
  )
}
```

## Comparison Operators

### Comparing Values
```t
# Table of comparison operators
# == : Equal to
# != : Not equal to
# <  : Less than
# <= : Less than or equal
# >  : Greater than
# >= : Greater than or equal

locals {
  # Numeric comparisons
  is_production = var.environment == "prod"        # true if prod
  not_dev = var.environment != "dev"              # true if not dev
  high_capacity = var.instance_count > 10         # true if over 10
  within_limit = var.storage_gb <= 1000           # true if 1000 or less
  
  # String comparisons
  is_large = var.instance_type == "t3.large"      # Exact match
  
  # Type matters!
  string_vs_number = "15" == 15                   # false (different types)
  with_conversion = tonumber("15") == 15          # true (same type)
}
```

### Practical Examples
```t
# Validation using comparisons
variable "port" {
  type = number
  
  validation {
    condition     = var.port >= 1 && var.port <= 65535
    error_message = "Port must be between 1 and 65535."
  }
}

# Conditional logic based on comparisons
locals {
  # Different instance types based on count
  instance_type = var.instance_count > 5 ? "t3.large" : "t3.small"
  
  # Enable monitoring for production or high-traffic
  enable_monitoring = (
    var.environment == "prod" || 
    var.expected_traffic > 1000
  )
}
```

## Boolean Operators

### Combining Conditions
```t
# Table of boolean operators
# || : OR  - true if ANY condition is true
# && : AND - true if ALL conditions are true
# !  : NOT - reverses true/false

locals {
  # OR examples
  needs_backup = var.is_production || var.contains_data      # Either condition
  
  # AND examples  
  high_risk = var.is_production && var.is_public            # Both conditions
  
  # NOT examples
  is_private = !var.is_public                              # Opposite of public
  
  # Complex combinations
  requires_encryption = (
    (var.environment == "prod" || var.environment == "staging") &&
    var.data_classification == "sensitive" &&
    !var.encryption_exempt
  )
}
```

### Real-World Boolean Logic
```t
# Determine if enhanced monitoring is needed
locals {
  enable_enhanced_monitoring = (
    var.environment == "prod" ||                    # Production
    var.instance_count > 10 ||                      # Many instances
    (var.cpu_credits == "unlimited" && var.monitoring_override)  # Special case
  )
}

# Multi-condition security rules
variable "allow_ssh" {
  type = bool
  
  validation {
    condition = (
      !var.allow_ssh ||                            # Either SSH is disabled
      (var.ssh_key_name != "" && length(var.ssh_cidrs) > 0)  # Or properly configured
    )
    error_message = "SSH requires both key name and allowed CIDRs."
  }
}
```

## Conditional Expressions (Ternary Operator)

### Basic Syntax
```t
# condition ? value_if_true : value_if_false

locals {
  # Simple examples
  environment_label = var.is_production ? "prod" : "dev"
  instance_type = var.high_performance ? "m5.xlarge" : "t3.medium"
  
  # Numeric outputs
  replica_count = var.enable_ha ? 3 : 1
  backup_days = var.environment == "prod" ? 30 : 7
}
```

### Enabling/Disabling Resources
```t
# The classic pattern: boolean to count
resource "aws_eip" "nat" {
  count = var.enable_nat_gateway ? 1 : 0
  
  tags = {
    Name = "${var.name_prefix}-nat-eip"
  }
}

# Multiple related resources
resource "aws_nat_gateway" "main" {
  count = var.enable_nat_gateway ? length(var.public_subnets) : 0
  
  subnet_id     = var.public_subnets[count.index]
  allocation_id = aws_eip.nat[count.index].id
}
```

### Complex Module Selection
```t
# Choose between different implementations
variable "use_fargate" {
  type        = bool
  description = "Use Fargate instead of EC2 for ECS"
  default     = false
}

module "ecs_ec2" {
  source = "./modules/ecs-ec2"
  count  = var.use_fargate ? 0 : 1  # Only if NOT Fargate
  
  cluster_name = var.cluster_name
  instance_type = var.instance_type
}

module "ecs_fargate" {
  source = "./modules/ecs-fargate"
  count  = var.use_fargate ? 1 : 0  # Only if Fargate
  
  cluster_name = var.cluster_name
  cpu = var.fargate_cpu
  memory = var.fargate_memory
}

# Output the right value based on choice
output "cluster_id" {
  value = var.use_fargate ? 
    module.ecs_fargate[0].cluster_id : 
    module.ecs_ec2[0].cluster_id
}
```

## Order of Operations

### Precedence Rules
```t
# Order (highest to lowest):
# 1. !, - (negation)
# 2. *, /, %
# 3. +, -
# 4. >, >=, <, <=
# 5. ==, !=
# 6. &&
# 7. ||

locals {
  # Without parentheses - follows order
  confusing = 2 + 4 / 2 * 3 > 5 && true || false
  # Evaluates as: 2 + ((4 / 2) * 3) > 5 && true || false
  # = 2 + (2 * 3) > 5 && true || false
  # = 2 + 6 > 5 && true || false
  # = 8 > 5 && true || false
  # = true && true || false
  # = true || false
  # = true
  
  # With parentheses - clear intent
  clear = ((2 + 4) / (2 * 3)) > 5 && (true || false)
  # = (6 / 6) > 5 && true
  # = 1 > 5 && true
  # = false && true
  # = false
}
```

### Best Practice: Use Parentheses
```t
# ❌ Hard to read
locals {
  unclear = var.count * 2 + 5 > 10 && var.enabled || var.override
}

# ✅ Clear intent
locals {
  clear = ((var.count * 2 + 5) > 10 && var.enabled) || var.override
}

# ✅ Even clearer with intermediate values
locals {
  adjusted_count = var.count * 2 + 5
  meets_threshold = local.adjusted_count > 10
  should_enable = (local.meets_threshold && var.enabled) || var.override
}
```

## Practical Examples

### Resource Sizing Logic
```t
locals {
  # Determine instance size based on workload
  base_cpu_per_user = 0.5
  overhead_cpu = 2
  total_cpu_needed = (var.user_count * local.base_cpu_per_user) + local.overhead_cpu
  
  # Select instance type based on CPU needs
  instance_type = (
    local.total_cpu_needed <= 2 ? "t3.small" :
    local.total_cpu_needed <= 4 ? "t3.medium" :
    local.total_cpu_needed <= 8 ? "t3.large" :
    "t3.xlarge"
  )
}
```

### Conditional Security Rules
```t
resource "aws_security_group_rule" "ssh" {
  count = var.enable_ssh && length(var.ssh_allowed_cidrs) > 0 ? 1 : 0
  
  type        = "ingress"
  from_port   = 22
  to_port     = 22
  protocol    = "tcp"
  cidr_blocks = var.ssh_allowed_cidrs
  
  security_group_id = aws_security_group.main.id
}

resource "aws_security_group_rule" "https" {
  count = var.enable_https || var.environment == "prod" ? 1 : 0
  
  type        = "ingress"
  from_port   = 443
  to_port     = 443
  protocol    = "tcp"
  cidr_blocks = var.environment == "prod" ? ["0.0.0.0/0"] : var.allowed_cidrs
  
  security_group_id = aws_security_group.main.id
}
```

## Important Notes

### Terraform Evaluates Both Sides
```t
# ⚠️ This might cause errors!
output "risky" {
  # Both module.a[0].value and module.b[0].value are evaluated
  value = var.use_a ? module.a[0].value : module.b[0].value
}

# ✅ Safe approach using try()
output "safe" {
  value = var.use_a ? 
    try(module.a[0].value, null) : 
    try(module.b[0].value, null)
}
```

## Key Takeaways

1. **Math operators** - Standard arithmetic for calculations
2. **Comparison operators** - Test relationships between values
3. **Boolean operators** - Combine multiple conditions
4. **Conditional expressions** - Create if-then logic with `? :`
5. **Order matters** - Use parentheses for clarity
6. **Type awareness** - Comparisons require matching types
7. **Both sides evaluated** - Conditional expressions evaluate both results

Operators and conditionals are the building blocks for creating dynamic, flexible Terraform configurations that adapt to different requirements and environments.
