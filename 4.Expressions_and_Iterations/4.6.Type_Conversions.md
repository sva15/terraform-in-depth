# Chapter 4.6: Type Conversion

## What This Chapter is About

This chapter explains **type conversion** in Terraform - how values change from one type to another. Terraform handles many conversions automatically, but also provides explicit functions for when you need precise control.

## Key Concept: Type Flexibility

Think of type conversion like:
- **Currency exchange**: Converting dollars to euros when needed
- **Unit conversion**: Changing meters to feet for different uses
- **Format adaptation**: Same data, different representation

## Implicit Type Conversion

### Automatic Conversions
```t
# Terraform converts types automatically when possible

locals {
  # Number to string conversion
  number_value = 42
  string_result = substr(local.number_value, 0, 2)  # "42" - auto-converted
  
  # String to number conversion
  string_value = "123"
  math_result = local.string_value + 77  # 200 - auto-converted
  
  # Boolean to string
  bool_value = true
  message = "Feature enabled: ${local.bool_value}"  # "Feature enabled: true"
}

# Real example with substr
locals {
  pi = 3.14159
  pi_truncated = substr(local.pi, 0, 4)  # "3.14" - number becomes string
}
```

### When Implicit Conversion Works
```t
# ✅ These work automatically
locals {
  # String "25" → Number 25
  count_from_string = "5" * 2  # 10
  
  # Number 100 → String "100"
  text_with_number = "Total: ${100}"  # "Total: 100"
  
  # Boolean → String
  status = "Enabled: ${true}"  # "Enabled: true"
  
  # String → Boolean (specific values only)
  flag_from_string = "true" ? "yes" : "no"  # "yes"
}
```

### When It Doesn't Work
```t
# ❌ These will error or give unexpected results

locals {
  # Equality checks don't convert types
  are_equal = "42" == 42  # false (different types)
  
  # Invalid string to number
  # bad_math = "abc" + 5  # ERROR!
  
  # Complex type conversions
  # list_to_string = "Values: ${[1, 2, 3]}"  # ERROR!
}
```

## Explicit Type Conversion Functions

### Basic Type Conversions
```t
# tostring() - Convert to string
locals {
  number_as_string = tostring(42)           # "42"
  bool_as_string = tostring(true)           # "true"
  
  # Useful for string operations
  version_number = 2.5
  version_string = tostring(local.version_number)
  major_version = split(".", local.version_string)[0]  # "2"
}

# tonumber() - Convert to number
locals {
  string_number = "123.45"
  actual_number = tonumber(local.string_number)  # 123.45
  
  # Common pattern: user input validation
  port_string = "8080"
  port_number = tonumber(local.port_string)
}

# tobool() - Convert to boolean
locals {
  string_true = "true"
  bool_value = tobool(local.string_true)  # true
  
  # Only works with "true"/"false" strings
  string_false = "false"
  bool_false = tobool(local.string_false)  # false
}
```

### Collection Type Conversions
```t
# tolist() - Convert to list
locals {
  # Set to list (removes duplicates, loses order)
  unique_items = tolist(toset(["a", "b", "a", "c"]))  # ["a", "b", "c"]
  
  # Tuple to list
  from_tuple = tolist(["one", "two", "three"])
}

# toset() - Convert to set
locals {
  # Common pattern: use with for_each
  instance_names = ["web-1", "web-2", "app-1"]
  
  # for_each requires set or map
  instance_set = toset(local.instance_names)
}

resource "aws_instance" "servers" {
  for_each = local.instance_set
  
  tags = {
    Name = each.value
  }
}

# tomap() - Convert to map
locals {
  # Object to map
  object_value = {
    name = "example"
    type = "demo"
  }
  
  map_value = tomap(local.object_value)
}
```

## Practical Conversion Patterns

### Normalizing Module Outputs
```t
# Module outputs should have consistent types

# variables.tf
variable "create_instances" {
  type    = bool
  default = true
}

variable "instance_count" {
  type    = number
  default = 3
}

# main.tf
resource "aws_instance" "web" {
  count = var.create_instances ? var.instance_count : 0
  # ...
}

# outputs.tf - Normalize output types
output "instance_ids" {
  # Always return a list, even if empty
  value = tolist(aws_instance.web[*].id)
}

output "instance_count" {
  # Always return a number
  value = tonumber(length(aws_instance.web))
}

output "instances_created" {
  # Consistent boolean output
  value = tobool(length(aws_instance.web) > 0)
}
```

### Working with for_each
```t
# for_each requires set or map types

# List from variable
variable "subnet_ids" {
  type = list(string)
}

# Convert to set for for_each
resource "aws_instance" "distributed" {
  for_each = toset(var.subnet_ids)
  
  subnet_id = each.value
  # ...
}

# Creating a map from lists
variable "instance_names" {
  type = list(string)
}

variable "instance_types" {
  type = list(string)
}

locals {
  # Combine into map for for_each
  instance_config = tomap({
    for idx, name in var.instance_names :
    name => var.instance_types[idx]
  })
}

resource "aws_instance" "fleet" {
  for_each = local.instance_config
  
  tags = {
    Name = each.key
  }
  instance_type = each.value
}
```

## Sensitive and Nonsensitive Functions

### Making Values Sensitive
```t
# sensitive() - Mark a value as sensitive

# Example: Protecting generated values
resource "random_password" "db" {
  length = 32
}

locals {
  # Mark as sensitive if not already
  db_password_sensitive = sensitive(random_password.db.result)
}

# Example: Protecting combined values
variable "username" {
  type = string
}

locals {
  # Create sensitive connection string
  connection_string = sensitive(
    "postgresql://${var.username}:${random_password.db.result}@db.example.com:5432/mydb"
  )
}
```

### Removing Sensitivity (Use Carefully!)
```t
# nonsensitive() - Remove sensitive marking

variable "api_key" {
  type      = string
  sensitive = true
}

# Sometimes you need non-sensitive derived values
locals {
  # Extract non-sensitive part
  api_key_prefix = nonsensitive(substr(var.api_key, 0, 4))
  
  # Document why this is safe
  api_key_masked = nonsensitive("${local.api_key_prefix}****")
}

# Common pattern: Conditional sensitivity
output "debug_info" {
  value = var.debug_mode ? nonsensitive(var.api_key) : "REDACTED"
  
  # Always document why you're removing sensitivity
  description = "API key shown only in debug mode for troubleshooting"
}
```

### Sensitivity Propagation
```t
# Sensitivity "infects" derived values

variable "database_password" {
  type      = string
  sensitive = true
}

locals {
  # These all become sensitive automatically
  connection_url = "mysql://admin:${var.database_password}@localhost"  # Sensitive!
  
  config = {
    url      = local.connection_url  # Sensitive!
    password = var.database_password # Sensitive!
  }
  
  # Even seemingly innocent operations
  password_length = length(var.database_password)  # Also sensitive!
}

# To use the length publicly, explicitly remove sensitivity
output "password_complexity" {
  value = nonsensitive(local.password_length) > 12 ? "Strong" : "Weak"
  
  description = "Password strength indicator (length only, not the password itself)"
}
```

## Real-World Examples

### API Configuration Module
```t
# Module that handles various input formats

variable "port" {
  description = "API port (string or number)"
  type        = any
  default     = "8080"
}

variable "enable_ssl" {
  description = "Enable SSL (string or bool)"
  type        = any
  default     = "true"
}

variable "timeout_seconds" {
  description = "Timeout in seconds"
  type        = string
  default     = "30"
}

locals {
  # Normalize all inputs to expected types
  config = {
    port    = tonumber(var.port)
    ssl     = tobool(var.enable_ssl)
    timeout = tonumber(var.timeout_seconds)
  }
  
  # Build URL with correct types
  base_url = "${local.config.ssl ? "https" : "http"}://api.example.com:${local.config.port}"
}

output "configuration" {
  value = local.config
  
  description = "Normalized configuration with consistent types"
}
```

### Dynamic Resource Creation
```t
# Handle different input formats gracefully

variable "instance_names" {
  description = "Instance names (list or comma-separated string)"
  type        = any
}

locals {
  # Handle both list and string inputs
  names_list = try(
    tolist(var.instance_names),                    # Already a list
    split(",", tostring(var.instance_names)),     # Comma-separated string
    []                                             # Fallback
  )
  
  # Ensure unique names for for_each
  names_set = toset([for name in local.names_list : trimspace(name)])
}

resource "aws_instance" "dynamic" {
  for_each = local.names_set
  
  tags = {
    Name = each.value
  }
}
```

## Best Practices

### 1. Be Explicit When Types Matter
```t
# ❌ Relying on implicit conversion
output "total_cost" {
  value = var.instance_count * var.price_per_hour * "24"  # Works but unclear
}

# ✅ Explicit conversion
output "total_cost" {
  value = tonumber(var.instance_count) * tonumber(var.price_per_hour) * 24
}
```

### 2. Normalize at Module Boundaries
```t
# In module outputs
output "instance_ids" {
  value = toset(aws_instance.all[*].id)  # Always return consistent type
}

# In module inputs
locals {
  # Normalize inputs immediately
  normalized_tags = tomap(var.tags)
  instance_count = tonumber(var.count)
}
```

### 3. Document Sensitivity Changes
```t
# Always explain why you're changing sensitivity

locals {
  # Remove sensitivity from password length for monitoring
  # This is safe because length doesn't reveal the password
  password_length_public = nonsensitive(length(var.db_password))
  
  # Mark user data as sensitive even though input isn't
  # Contains merged data from multiple sources including secrets
  full_user_data = sensitive(local.merged_user_data)
}
```

### 4. Use Type Conversion for Validation
```t
variable "numeric_string" {
  type = string
  
  validation {
    condition     = can(tonumber(var.numeric_string))
    error_message = "Value must be convertible to a number."
  }
}
```

## Key Takeaways

1. **Terraform auto-converts when possible** - But not for equality checks
2. **Explicit is better than implicit** - Use toType() functions for clarity
3. **for_each needs sets or maps** - Common use for toset()
4. **Normalize at boundaries** - Consistent types in module interfaces
5. **Sensitivity propagates** - Derived values inherit sensitivity
6. **Document sensitivity changes** - Explain why you use sensitive()/nonsensitive()
7. **Type conversion ≠ validation** - "123abc" might partially convert

Type conversion functions help ensure your Terraform configurations handle different input formats gracefully while maintaining type safety and security.
