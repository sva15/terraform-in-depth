# Chapter 4.1: Expanding Our Module

## What This Chapter is About

This chapter demonstrates **expanding a basic module** to handle real-world feature requests. It shows how to research requirements, implement new functionality, and make modules more flexible without losing simplicity.

## Key Concept: Module Evolution

Think of module expansion like:
- **Home renovation**: Adding rooms and features based on resident needs
- **Software updates**: Adding features users request while maintaining compatibility
- **Recipe variations**: Adapting a basic recipe for different dietary needs and tastes

## The Feature Requests

Four teams need enhancements:
1. **Team 1**: Grant instances permissions to access AWS services (like S3)
2. **Team 2**: Enable AWS Session Manager (SSH-less access)
3. **Team 3**: Launch multiple instances
4. **Team 4**: Name instances in AWS Console

## Step 1: Research Process

### The Research Flow
```
Feature Request → Documentation Review → Search Solutions → Test Options → Implement
```

### Example Research Path
```
"How to name EC2 instance in AWS Console?"
    ↓
Stack Overflow: "Use Name tag"
    ↓
AWS Docs: "Tags are key/value pairs"
    ↓
Terraform Docs: "Use tags argument"
    ↓
Implementation Plan
```

## Step 2: Adding Names and Tags

### The Solution
```t
# variables.tf additions
variable "name_prefix" {
  type        = string
  description = "The prefix to apply to generated names"
}

variable "tags" {
  type        = map(string)
  description = "Key/Value pairs to pass to AWS as Tags"
  default     = {}
}

# main.tf update
resource "aws_instance" "hello_world" {
  ami           = data.aws_ami.ubuntu.id
  subnet_id     = var.subnet_id
  instance_type = var.instance_type
  
  tags = merge(var.tags, {
    Name = "${var.name_prefix}-instance"  # Special "Name" tag
  })
}
```

### Key Points
- **Name tag is special** - Shows in AWS Console
- **merge() function** - Combines user tags with module tags
- **Prefix pattern** - Prepares for multiple instances

## Step 3: Enabling Multiple Instances

### Using count Meta-Parameter
```t
# variables.tf addition
variable "instance_count" {
  type        = number
  description = "The number of instances to launch"
  default     = 0
  
  validation {
    condition     = floor(var.instance_count) == var.instance_count
    error_message = "The instance count must be a whole number."
  }
  
  validation {
    condition     = var.instance_count >= 0
    error_message = "The instance count cannot be negative."
  }
}

# main.tf update
resource "aws_instance" "hello_world" {
  count = var.instance_count  # Creates this many instances
  
  ami           = data.aws_ami.ubuntu.id
  subnet_id     = var.subnet_id
  instance_type = var.instance_type
  
  tags = merge(var.tags, {
    Name = "${var.name_prefix}-${count.index}"  # Unique names
  })
}
```

### What count Provides
- **count.index** - Unique number for each instance (0, 1, 2...)
- **Resource arrays** - Creates `aws_instance.hello_world[0]`, `[1]`, etc.

## Step 4: Creating IAM Role

### Understanding the Need
AWS instances need IAM roles to access other services. Our module should:
- Create the basic role structure
- Let users attach their own policies

### Implementation
```t
# Create assume role policy (who can use this role)
data "aws_iam_policy_document" "instance_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]
    
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]  # Only EC2 can use this role
    }
  }
}

# Create the IAM role
resource "aws_iam_role" "main" {
  name               = "${var.name_prefix}-instance-role"
  assume_role_policy = data.aws_iam_policy_document.instance_assume_role_policy.json
}

# Create instance profile (links role to EC2)
resource "aws_iam_instance_profile" "main" {
  name = aws_iam_role.main.name
  role = aws_iam_role.main.name
}

# Update instance to use the profile
resource "aws_instance" "hello_world" {
  count                = var.instance_count
  iam_instance_profile = aws_iam_instance_profile.main.name
  # ... other configuration
}

# Export the role for users to attach policies
output "aws_instance_role" {
  description = "The IAM role for the instances"
  value       = aws_iam_role.main
}
```

## Step 5: Enabling Session Manager

### Conditional Resource Creation
```t
# variables.tf addition
variable "enable_systems_manager" {
  type        = bool
  description = "Enable AWS Systems Manager for instances"
  default     = false
}

# Look up AWS managed policy
data "aws_iam_policy" "ssm_arn" {
  arn = "arn:aws:iam::aws:policy/AmazonSSMManagedEC2InstanceDefaultPolicy"
}

# Conditionally attach the policy
resource "aws_iam_role_policy_attachment" "ssm_attach" {
  count      = var.enable_systems_manager ? 1 : 0  # 0 or 1
  role       = aws_iam_role.main.name
  policy_arn = data.aws_iam_policy.ssm_arn.arn
}
```

### The Ternary Operator
```t
condition ? value_if_true : value_if_false

# Examples:
count = var.enable_backups ? 1 : 0
size  = var.environment == "prod" ? "large" : "small"
```

## Complete Enhanced Module

### File Structure
```
modules/ec2_instance/
├── main.tf
├── variables.tf
├── outputs.tf
└── README.md
```

### Complete variables.tf
```t
variable "instance_type" {
  type        = string
  description = "The type of instance to launch"
  default     = "t3.micro"
}

variable "subnet_id" {
  type        = string
  description = "The subnet to launch instances in"
  
  validation {
    condition     = can(regex("^subnet-[a-f0-9]+$", var.subnet_id))
    error_message = "Must be a valid subnet ID."
  }
}

variable "instance_count" {
  type        = number
  description = "Number of instances to create"
  default     = 1
  
  validation {
    condition     = floor(var.instance_count) == var.instance_count && var.instance_count >= 0
    error_message = "Must be a non-negative whole number."
  }
}

variable "name_prefix" {
  type        = string
  description = "Prefix for resource names"
  
  validation {
    condition     = length(var.name_prefix) <= 32
    error_message = "Name prefix must be 32 characters or less."
  }
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to resources"
  default     = {}
}

variable "enable_systems_manager" {
  type        = bool
  description = "Enable AWS Systems Manager"
  default     = false
}
```

### Complete main.tf
```t
# Data sources
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]
  
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

data "aws_iam_policy_document" "instance_assume_role_policy" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
  }
}

data "aws_iam_policy" "ssm_arn" {
  count = var.enable_systems_manager ? 1 : 0
  arn   = "arn:aws:iam::aws:policy/AmazonSSMManagedEC2InstanceDefaultPolicy"
}

# IAM resources
resource "aws_iam_role" "main" {
  name               = "${var.name_prefix}-instance-role"
  assume_role_policy = data.aws_iam_policy_document.instance_assume_role_policy.json
  
  tags = var.tags
}

resource "aws_iam_instance_profile" "main" {
  name = aws_iam_role.main.name
  role = aws_iam_role.main.name
  
  tags = var.tags
}

resource "aws_iam_role_policy_attachment" "ssm_attach" {
  count      = var.enable_systems_manager ? 1 : 0
  role       = aws_iam_role.main.name
  policy_arn = data.aws_iam_policy.ssm_arn[0].arn
}

# EC2 instances
resource "aws_instance" "hello_world" {
  count = var.instance_count
  
  ami                  = data.aws_ami.ubuntu.id
  instance_type        = var.instance_type
  subnet_id            = var.subnet_id
  iam_instance_profile = aws_iam_instance_profile.main.name
  
  tags = merge(var.tags, {
    Name = "${var.name_prefix}-${count.index}"
  })
}
```

### Complete outputs.tf
```t
output "instance_ids" {
  description = "IDs of created instances"
  value       = aws_instance.hello_world[*].id
}

output "instance_arns" {
  description = "ARNs of created instances"
  value       = aws_instance.hello_world[*].arn
}

output "private_ips" {
  description = "Private IPs of instances"
  value       = aws_instance.hello_world[*].private_ip
}

output "iam_role" {
  description = "IAM role for attaching policies"
  value       = aws_iam_role.main
}

output "iam_role_arn" {
  description = "ARN of the IAM role"
  value       = aws_iam_role.main.arn
}
```

## Using the Enhanced Module

### Basic Usage
```t
module "web_servers" {
  source = "github.com/YOUR_USERNAME/terraform-aws-in-depth//modules/ec2_instance"
  
  instance_count = 3
  name_prefix    = "web"
  subnet_id      = data.aws_subnet.public.id
  
  tags = {
    Environment = "production"
    Team        = "platform"
  }
}
```

### With Custom Permissions
```t
module "app_servers" {
  source = "github.com/YOUR_USERNAME/terraform-aws-in-depth//modules/ec2_instance"
  
  instance_count         = 2
  name_prefix           = "app"
  subnet_id             = data.aws_subnet.private.id
  enable_systems_manager = true
  
  tags = {
    Environment = "production"
  }
}

# Attach S3 access policy to the role
resource "aws_iam_role_policy_attachment" "s3_access" {
  role       = module.app_servers.iam_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"
}
```

## Key Techniques Learned

### 1. Research-Driven Development
- Start with documentation
- Search for examples
- Test assumptions

### 2. Dynamic Resource Creation
```t
# Using count for multiple resources
count = var.instance_count

# Conditional resources
count = var.enable_feature ? 1 : 0
```

### 3. Flexible Interfaces
```t
# Merge user input with defaults
tags = merge(var.tags, {
  ManagedBy = "Terraform"
})
```

### 4. Extensibility Through Outputs
```t
# Export complex resources for user customization
output "iam_role" {
  value = aws_iam_role.main
}
```

## Key Takeaways

1. **Research before coding** - Understanding requirements prevents rework
2. **Use count for flexibility** - Enable variable resource quantities
3. **Conditional resources** - Toggle features with ternary operators
4. **Export extension points** - Let users add their own customizations
5. **Merge for customization** - Combine user input with sensible defaults
6. **Validate inputs** - Catch configuration errors early

This evolution shows how modules grow from simple beginnings to handle complex, real-world requirements while maintaining ease of use.
