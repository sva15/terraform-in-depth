# Chapter 4.3: Functions

## What This Chapter is About

This chapter explains **functions** in Terraform - named operations that transform data. Unlike imperative languages where functions "do things," Terraform functions focus on data transformation to support resource configuration.

## Key Concept: Functions = Data Transformers

Think of functions like:
- **Kitchen tools**: A blender transforms ingredients, but doesn't cook them
- **Math formulas**: Take inputs and return calculated results
- **Text filters**: Transform strings without changing the original

## Function Basics

### Calling Functions
```t
# Function syntax: function_name(arguments)

locals {
  # No arguments
  current_time = timestamp()
  
  # Single argument
  file_content = file("config.json")
  
  # Multiple arguments
  full_name = join(" ", ["John", "Doe"])
  
  # Variable arguments
  merged_list = concat([1, 2], [3, 4], [5, 6])
}
```

### Function Arguments as Expressions
```t
locals {
  # Arguments can be expressions
  is_dev = startswith(var.environment, "dev-")
  
  # Nested function calls
  env_name = upper(split(var.environment, "-")[1])
  
  # Complex expressions
  subnet_cidr = cidrsubnet(
    var.vpc_cidr,
    4,
    count.index * 2 + (var.is_public ? 0 : 1)
  )
}
```

## The Standard Library

### Function Categories

| Category | Purpose | Example Functions |
|----------|---------|-------------------|
| **Numeric** | Advanced math | `min()`, `max()`, `ceil()`, `floor()` |
| **String** | Text manipulation | `upper()`, `lower()`, `split()`, `join()` |
| **Collection** | List/map operations | `concat()`, `merge()`, `keys()`, `values()` |
| **Encoding** | Data format conversion | `jsonencode()`, `base64encode()` |
| **Filesystem** | File operations | `file()`, `templatefile()` |
| **Date/Time** | Time manipulation | `timestamp()`, `formatdate()` |
| **Cryptography** | Hashing | `sha256()`, `md5()` |
| **IP Network** | CIDR calculations | `cidrsubnet()`, `cidrhost()` |
| **Type Conversion** | Change data types | `tostring()`, `tonumber()`, `tolist()` |

## Common Functions by Category

### String Functions
```t
locals {
  # Case manipulation
  upper_name = upper("terraform")              # "TERRAFORM"
  lower_name = lower("TERRAFORM")              # "terraform"
  
  # String inspection
  starts_with_dev = startswith(var.env, "dev-")  # true/false
  ends_with_prod = endswith(var.env, "-prod")    # true/false
  contains_test = contains(var.name, "test")      # true/false
  
  # String manipulation
  parts = split("-", "dev-us-east-1")         # ["dev", "us", "east", "1"]
  joined = join("-", ["prod", "eu", "west"])  # "prod-eu-west"
  trimmed = trimspace("  hello  ")            # "hello"
  
  # Pattern matching
  replaced = replace("hello-world", "-", "_")  # "hello_world"
  
  # Formatting
  formatted = format("Hello %s!", var.name)    # "Hello John!"
}
```

### Collection Functions
```t
locals {
  # List operations
  combined = concat([1, 2], [3, 4])           # [1, 2, 3, 4]
  unique = distinct([1, 2, 2, 3])              # [1, 2, 3]
  sorted = sort(["c", "a", "b"])               # ["a", "b", "c"]
  reversed = reverse([1, 2, 3])                # [3, 2, 1]
  
  # Map operations
  merged = merge(                              # Combines maps
    {a = 1, b = 2},
    {b = 3, c = 4}
  )                                            # {a = 1, b = 3, c = 4}
  
  map_keys = keys({a = 1, b = 2})            # ["a", "b"]
  map_values = values({a = 1, b = 2})         # [1, 2]
  
  # Lookups
  value = lookup(var.settings, "key", "default")  # Get with default
  
  # Length
  list_size = length([1, 2, 3])               # 3
  map_size = length({a = 1, b = 2})            # 2
}
```

### Numeric Functions
```t
locals {
  # Rounding
  rounded_up = ceil(4.3)                       # 5
  rounded_down = floor(4.7)                    # 4
  
  # Min/Max
  smallest = min(5, 3, 8, 1)                   # 1
  largest = max(5, 3, 8, 1)                    # 8
  
  # Absolute value
  positive = abs(-42)                          # 42
  
  # Power
  squared = pow(4, 2)                          # 16
}
```

### Type Conversion Functions
```t
locals {
  # To string
  string_from_number = tostring(42)           # "42"
  string_from_bool = tostring(true)           # "true"
  
  # To number
  number_from_string = tonumber("42")         # 42
  
  # To list
  list_from_set = tolist(toset([1, 2, 2]))   # [1, 2]
  
  # To map
  map_from_object = tomap({
    name = "example"
    type = "test"
  })
  
  # Try conversions (return null on error)
  safe_number = try(tonumber(var.input), 0)   # 0 if conversion fails
}
```

## Pure vs Impure Functions

### Pure Functions (Predictable)
```t
# Always return same result for same input
locals {
  # Pure functions
  uppercase = upper("hello")                   # Always "HELLO"
  sum = 2 + 2                                 # Always 4
  joined = join("-", ["a", "b"])              # Always "a-b"
}

resource "aws_instance" "example" {
  instance_type = local.uppercase              # No drift
  
  tags = {
    Name = local.joined                        # Stable
  }
}
```

### Impure Functions (Unpredictable)
```t
# ❌ Problematic: Changes every time
resource "aws_instance" "bad" {
  tags = {
    id = uuid()                                # New UUID each plan!
    created_at = timestamp()                   # Current time changes!
  }
}
# Result: Terraform always shows changes

# ✅ Better: Use providers for stability
resource "random_uuid" "instance" {}

resource "time_static" "created" {}

resource "aws_instance" "good" {
  tags = {
    id = random_uuid.instance.result          # Stable after creation
    created_at = time_static.created.rfc3339  # Fixed timestamp
  }
}
```

## Practical Examples

### Building Dynamic Configurations
```t
# Network calculation
variable "vpc_cidr" {
  default = "10.0.0.0/16"
}

locals {
  # Calculate subnet CIDRs dynamically
  public_subnets = [
    for i in range(3) : cidrsubnet(var.vpc_cidr, 8, i)
  ]
  # Results: ["10.0.0.0/24", "10.0.1.0/24", "10.0.2.0/24"]
  
  private_subnets = [
    for i in range(3) : cidrsubnet(var.vpc_cidr, 8, i + 100)
  ]
  # Results: ["10.0.100.0/24", "10.0.101.0/24", "10.0.102.0/24"]
}
```

### Template Processing
```t
# templates/user_data.sh.tpl
#!/bin/bash
echo "Environment: ${environment}"
echo "Instance ID: ${instance_id}"

# Install packages
%{ for package in packages ~}
apt-get install -y ${package}
%{ endfor ~}

# main.tf
locals {
  user_data = templatefile("templates/user_data.sh.tpl", {
    environment = var.environment
    instance_id = aws_instance.example.id
    packages    = ["nginx", "git", "htop"]
  })
}
```

### Conditional Logic with Functions
```t
locals {
  # Environment detection
  is_production = contains(["prod", "production"], lower(var.environment))
  
  # Conditional values
  instance_type = local.is_production ? "m5.large" : "t3.micro"
  
  # Safe lookups
  region_config = try(
    var.region_settings[var.region],
    var.region_settings["default"]
  )
  
  # Dynamic naming
  resource_prefix = join("-", compact([
    var.project,
    var.environment != "default" ? var.environment : "",
    var.region
  ]))
}
```

### Data Transformation
```t
# JSON encoding/decoding
locals {
  # Encode to JSON
  config_json = jsonencode({
    version = "1.0"
    features = {
      monitoring = true
      backups = var.enable_backups
    }
  })
  
  # Decode from JSON
  parsed_config = jsondecode(file("config.json"))
  
  # Base64 encoding
  encoded_script = base64encode(local.user_data)
}

# Tag manipulation
locals {
  # Merge with defaults
  all_tags = merge(
    var.default_tags,
    var.resource_tags,
    {
      ManagedBy = "Terraform"
      UpdatedAt = formatdate("YYYY-MM-DD", timestamp())
    }
  )
  
  # Filter tags
  billing_tags = {
    for k, v in local.all_tags : k => v
    if startswith(k, "Billing") || k == "CostCenter"
  }
}
```

## Best Practices

### 1. Avoid Impure Functions in Resources
```t
# ❌ Bad - causes constant drift
resource "aws_s3_object" "bad" {
  key     = "backup-${timestamp()}.zip"
  content = file("backup.zip")
}

# ✅ Good - stable naming
resource "aws_s3_object" "good" {
  key     = "backup-${var.version}.zip"
  content = file("backup.zip")
}
```

### 2. Use Functions for Validation
```t
variable "email" {
  type = string
  
  validation {
    condition     = can(regex("^[^@]+@[^@]+\\.[^@]+$", var.email))
    error_message = "Must be a valid email address."
  }
}
```

### 3. Simplify Complex Logic
```t
# Instead of complex inline expressions
locals {
  # ❌ Hard to read
  name = "${var.prefix}-${var.env == "prod" ? "production" : var.env == "dev" ? "development" : var.env}-${replace(var.region, "-", "")}"
  
  # ✅ Clear steps
  environment_label = {
    prod = "production"
    dev  = "development"
  }
  
  clean_region = replace(var.region, "-", "")
  
  name = join("-", [
    var.prefix,
    lookup(local.environment_label, var.env, var.env),
    local.clean_region
  ])
}
```

## Key Takeaways

1. **Functions transform data** - They don't perform actions like in imperative languages
2. **Standard library is comprehensive** - Categories cover most transformation needs
3. **Pure vs impure matters** - Impure functions cause configuration drift
4. **Arguments can be expressions** - Nest functions and use complex logic
5. **Use providers for stability** - Random and time providers instead of functions
6. **Functions enable dynamic config** - Calculate values instead of hardcoding

Functions are essential tools for creating flexible, maintainable Terraform configurations that can adapt to different requirements without manual changes.
