# Chapter 4.5: Regular Expressions

## What This Chapter is About

This chapter explains **regular expressions (regex)** in Terraform - a pattern-matching language used to find, extract, and manipulate text. Terraform provides regex support through `regex()`, `regexall()`, and `replace()` functions.

## Key Concept: Regex = Pattern Matching

Think of regex like:
- **Search patterns**: Finding specific text in a document
- **Data extractors**: Pulling phone numbers from a contact list
- **Text validators**: Checking if an email address is properly formatted

## Important Note: Golang Syntax

Terraform uses **Golang regex syntax** because Terraform is written in Go. When testing patterns:
- Use tools like Regex101 set to "Golang" mode
- Backslashes need escaping: `\d` becomes `\\d` in Terraform strings

## The regex Function

### Basic Pattern Matching
```t
# Simple pattern - returns matching string
locals {
  # Extract first word
  first_word = regex("^\\w+", "Hello World")  # Returns: "Hello"
  
  # Extract numbers
  version = regex("\\d+\\.\\d+", "Version 2.5 released")  # Returns: "2.5"
  
  # Extract environment prefix
  env_type = regex("^[a-z]+", "dev-us-east-1")  # Returns: "dev"
}

# Error if no match
locals {
  # This will error - no uppercase at start
  will_error = regex("^[A-Z]", "lowercase")  # ERROR!
}
```

### Capture Groups (Unnamed)
```t
# Parentheses create capture groups - returns list
locals {
  # Single capture group
  name_parts = regex("^([a-z]+)-(.+)$", "prod-us-west-2")
  # Returns: ["prod", "us-west-2"]
  
  environment = local.name_parts[0]  # "prod"
  region      = local.name_parts[1]  # "us-west-2"
  
  # Multiple capture groups
  version_parts = regex("v(\\d+)\\.(\\d+)\\.(\\d+)", "v2.5.3")
  # Returns: ["2", "5", "3"]
  
  major = local.version_parts[0]  # "2"
  minor = local.version_parts[1]  # "5"
  patch = local.version_parts[2]  # "3"
}
```

### Named Capture Groups
```t
# (?P<name>pattern) creates named groups - returns map
locals {
  # Parse AWS ARN
  arn = "arn:aws:ec2:us-west-2:123456789012:instance/i-1234567890abcdef0"
  
  arn_parts = regex(
    "^arn:(?P<partition>\\w+):(?P<service>\\w+):(?P<region>[\\w-]*):(?P<account>\\d{12}):",
    local.arn
  )
  # Returns: {
  #   partition = "aws"
  #   service   = "ec2"
  #   region    = "us-west-2"
  #   account   = "123456789012"
  # }
  
  # Access by name
  aws_account = local.arn_parts["account"]   # "123456789012"
  aws_service = local.arn_parts["service"]   # "ec2"
  aws_region  = local.arn_parts["region"]    # "us-west-2"
}

# Parse structured strings
locals {
  connection_string = "postgresql://user:pass@localhost:5432/mydb"
  
  db_parts = regex(
    "(?P<protocol>\\w+)://(?P<user>\\w+):(?P<pass>\\w+)@(?P<host>[\\w\\.]+):(?P<port>\\d+)/(?P<db>\\w+)",
    local.connection_string
  )
  # Returns: {
  #   protocol = "postgresql"
  #   user     = "user"
  #   pass     = "pass"
  #   host     = "localhost"
  #   port     = "5432"
  #   db       = "mydb"
  # }
}
```

## The regexall Function

### Finding All Matches
```t
# Returns list of ALL matches (not just first)
locals {
  text = "IP: 192.168.1.1, Gateway: 10.0.0.1, DNS: 8.8.8.8"
  
  # Find all IP addresses
  all_ips = regexall("\\d+\\.\\d+\\.\\d+\\.\\d+", local.text)
  # Returns: ["192.168.1.1", "10.0.0.1", "8.8.8.8"]
  
  # Extract all numbers
  numbers = regexall("\\d+", "Room 101, Building 5, Floor 3")
  # Returns: ["101", "5", "3"]
  
  # No error on no matches - returns empty list
  no_matches = regexall("\\d+", "No numbers here")  # Returns: []
}
```

### With Capture Groups
```t
# Unnamed groups - returns list of lists
locals {
  text = "user1:admin, user2:viewer, user3:editor"
  
  user_roles = regexall("(\\w+):(\\w+)", local.text)
  # Returns: [
  #   ["user1", "admin"],
  #   ["user2", "viewer"],
  #   ["user3", "editor"]
  # ]
}

# Named groups - returns list of maps
locals {
  log_entries = "2024-01-15 10:30:45 ERROR: Connection failed\n2024-01-15 10:31:00 INFO: Retrying"
  
  parsed_logs = regexall(
    "(?P<date>\\d{4}-\\d{2}-\\d{2}) (?P<time>\\d{2}:\\d{2}:\\d{2}) (?P<level>\\w+): (?P<message>.*)",
    local.log_entries
  )
  # Returns: [
  #   {
  #     date    = "2024-01-15"
  #     time    = "10:30:45"
  #     level   = "ERROR"
  #     message = "Connection failed"
  #   },
  #   {
  #     date    = "2024-01-15"
  #     time    = "10:31:00"
  #     level   = "INFO"
  #     message = "Retrying"
  #   }
  # ]
}
```

### Validation Pattern
```t
# Common pattern: use regexall for validation
variable "aws_region" {
  type    = string
  default = "us-east-1"
  
  validation {
    condition = length(regexall("^[a-z]{2}-[a-z]+-\\d$", var.aws_region)) == 1
    error_message = "Must be a valid AWS region format (e.g., us-east-1)."
  }
}

variable "email" {
  type = string
  
  validation {
    condition = length(regexall("^[^@]+@[^@]+\\.[^@]+$", var.email)) == 1
    error_message = "Must be a valid email address."
  }
}
```

## The replace Function

### Simple String Replacement
```t
locals {
  # Direct string replacement
  greeting = replace("Hello World!", "Hello", "Goodbye")
  # Returns: "Goodbye World!"
  
  # Replace all occurrences
  cleaned = replace("foo-bar-baz", "-", "_")
  # Returns: "foo_bar_baz"
}
```

### Regex-Based Replacement
```t
# Use /pattern/ to indicate regex (with slashes)
locals {
  # Replace first word
  modified = replace("Hello World", "/^\\w+/", "Goodbye")
  # Returns: "Goodbye World"
  
  # Remove all numbers
  no_numbers = replace("abc123def456", "/\\d+/", "")
  # Returns: "abcdef"
  
  # Clean up spacing
  normalized = replace("too    many     spaces", "/\\s+/", " ")
  # Returns: "too many spaces"
}
```

### Using Capture Groups in Replacement
```t
# Unnamed groups - use $1, $2, etc.
locals {
  # Swap order
  swapped = replace("LastName, FirstName", "/(\\w+), (\\w+)/", "$2 $1")
  # Returns: "FirstName LastName"
  
  # Add formatting
  formatted_date = replace("20240115", "/(\\d{4})(\\d{2})(\\d{2})/", "$1-$2-$3")
  # Returns: "2024-01-15"
}

# Named groups - use $name
locals {
  # Add CIDR notation
  with_cidr = replace(
    "ip_address: 192.168.0.1;",
    "/(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+)/",
    "$ip/32"
  )
  # Returns: "ip_address: 192.168.0.1/32;"
  
  # Format phone numbers
  phone = replace(
    "1234567890",
    "/(?P<area>\\d{3})(?P<prefix>\\d{3})(?P<number>\\d{4})/",
    "($area) $prefix-$number"
  )
  # Returns: "(123) 456-7890"
}
```

## Practical Examples

### Resource Naming Validation
```t
variable "resource_name" {
  type = string
  
  validation {
    condition = can(regex("^[a-z][a-z0-9-]*[a-z0-9]$", var.resource_name))
    error_message = "Name must start with letter, end with letter/number, and contain only lowercase letters, numbers, and hyphens."
  }
  
  validation {
    condition = length(var.resource_name) <= 63
    error_message = "Name must be 63 characters or less."
  }
}
```

### Extract Information from Tags
```t
# Parse structured tag values
locals {
  cost_center_tag = "DEPT:Engineering:12345"
  
  tag_parts = regex(
    "^(?P<type>\\w+):(?P<department>\\w+):(?P<code>\\d+)$",
    local.cost_center_tag
  )
  
  department_name = local.tag_parts["department"]  # "Engineering"
  department_code = local.tag_parts["code"]        # "12345"
}
```

### Clean and Normalize Input
```t
variable "raw_input" {
  type    = string
  default = "  TerraForm-Example_123  "
}

locals {
  # Step 1: Trim whitespace
  trimmed = trimspace(var.raw_input)
  
  # Step 2: Lowercase
  lowercased = lower(local.trimmed)
  
  # Step 3: Replace underscores with hyphens
  normalized = replace(local.lowercased, "_", "-")
  
  # Step 4: Remove numbers
  no_numbers = replace(local.normalized, "/\\d+/", "")
  
  # Result: "terraform-example-"
}
```

### Parse Log Files
```t
variable "log_content" {
  default = <<-EOT
    [2024-01-15 10:30:45] ERROR: Database connection failed
    [2024-01-15 10:30:46] WARN: Retrying connection
    [2024-01-15 10:30:47] INFO: Connection established
  EOT
}

locals {
  # Extract all ERROR messages
  error_logs = regexall(
    "\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] ERROR: (.+)",
    var.log_content
  )
  # Returns: [["2024-01-15 10:30:45", "Database connection failed"]]
  
  # Count log levels
  error_count = length(regexall("ERROR:", var.log_content))
  warn_count  = length(regexall("WARN:", var.log_content))
  info_count  = length(regexall("INFO:", var.log_content))
}
```

### Dynamic Resource Tagging
```t
# Extract metadata from resource names
resource "aws_instance" "web" {
  for_each = toset(["web-prod-01", "web-dev-02", "api-prod-01"])
  
  instance_type = local.instance_types[each.key]
  
  tags = merge(
    {
      Name = each.key
    },
    can(regex("^(?P<service>\\w+)-(?P<env>\\w+)-(?P<num>\\d+)$", each.key)) ? {
      Service     = regex("^(\\w+)-", each.key)[0]
      Environment = regex("-(\\w+)-", each.key)[0]
      Index       = regex("-(\\d+)$", each.key)[0]
    } : {}
  )
}

locals {
  instance_types = {
    for name in ["web-prod-01", "web-dev-02", "api-prod-01"] :
    name => regex("-(?P<env>\\w+)-", name)["env"] == "prod" ? "t3.medium" : "t3.micro"
  }
}
```

## Best Practices

### 1. Test Your Patterns
```t
# Use can() to safely test patterns
locals {
  is_valid_ip = can(regex("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$", var.ip_address))
}
```

### 2. Use regexall for Validation
```t
# Prefer regexall + length for validation (no errors)
variable "identifier" {
  validation {
    condition     = length(regexall("^[a-z0-9]+$", var.identifier)) == 1
    error_message = "Identifier must contain only lowercase letters and numbers."
  }
}
```

### 3. Comment Complex Patterns
```t
locals {
  # Pattern explanation:
  # ^ - start of string
  # (?P<year>\d{4}) - 4 digit year
  # - - literal dash
  # (?P<month>\d{2}) - 2 digit month
  # - - literal dash
  # (?P<day>\d{2}) - 2 digit day
  # $ - end of string
  date_parts = regex(
    "^(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})$",
    var.date_string
  )
}
```

## Common Patterns Reference

```t
locals {
  # Common regex patterns
  patterns = {
    # AWS resource formats
    aws_region     = "^[a-z]{2}-[a-z]+-\\d$"
    aws_account_id = "^\\d{12}$"
    subnet_id      = "^subnet-[a-f0-9]+$"
    
    # Network patterns
    ipv4_address = "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$"
    cidr_block   = "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\\d{1,2}$"
    
    # Common formats
    email        = "^[^@]+@[^@]+\\.[^@]+$"
    alphanumeric = "^[a-zA-Z0-9]+$"
    kubernetes_name = "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
  }
}
```

## Key Takeaways

1. **Terraform uses Golang regex syntax** - Test with appropriate tools
2. **regex() for single match** - Errors if no match found
3. **regexall() for all matches** - Returns empty list if no matches
4. **replace() for substitution** - Can use capture groups in replacement
5. **Named groups return maps** - Easier to work with than numbered groups
6. **Use for validation** - Common pattern with regexall() + length()
7. **Escape backslashes** - `\d` becomes `\\d` in Terraform strings

Regular expressions are powerful tools for string manipulation and validation in Terraform, enabling sophisticated text processing and input validation.
