# Chapter 4.9: For

## What This Chapter is About

This chapter explains the **for expression** - Terraform's way to transform collections by iterating over lists, maps, sets, and objects. It allows you to create new collections with modified values, filter items, and restructure data.

## Key Concept: Collection Transformation

Think of the for expression like:
- **Assembly line transformation**: Taking raw materials and producing finished products
- **Data pipeline**: Processing each item in a stream
- **Map/filter operations**: Transform and select data programmatically

## Basic For Expression Syntax

### List Transformation
```t
# Basic syntax: [for item in collection : transformation]

locals {
  # Simple transformation
  names = ["alice", "bob", "charlie"]
  upper_names = [for name in local.names : upper(name)]
  # Result: ["ALICE", "BOB", "CHARLIE"]
  
  # Adding prefixes
  prefixed = [for name in local.names : "user-${name}"]
  # Result: ["user-alice", "user-bob", "user-charlie"]
  
  # Numeric operations
  numbers = [1, 2, 3, 4, 5]
  doubled = [for n in local.numbers : n * 2]
  # Result: [2, 4, 6, 8, 10]
}
```

### Object/Map Transformation
```t
# With objects, you get both key and value
locals {
  instance_types = {
    web = "t3.micro"
    app = "t3.small"
    db  = "t3.medium"
  }
  
  # Using both key and value
  instance_descriptions = [
    for name, type in local.instance_types : 
    "${name} server uses ${type}"
  ]
  # Result: ["web server uses t3.micro", "app server uses t3.small", "db server uses t3.medium"]
  
  # Using just values
  all_types = [for k, v in local.instance_types : v]
  # Result: ["t3.micro", "t3.small", "t3.medium"]
}
```

## Creating Different Output Types

### Returning Lists (Square Brackets)
```t
# Input: any collection → Output: list

locals {
  # From list to list
  ports = [80, 443, 8080]
  port_strings = [for p in local.ports : tostring(p)]
  # Result: ["80", "443", "8080"]
  
  # From map to list
  services = {
    web  = { port = 80,  protocol = "http" }
    api  = { port = 443, protocol = "https" }
  }
  
  service_urls = [
    for name, config in local.services :
    "${config.protocol}://${name}.example.com:${config.port}"
  ]
  # Result: ["http://web.example.com:80", "https://api.example.com:443"]
}
```

### Returning Objects (Curly Brackets + =>)
```t
# Input: any collection → Output: object/map
# Syntax: {for item in collection : key => value}

locals {
  # List to object
  environments = ["dev", "staging", "prod"]
  env_numbers = {
    for idx, env in local.environments : 
    env => idx + 1
  }
  # Result: { dev = 1, staging = 2, prod = 3 }
  
  # Transform object structure
  instances = {
    web-1 = { type = "t3.micro", az = "us-east-1a" }
    web-2 = { type = "t3.micro", az = "us-east-1b" }
  }
  
  instances_by_az = {
    for name, config in local.instances :
    config.az => name
  }
  # Result: { "us-east-1a" = "web-1", "us-east-1b" = "web-2" }
  
  # Create lookup table
  users = ["alice", "bob", "charlie"]
  user_emails = {
    for user in local.users :
    user => "${user}@example.com"
  }
  # Result: { alice = "alice@example.com", bob = "bob@example.com", charlie = "charlie@example.com" }
}
```

## Filtering with if

### Basic Filtering
```t
# Syntax: [for item in collection : result if condition]

locals {
  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  # Filter even numbers
  evens = [for n in local.numbers : n if n % 2 == 0]
  # Result: [2, 4, 6, 8, 10]
  
  # Filter with complex condition
  large_evens = [for n in local.numbers : n if n % 2 == 0 && n > 5]
  # Result: [6, 8, 10]
  
  # Filter nulls
  mixed_values = ["a", null, "b", null, "c"]
  non_nulls = [for v in local.mixed_values : v if v != null]
  # Result: ["a", "b", "c"]
}
```

### Filtering Objects
```t
locals {
  instances = {
    web-1   = { type = "t3.micro",  public = true }
    web-2   = { type = "t3.small",  public = true }
    db-1    = { type = "t3.medium", public = false }
    cache-1 = { type = "t3.micro",  public = false }
  }
  
  # Filter to public instances only
  public_instances = {
    for name, config in local.instances :
    name => config if config.public
  }
  # Result: { web-1 = {...}, web-2 = {...} }
  
  # Get names of large instances
  large_instance_names = [
    for name, config in local.instances :
    name if config.type != "t3.micro"
  ]
  # Result: ["web-2", "db-1"]
}
```

## Grouping Mode (Ellipsis ...)

### Creating Lists of Values
```t
# Syntax: {for item in collection : key => value...}
# The ... creates a list of values for each key

locals {
  servers = [
    { name = "web-1", subnet = "subnet-1a" },
    { name = "web-2", subnet = "subnet-1b" },
    { name = "app-1", subnet = "subnet-1a" },
    { name = "app-2", subnet = "subnet-1b" },
    { name = "db-1",  subnet = "subnet-1a" }
  ]
  
  # Group servers by subnet
  servers_by_subnet = {
    for server in local.servers :
    server.subnet => server.name...
  }
  # Result: {
  #   "subnet-1a" = ["web-1", "app-1", "db-1"],
  #   "subnet-1b" = ["web-2", "app-2"]
  # }
  
  # Group by type
  instances_by_type = {
    for name, config in local.instances :
    config.type => name...
  }
  # Result: {
  #   "t3.micro"  = ["web-1", "cache-1"],
  #   "t3.small"  = ["web-2"],
  #   "t3.medium" = ["db-1"]
  # }
}
```

### Practical Grouping Examples
```t
# Group resources by tag
variable "resources" {
  type = list(object({
    id   = string
    tags = map(string)
  }))
}

locals {
  # Group by environment tag
  resources_by_env = {
    for r in var.resources :
    lookup(r.tags, "Environment", "untagged") => r.id...
  }
  
  # Group security group rules by port
  rules = [
    { port = 80,  cidr = "10.0.0.0/8" },
    { port = 443, cidr = "10.0.0.0/8" },
    { port = 80,  cidr = "172.16.0.0/12" },
    { port = 22,  cidr = "192.168.1.0/24" }
  ]
  
  cidrs_by_port = {
    for rule in local.rules :
    tostring(rule.port) => rule.cidr...
  }
  # Result: {
  #   "80"  = ["10.0.0.0/8", "172.16.0.0/12"],
  #   "443" = ["10.0.0.0/8"],
  #   "22"  = ["192.168.1.0/24"]
  # }
}
```

## Splat Expressions

### Basic Splat Usage
```t
# Splat is shorthand for common for expressions
# collection[*].attribute is same as [for item in collection : item.attribute]

variable "instances" {
  type = list(object({
    id   = string
    type = string
    ip   = string
  }))
  
  default = [
    { id = "i-123", type = "t3.micro", ip = "10.0.1.10" },
    { id = "i-456", type = "t3.small", ip = "10.0.1.11" },
    { id = "i-789", type = "t3.micro", ip = "10.0.1.12" }
  ]
}

locals {
  # These are equivalent
  ids_with_for = [for i in var.instances : i.id]
  ids_with_splat = var.instances[*].id
  # Both produce: ["i-123", "i-456", "i-789"]
  
  # Nested attributes
  all_ips = var.instances[*].ip
  # Result: ["10.0.1.10", "10.0.1.11", "10.0.1.12"]
}
```

### Splat with Resources
```t
# Common pattern with count
resource "aws_instance" "web" {
  count = 3
  # ... configuration
}

# Get all instance IDs
output "instance_ids" {
  value = aws_instance.web[*].id
}

# With modules
module "vpc" {
  source = "./modules/vpc"
  count  = 2
  # ...
}

# Get all VPC IDs
output "vpc_ids" {
  value = module.vpc[*].vpc_id
}
```

### Single Value to List
```t
# Convert single value to one-item list using splat

variable "security_group_id" {
  type    = string
  default = "sg-12345"
}

resource "aws_instance" "example" {
  # Some arguments expect lists
  vpc_security_group_ids = var.security_group_id[*]  # ["sg-12345"]
}

# Conditional single item list
locals {
  # Empty list or one-item list
  optional_sg = var.create_sg ? aws_security_group.new[*].id : []
}
```

## Complex Examples

### Data Transformation Pipeline
```t
variable "raw_data" {
  default = [
    { name = "web-prod-1",  status = "running", cpu = 45 },
    { name = "web-dev-2",   status = "stopped", cpu = 0 },
    { name = "app-prod-1",  status = "running", cpu = 78 },
    { name = "db-staging-1", status = "running", cpu = 23 }
  ]
}

locals {
  # Extract environment from name
  data_with_env = [
    for item in var.raw_data : merge(item, {
      env = split("-", item.name)[1]
    })
  ]
  
  # Filter running instances
  running_instances = [
    for item in local.data_with_env :
    item if item.status == "running"
  ]
  
  # Group by environment
  instances_by_env = {
    for item in local.running_instances :
    item.env => item.name...
  }
  # Result: {
  #   "prod"    = ["web-prod-1", "app-prod-1"],
  #   "staging" = ["db-staging-1"]
  # }
  
  # Calculate average CPU by environment
  avg_cpu_by_env = {
    for env, names in local.instances_by_env :
    env => sum([
      for item in local.running_instances :
      item.cpu if item.env == env
    ]) / length(names)
  }
}
```

### Dynamic Tag Generation
```t
variable "base_tags" {
  type = map(string)
  default = {
    ManagedBy = "Terraform"
    Project   = "MyApp"
  }
}

variable "environments" {
  type = map(object({
    vpc_cidr = string
    public   = bool
  }))
}

locals {
  # Generate complete tag sets for each environment
  environment_tags = {
    for env, config in var.environments :
    env => merge(
      var.base_tags,
      {
        Environment = env
        NetworkType = config.public ? "public" : "private"
        CIDR        = config.vpc_cidr
      }
    )
  }
  
  # Flatten tags for specific use case
  all_tag_keys = distinct(flatten([
    for env, tags in local.environment_tags :
    keys(tags)
  ]))
}
```

## Best Practices

### 1. Use Meaningful Variable Names
```t
# ❌ Bad - unclear variable names
locals {
  result = [for x in var.y : x.z if x.w]
}

# ✅ Good - descriptive names
locals {
  active_instances = [
    for instance in var.all_instances :
    instance.id if instance.status == "active"
  ]
}
```

### 2. Break Complex Transformations
```t
# ❌ Bad - too complex in one expression
locals {
  result = {
    for k, v in {
      for item in var.items :
      item.category => item...
    } : k => [
      for i in v : i.name if i.enabled
    ] if length(v) > 0
  }
}

# ✅ Good - step by step
locals {
  # Group by category
  items_by_category = {
    for item in var.items :
    item.category => item...
  }
  
  # Filter enabled items per category
  enabled_by_category = {
    for category, items in local.items_by_category :
    category => [
      for item in items : item.name if item.enabled
    ] if length(items) > 0
  }
}
```

### 3. Document Complex Logic
```t
locals {
  # Create a map of availability zones to subnet IDs,
  # but only for subnets tagged as "public"
  public_subnets_by_az = {
    for subnet in data.aws_subnet.all :
    subnet.availability_zone => subnet.id...
    if lookup(subnet.tags, "Type", "") == "public"
  }
}
```

## Key Takeaways

1. **Square brackets for lists** - `[for ... : ...]`
2. **Curly brackets for objects** - `{for ... : key => value}`
3. **Access key and value in objects** - `for k, v in object`
4. **Filter with if** - `for x in list : x if condition`
5. **Group with ellipsis** - `key => value...` creates lists
6. **Splat for simple cases** - `list[*].attribute` is cleaner
7. **Transform data structures** - Convert between lists, maps, and objects
8. **Chain operations** - Build complex transformations step by step

The for expression is one of Terraform's most powerful features for data manipulation, enabling you to reshape and filter data to match your infrastructure needs.
