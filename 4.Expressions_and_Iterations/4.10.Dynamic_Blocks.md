# Chapter 4.10: Dynamic Blocks

## What This Chapter is About

This chapter explains **dynamic blocks** - Terraform's way to programmatically generate configuration subblocks. This allows you to create variable numbers of nested blocks based on input data, making your configurations more flexible and reusable.

## Key Concept: Dynamic Block Generation

Think of dynamic blocks like:
- **Template stamps**: Creating multiple impressions from one template
- **Assembly instructions**: Repeating steps for each component
- **Form duplication**: Generating multiple sections based on data

## The Challenge: Static vs Dynamic Blocks

### The Problem: Fixed Block Structure
```t
# Without dynamic blocks - hardcoded and inflexible
resource "aws_security_group" "static" {
  name = "my-sg"
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  # What if we need more rules? Or different rules per environment?
  # We'd have to modify the code each time!
}
```

### The Solution: Dynamic Blocks
```t
# With dynamic blocks - flexible and data-driven
variable "ingress_rules" {
  type = list(object({
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
  }))
}

resource "aws_security_group" "dynamic" {
  name = "my-sg"
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    
    content {
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
}
```

## Dynamic Block Syntax

### Basic Structure
```t
dynamic "BLOCK_TYPE" {          # The type of block to create
  for_each = COLLECTION         # Data to iterate over
  iterator = ITERATOR_NAME      # Optional: custom iterator name
  
  content {                     # The block configuration
    # Use BLOCK_TYPE.value (or ITERATOR_NAME.value)
  }
}
```

### Understanding the Iterator
```t
# The iterator name defaults to the block type
resource "aws_instance" "example" {
  # Default iterator name is "ebs_block_device"
  dynamic "ebs_block_device" {
    for_each = var.additional_volumes
    
    content {
      device_name = ebs_block_device.value.device_name
      volume_size = ebs_block_device.value.size
    }
  }
  
  # Custom iterator name for clarity
  dynamic "ebs_block_device" {
    for_each = var.additional_volumes
    iterator = volume
    
    content {
      device_name = volume.value.device_name
      volume_size = volume.value.size
    }
  }
}
```

## Real-World Examples

### Security Group Rules
```t
variable "security_rules" {
  type = list(object({
    type        = string  # "ingress" or "egress"
    description = string
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
  }))
  
  default = [
    {
      type        = "ingress"
      description = "HTTP from anywhere"
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      type        = "ingress"
      description = "HTTPS from anywhere"
      from_port   = 443
      to_port     = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    },
    {
      type        = "ingress"
      description = "SSH from VPN"
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = ["10.0.0.0/8"]
    }
  ]
}

resource "aws_security_group" "app" {
  name        = "${var.app_name}-sg"
  description = "Security group for ${var.app_name}"
  vpc_id      = var.vpc_id
  
  # Dynamic ingress rules
  dynamic "ingress" {
    for_each = [for rule in var.security_rules : rule if rule.type == "ingress"]
    
    content {
      description = ingress.value.description
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
  
  # Static egress rule (always present)
  egress {
    description = "Allow all outbound"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

### Conditional Block Creation
```t
variable "enable_logging" {
  type    = bool
  default = false
}

variable "log_retention_days" {
  type    = number
  default = 7
}

resource "aws_s3_bucket" "data" {
  bucket = var.bucket_name
  
  # Conditionally add logging configuration
  dynamic "logging" {
    for_each = var.enable_logging ? [1] : []
    
    content {
      target_bucket = aws_s3_bucket.logs[0].id
      target_prefix = "access-logs/"
    }
  }
  
  # Conditionally add lifecycle rules
  dynamic "lifecycle_rule" {
    for_each = var.enable_logging ? [1] : []
    
    content {
      id      = "expire-logs"
      enabled = true
      
      expiration {
        days = var.log_retention_days
      }
    }
  }
}
```

### Multiple Dynamic Blocks
```t
variable "cors_rules" {
  type = list(object({
    allowed_origins = list(string)
    allowed_methods = list(string)
    allowed_headers = list(string)
    expose_headers  = list(string)
    max_age_seconds = number
  }))
  default = []
}

resource "aws_s3_bucket" "website" {
  bucket = var.bucket_name
  
  # Multiple CORS rules
  dynamic "cors_rule" {
    for_each = var.cors_rules
    
    content {
      allowed_origins = cors_rule.value.allowed_origins
      allowed_methods = cors_rule.value.allowed_methods
      allowed_headers = cors_rule.value.allowed_headers
      expose_headers  = cors_rule.value.expose_headers
      max_age_seconds = cors_rule.value.max_age_seconds
    }
  }
}
```

### Nested Dynamic Blocks
```t
variable "load_balancer_rules" {
  type = list(object({
    priority = number
    conditions = list(object({
      field  = string
      values = list(string)
    }))
    action_type        = string
    target_group_arn   = string
  }))
}

resource "aws_lb_listener" "app" {
  load_balancer_arn = aws_lb.main.arn
  port              = "443"
  protocol          = "HTTPS"
  
  # Default action
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.default.arn
  }
  
  # Dynamic rules with nested conditions
  dynamic "rule" {
    for_each = var.load_balancer_rules
    
    content {
      priority = rule.value.priority
      
      # Nested dynamic block for conditions
      dynamic "condition" {
        for_each = rule.value.conditions
        
        content {
          field  = condition.value.field
          values = condition.value.values
        }
      }
      
      action {
        type             = rule.value.action_type
        target_group_arn = rule.value.target_group_arn
      }
    }
  }
}
```

## Complex Patterns

### API Gateway Integration
```t
variable "api_endpoints" {
  type = map(object({
    method          = string
    integration_type = string
    uri             = string
    request_templates = map(string)
  }))
}

resource "aws_api_gateway_rest_api" "api" {
  name = var.api_name
}

resource "aws_api_gateway_resource" "endpoints" {
  for_each = var.api_endpoints
  
  rest_api_id = aws_api_gateway_rest_api.api.id
  parent_id   = aws_api_gateway_rest_api.api.root_resource_id
  path_part   = each.key
}

resource "aws_api_gateway_method" "methods" {
  for_each = var.api_endpoints
  
  rest_api_id   = aws_api_gateway_rest_api.api.id
  resource_id   = aws_api_gateway_resource.endpoints[each.key].id
  http_method   = each.value.method
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "integrations" {
  for_each = var.api_endpoints
  
  rest_api_id = aws_api_gateway_rest_api.api.id
  resource_id = aws_api_gateway_resource.endpoints[each.key].id
  http_method = aws_api_gateway_method.methods[each.key].http_method
  
  integration_http_method = "POST"
  type                   = each.value.integration_type
  uri                    = each.value.uri
  
  # Dynamic request templates
  dynamic "request_templates" {
    for_each = each.value.request_templates
    
    content {
      content_type = request_templates.key
      template     = request_templates.value
    }
  }
}
```

### ECS Task Definition
```t
variable "container_definitions" {
  type = list(object({
    name         = string
    image        = string
    cpu          = number
    memory       = number
    essential    = bool
    port_mappings = list(object({
      container_port = number
      host_port      = number
      protocol       = string
    }))
    environment = list(object({
      name  = string
      value = string
    }))
  }))
}

resource "aws_ecs_task_definition" "app" {
  family                   = var.app_name
  network_mode            = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                     = var.task_cpu
  memory                  = var.task_memory
  
  container_definitions = jsonencode([
    for container in var.container_definitions : {
      name      = container.name
      image     = container.image
      cpu       = container.cpu
      memory    = container.memory
      essential = container.essential
      
      portMappings = [
        for pm in container.port_mappings : {
          containerPort = pm.container_port
          hostPort      = pm.host_port
          protocol      = pm.protocol
        }
      ]
      
      environment = [
        for env in container.environment : {
          name  = env.name
          value = env.value
        }
      ]
    }
  ])
}
```

## Best Practices

### 1. Keep It Simple
```t
# ❌ Bad - overly complex nesting
dynamic "block1" {
  for_each = var.data
  content {
    dynamic "block2" {
      for_each = block1.value.items
      content {
        dynamic "block3" {
          for_each = block2.value.subitems
          content {
            # Too deep!
          }
        }
      }
    }
  }
}

# ✅ Good - flatten when possible
locals {
  flattened_items = flatten([
    for item in var.data : [
      for subitem in item.subitems : {
        parent = item.name
        child  = subitem
      }
    ]
  ])
}

dynamic "block" {
  for_each = local.flattened_items
  content {
    parent_name = block.value.parent
    child_value = block.value.child
  }
}
```

### 2. Use Clear Iterator Names
```t
# ❌ Confusing default names
dynamic "origin" {
  for_each = var.origins
  content {
    domain_name = origin.value.domain  # "origin" is ambiguous
  }
}

# ✅ Clear custom iterator
dynamic "origin" {
  for_each = var.origins
  iterator = cdn_origin
  
  content {
    domain_name = cdn_origin.value.domain  # Much clearer
  }
}
```

### 3. Mix Static and Dynamic
```t
resource "aws_security_group" "hybrid" {
  name = "${var.name}-sg"
  
  # Always allow egress
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  # Always allow HTTPS
  ingress {
    description = "HTTPS from anywhere"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  # Dynamic custom rules
  dynamic "ingress" {
    for_each = var.custom_ingress_rules
    
    content {
      description = ingress.value.description
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
}
```

### 4. Document Complex Logic
```t
# Generate S3 bucket policies dynamically based on access patterns
# Each statement in var.policy_statements becomes a statement block
# with automatic sid generation and principal expansion
dynamic "statement" {
  for_each = var.policy_statements
  iterator = stmt
  
  content {
    sid    = "Stmt${stmt.key}"
    effect = stmt.value.effect
    
    principals {
      type        = stmt.value.principal_type
      identifiers = stmt.value.principal_ids
    }
    
    actions   = stmt.value.actions
    resources = stmt.value.resources
  }
}
```

## Key Takeaways

1. **Dynamic blocks create variable subblocks** - Generate 0 to N blocks based on data
2. **Syntax is unique** - Uses block name as iterator by default
3. **for_each drives iteration** - Works with lists, sets, and maps
4. **content defines the block** - All configuration goes inside content
5. **Iterator name = block type** - Unless you specify custom iterator
6. **Conditional blocks use empty list trick** - `for_each = condition ? [1] : []`
7. **Can mix static and dynamic** - Use both in same resource
8. **Avoid deep nesting** - Flatten data structures when possible

Dynamic blocks are powerful but can be confusing. They're essential for creating flexible, reusable modules that can adapt to different requirements without code changes.
