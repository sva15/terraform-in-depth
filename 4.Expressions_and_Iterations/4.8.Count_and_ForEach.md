# Chapter 4.8: count and for_each

## What This Chapter is About

This chapter explains **count and for_each meta-parameters** - Terraform's methods for creating multiple resources from a single configuration block. These enable iteration in Terraform's declarative style.

## Key Concept: Resource Multiplication

Think of count and for_each like:
- **Cookie cutters**: One pattern creating multiple cookies
- **Assembly line**: Same blueprint producing multiple products
- **Photocopier**: One original creating multiple copies with variations

## The count Meta-Parameter

### Basic Usage
```t
# Create exact number of resources
resource "aws_instance" "web" {
  count = 3  # Creates 3 instances
  
  instance_type = "t3.micro"
  ami           = data.aws_ami.ubuntu.id
  
  tags = {
    Name = "web-${count.index}"  # web-0, web-1, web-2
  }
}

# Using variable for count
variable "instance_count" {
  type    = number
  default = 2
}

resource "aws_instance" "app" {
  count = var.instance_count
  
  instance_type = "t3.small"
  
  tags = {
    Name  = "app-${count.index + 1}"  # app-1, app-2 (not zero-indexed)
    Index = count.index                # 0, 1
  }
}
```

### Conditional Creation Pattern
```t
# Enable/disable resources with boolean
variable "enable_monitoring" {
  type    = bool
  default = false
}

resource "aws_cloudwatch_dashboard" "main" {
  count = var.enable_monitoring ? 1 : 0
  
  dashboard_name = "${var.app_name}-dashboard"
  # ... configuration
}

# Multiple optional resources
variable "create_vpc" {
  type    = bool
  default = true
}

resource "aws_vpc" "main" {
  count = var.create_vpc ? 1 : 0
  
  cidr_block = var.vpc_cidr
}

resource "aws_internet_gateway" "main" {
  count = var.create_vpc ? 1 : 0
  
  vpc_id = aws_vpc.main[0].id  # Reference the first (only) VPC
}
```

### Distributing Resources
```t
variable "subnet_ids" {
  type = list(string)
}

variable "instance_count" {
  type = number
}

resource "aws_instance" "distributed" {
  count = var.instance_count
  
  # Distribute instances across subnets using modulo
  subnet_id = var.subnet_ids[count.index % length(var.subnet_ids)]
  
  instance_type = "t3.micro"
  
  tags = {
    Name       = "distributed-${count.index}"
    SubnetIndex = count.index % length(var.subnet_ids)
  }
}
```

## The for_each Meta-Parameter

### With Maps/Objects
```t
# Define instances with different configurations
locals {
  instances = {
    "web-server" = {
      type      = "t3.micro"
      subnet_id = "subnet-12345"
      public_ip = true
    }
    "app-server" = {
      type      = "t3.small"
      subnet_id = "subnet-67890"
      public_ip = false
    }
    "db-server" = {
      type      = "t3.medium"
      subnet_id = "subnet-67890"
      public_ip = false
    }
  }
}

resource "aws_instance" "servers" {
  for_each = local.instances
  
  instance_type               = each.value.type
  subnet_id                   = each.value.subnet_id
  associate_public_ip_address = each.value.public_ip
  
  tags = {
    Name = each.key  # "web-server", "app-server", "db-server"
    Type = each.value.type
  }
}
```

### With Sets
```t
# Create VPC endpoints for multiple services
variable "endpoint_services" {
  type    = set(string)
  default = ["s3", "dynamodb", "ec2"]
}

data "aws_region" "current" {}

resource "aws_vpc_endpoint" "services" {
  for_each = var.endpoint_services
  
  vpc_id       = aws_vpc.main.id
  service_name = "com.amazonaws.${data.aws_region.current.name}.${each.value}"
  
  tags = {
    Name    = "${var.vpc_name}-endpoint-${each.value}"
    Service = each.value  # each.key and each.value are same for sets
  }
}
```

### Converting Lists to Sets
```t
variable "availability_zones" {
  type = list(string)
  default = ["us-east-1a", "us-east-1b", "us-east-1c"]
}

resource "aws_subnet" "public" {
  # Must convert list to set for for_each
  for_each = toset(var.availability_zones)
  
  vpc_id            = aws_vpc.main.id
  availability_zone = each.value
  
  # Calculate CIDR based on AZ index
  cidr_block = cidrsubnet(
    aws_vpc.main.cidr_block,
    8,
    index(var.availability_zones, each.value)
  )
  
  tags = {
    Name = "${var.vpc_name}-public-${each.value}"
    Type = "public"
  }
}
```

## Accessing Resources Created with count/for_each

### Accessing count Resources
```t
resource "aws_instance" "web" {
  count = 3
  # ... configuration
}

# Access individual instances
output "first_instance_id" {
  value = aws_instance.web[0].id
}

# Access all instances
output "all_instance_ids" {
  value = aws_instance.web[*].id  # List of all IDs
}

# Reference in other resources
resource "aws_lb_target_group_attachment" "web" {
  count = length(aws_instance.web)
  
  target_group_arn = aws_lb_target_group.web.arn
  target_id        = aws_instance.web[count.index].id
}
```

### Accessing for_each Resources
```t
resource "aws_s3_bucket" "data" {
  for_each = {
    logs   = "my-logs-bucket"
    assets = "my-assets-bucket"
  }
  
  bucket = each.value
}

# Access specific bucket
output "logs_bucket_arn" {
  value = aws_s3_bucket.data["logs"].arn
}

# Access all buckets
output "all_bucket_arns" {
  value = {
    for k, v in aws_s3_bucket.data : k => v.arn
  }
}

# Use values() for list of attributes
output "bucket_ids" {
  value = values(aws_s3_bucket.data)[*].id
}
```

## Complex Examples

### Dynamic Security Group Rules
```t
variable "ingress_rules" {
  type = map(object({
    from_port   = number
    to_port     = number
    protocol    = string
    cidr_blocks = list(string)
    description = string
  }))
  
  default = {
    http = {
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
      description = "HTTP access"
    }
    https = {
      from_port   = 443
      to_port     = 443
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
      description = "HTTPS access"
    }
    ssh = {
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = ["10.0.0.0/8"]
      description = "SSH access from internal"
    }
  }
}

resource "aws_security_group_rule" "ingress" {
  for_each = var.ingress_rules
  
  type              = "ingress"
  from_port         = each.value.from_port
  to_port           = each.value.to_port
  protocol          = each.value.protocol
  cidr_blocks       = each.value.cidr_blocks
  description       = each.value.description
  security_group_id = aws_security_group.main.id
}
```

### Multi-Region Deployment
```t
variable "regions" {
  type = map(object({
    vpc_cidr     = string
    azs          = list(string)
    enable_natgw = bool
  }))
  
  default = {
    "us-east-1" = {
      vpc_cidr     = "10.0.0.0/16"
      azs          = ["us-east-1a", "us-east-1b"]
      enable_natgw = true
    }
    "eu-west-1" = {
      vpc_cidr     = "10.1.0.0/16"
      azs          = ["eu-west-1a", "eu-west-1b"]
      enable_natgw = false
    }
  }
}

# Create provider for each region
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
  }
}

# VPCs in each region
resource "aws_vpc" "regional" {
  for_each = var.regions
  
  provider = aws[each.key]  # Requires provider aliases
  
  cidr_block = each.value.vpc_cidr
  
  tags = {
    Name   = "${var.project}-vpc-${each.key}"
    Region = each.key
  }
}
```

## Limitations and Workarounds

### The Planning Phase Limitation
```t
# ❌ This will error - for_each value unknown
resource "aws_instance" "bad" {
  for_each = aws_subnet.private  # Resource attributes not known yet!
  
  subnet_id = each.value.id
}

# ✅ Workaround 1: Use count with data structure
locals {
  subnet_configs = [
    { name = "subnet-1", cidr = "10.0.1.0/24" },
    { name = "subnet-2", cidr = "10.0.2.0/24" }
  ]
}

resource "aws_instance" "good" {
  count = length(local.subnet_configs)
  
  subnet_id = aws_subnet.private[count.index].id
  
  tags = {
    Name = local.subnet_configs[count.index].name
  }
}

# ✅ Workaround 2: Use static configuration
variable "instance_subnets" {
  type = map(string)
  description = "Map of instance name to subnet ID"
}

resource "aws_instance" "static" {
  for_each = var.instance_subnets
  
  subnet_id = each.value
  
  tags = {
    Name = each.key
  }
}
```

### Avoiding timestamp/uuid Issues
```t
# ❌ This will error
resource "aws_s3_bucket" "bad" {
  count = timestamp() == timestamp() ? 1 : 0  # Impure function!
}

# ✅ Use random provider instead
resource "random_id" "bucket_suffix" {
  byte_length = 8
}

resource "aws_s3_bucket" "good" {
  bucket = "my-bucket-${random_id.bucket_suffix.hex}"
}
```

## Best Practices

### 1. Choose the Right Tool
```t
# Use count when:
# - Creating identical resources
# - Need specific number of resources
# - Conditional creation (0 or 1)

resource "aws_instance" "workers" {
  count = var.worker_count  # Simple replication
}

# Use for_each when:
# - Resources have different configurations
# - Working with named/keyed items
# - Need stable identities

resource "aws_route53_record" "domains" {
  for_each = var.domain_configs  # Each domain is unique
}
```

### 2. Stable Resource Identities
```t
# ⚠️ count: Changing order affects all resources
variable "instance_names" {
  default = ["web", "app", "db"]
}

resource "aws_instance" "unstable" {
  count = length(var.instance_names)
  tags = {
    Name = var.instance_names[count.index]
  }
}
# Removing "app" would rename "db" to index 1!

# ✅ for_each: Stable identities
resource "aws_instance" "stable" {
  for_each = toset(var.instance_names)
  tags = {
    Name = each.value
  }
}
# Removing "app" doesn't affect others
```

### 3. Conditional Resources Pattern
```t
# Single optional resource
resource "aws_cloudfront_distribution" "cdn" {
  count = var.enable_cdn ? 1 : 0
  # ...
}

# Reference safely
output "cdn_domain" {
  value = var.enable_cdn ? aws_cloudfront_distribution.cdn[0].domain_name : null
}

# Multiple related optional resources
locals {
  create_alb = var.load_balancer_type == "application"
}

resource "aws_lb" "this" {
  count = local.create_alb ? 1 : 0
  # ...
}

resource "aws_lb_listener" "this" {
  count = local.create_alb ? 1 : 0
  
  load_balancer_arn = aws_lb.this[0].arn
  # ...
}
```

## Key Takeaways

1. **count for simple replication** - When you need N identical resources
2. **for_each for complex scenarios** - When resources need different configurations
3. **count.index starts at 0** - Use `count.index + 1` for 1-based numbering
4. **for_each provides each.key and each.value** - Same for sets, different for maps
5. **Values must be known at plan time** - Can't use resource attributes
6. **for_each requires set or map** - Convert lists with toset()
7. **Conditional pattern**: `count = condition ? 1 : 0`
8. **Stable identities with for_each** - Resources keep identity when set changes

These meta-parameters are fundamental to creating flexible, reusable Terraform configurations that can adapt to different requirements without code duplication.
