# Chapter 4.4: Strings and Templates

## What This Chapter is About

This chapter explains **string manipulation and templating** in Terraform - how to work with text files, create dynamic configurations, and build complex strings from templates. It covers when templates are appropriate and when to use alternatives.

## Key Concept: Templates = Dynamic Text Generation

Think of templates like:
- **Mail merge**: Same letter template, different recipient details
- **Recipe cards**: Base recipe with customizable ingredients
- **Web templates**: HTML with placeholders for dynamic content

## The file Function

### Loading Static Files
```t
# Basic file loading
locals {
  # Simple file read
  config_content = file("config.txt")
  
  # JSON file
  json_data = jsondecode(file("data.json"))
  
  # Multi-line text
  license_text = file("LICENSE")
}

# Using with resources
resource "aws_s3_object" "config" {
  bucket  = aws_s3_bucket.main.id
  key     = "config/app.conf"
  content = file("files/app.conf")
}
```

### Using Path Helpers
```t
# Path helpers available
locals {
  # Path to current module
  module_file = file("${path.module}/files/config.txt")
  
  # Path to root module
  root_file = file("${path.root}/global-config.txt")
  
  # Current working directory (where terraform runs)
  cwd_file = file("${path.cwd}/local-config.txt")
}

# Common pattern for module files
resource "aws_instance" "example" {
  user_data = file("${path.module}/scripts/bootstrap.sh")
}
```

## The templatefile Function

### Basic Template Usage
```t
# Template file: templates/config.tftpl
server {
  hostname = ${hostname}
  port = ${port}
  enable_ssl = ${enable_ssl}
}

# Using the template
locals {
  nginx_config = templatefile("${path.module}/templates/config.tftpl", {
    hostname   = var.domain_name
    port       = var.https_enabled ? 443 : 80
    enable_ssl = var.https_enabled
  })
}
```

### Complex Template Example
```t
# Template file: templates/user-data.sh.tftpl
#!/bin/bash
# Configure hostname
hostnamectl set-hostname ${hostname}

# Install packages
%{ for package in packages ~}
apt-get install -y ${package}
%{ endfor ~}

# Configure services
%{ if enable_monitoring ~}
systemctl enable monitoring
systemctl start monitoring
%{ endif ~}

# Set environment variables
%{ for key, value in environment ~}
export ${key}="${value}"
%{ endfor ~}

# Using the template
resource "aws_instance" "app" {
  user_data = templatefile("${path.module}/templates/user-data.sh.tftpl", {
    hostname         = "${var.app_name}-${count.index}"
    packages         = ["nginx", "nodejs", "git"]
    enable_monitoring = var.environment == "prod"
    environment = {
      APP_ENV = var.environment
      APP_PORT = "3000"
      API_URL = var.api_endpoint
    }
  })
}
```

## String Template Language

### Interpolation vs Directives
```t
# ${...} for interpolation (insert values)
# %{...} for directives (logic/control flow)

# Interpolation examples
output "message" {
  value = "Hello ${var.name}, welcome to ${var.environment}!"
}

# Directive examples
output "conditional" {
  value = <<-EOT
    %{ if var.enable_feature }
    Feature is enabled
    %{ else }
    Feature is disabled
    %{ endif }
  EOT
}
```

### Conditional Logic in Templates
```t
# Template: configs/app.conf.tftpl
[application]
name = ${app_name}
environment = ${environment}

%{ if enable_debug ~}
[debug]
level = verbose
log_file = /var/log/${app_name}-debug.log
%{ endif ~}

%{ if database_config != null ~}
[database]
host = ${database_config.host}
port = ${database_config.port}
name = ${database_config.name}
%{ endif ~}

# Using conditional template
locals {
  app_config = templatefile("configs/app.conf.tftpl", {
    app_name     = var.app_name
    environment  = var.environment
    enable_debug = var.environment != "prod"
    database_config = var.enable_database ? {
      host = aws_db_instance.main[0].address
      port = aws_db_instance.main[0].port
      name = var.db_name
    } : null
  })
}
```

### Loops in Templates
```t
# Template: templates/nginx.conf.tftpl
upstream backend {
%{ for server in servers ~}
  server ${server.ip}:${server.port} weight=${server.weight};
%{ endfor ~}
}

server {
  listen 80;
  server_name ${domain};
  
  location / {
    proxy_pass http://backend;
  }
  
%{ for path, config in custom_locations ~}
  location ${path} {
    ${config}
  }
%{ endfor ~}
}

# Using the template
locals {
  nginx_config = templatefile("templates/nginx.conf.tftpl", {
    domain = var.domain_name
    servers = [
      { ip = "10.0.1.10", port = 8080, weight = 5 },
      { ip = "10.0.1.11", port = 8080, weight = 3 },
      { ip = "10.0.1.12", port = 8080, weight = 2 }
    ]
    custom_locations = {
      "/api" = "proxy_pass http://api-backend;"
      "/static" = "root /var/www/static;"
    }
  })
}
```

### Functions in Templates
```t
# Template with function calls
%{ for i, instance in instances ~}
Instance ${i + 1}: ${upper(instance.name)} at ${instance.ip}
  CPU: ${instance.cpu} cores (${instance.cpu * 100 / total_cpu}% of cluster)
  Memory: ${instance.memory}GB (${format("%.1f", instance.memory * 100 / total_memory)}% of cluster)
%{ endfor ~}

Total instances: ${length(instances)}
Average CPU: ${format("%.2f", total_cpu / length(instances))} cores
```

### The ~ Strip Marker
```t
# Without strip markers - includes whitespace
%{ for item in items }
- ${item}
%{ endfor }
# Output:
# 
# - item1
# 
# - item2
# 

# With strip markers - removes whitespace
%{ for item in items ~}
- ${item}
%{ endfor ~}
# Output:
# - item1
# - item2
```

## The Deprecated template_file Data Source

### Old Pattern (Avoid)
```t
# ❌ Deprecated - don't use
data "template_file" "config" {
  template = file("${path.module}/config.tpl")
  vars = {
    name = var.app_name
    port = var.app_port
  }
}

resource "aws_s3_object" "config" {
  content = data.template_file.config.rendered
}
```

### Modern Replacement
```t
# ✅ Use templatefile instead
resource "aws_s3_object" "config" {
  content = templatefile("${path.module}/config.tpl", {
    name = var.app_name
    port = var.app_port
  })
}
```

## When NOT to Use Templates

### Avoid Templates for Structured Data
```t
# ❌ Bad - Building JSON with templates
locals {
  json_template = <<-EOT
  {
    "name": "${var.name}",
    "enabled": ${var.enabled},
    "tags": [
      %{ for tag in var.tags ~}
      "${tag}"%{ if tag != var.tags[length(var.tags)-1] },%{ endif }
      %{ endfor ~}
    ]
  }
  EOT
}

# ✅ Good - Use jsonencode
locals {
  json_data = jsonencode({
    name    = var.name
    enabled = var.enabled
    tags    = var.tags
  })
}
```

### Use Native Data Sources
```t
# ❌ Bad - IAM policy as template
locals {
  iam_policy_template = templatefile("policy.json.tpl", {
    bucket_name = aws_s3_bucket.main.id
    role_arn    = aws_iam_role.main.arn
  })
}

# ✅ Good - Use IAM policy data source
data "aws_iam_policy_document" "s3_access" {
  statement {
    actions   = ["s3:GetObject"]
    resources = ["${aws_s3_bucket.main.arn}/*"]
    
    principals {
      type        = "AWS"
      identifiers = [aws_iam_role.main.arn]
    }
  }
}

locals {
  iam_policy = data.aws_iam_policy_document.s3_access.json
}
```

## Practical Examples

### Cloud-Init Configuration
```t
# templates/cloud-init.yaml.tftpl
#cloud-config
hostname: ${hostname}
manage_etc_hosts: true
package_update: true
package_upgrade: ${upgrade_packages}

packages:
%{ for pkg in packages ~}
  - ${pkg}
%{ endfor ~}

users:
  - name: ${admin_user}
    groups: sudo
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    ssh_authorized_keys:
%{ for key in ssh_keys ~}
      - ${key}
%{ endfor ~}

write_files:
  - path: /etc/environment
    content: |
%{ for key, value in environment_vars ~}
      ${key}="${value}"
%{ endfor ~}

runcmd:
%{ for cmd in startup_commands ~}
  - ${cmd}
%{ endfor ~}

# Using the template
resource "aws_instance" "app" {
  user_data = templatefile("${path.module}/templates/cloud-init.yaml.tftpl", {
    hostname         = "${var.app_name}-${count.index}"
    upgrade_packages = var.environment == "prod"
    packages         = ["docker", "docker-compose", "git"]
    admin_user       = "ubuntu"
    ssh_keys         = var.admin_ssh_keys
    environment_vars = {
      APP_ENV  = var.environment
      APP_NAME = var.app_name
    }
    startup_commands = [
      "systemctl start docker",
      "systemctl enable docker",
      "docker pull ${var.app_image}",
      "docker run -d --name app ${var.app_image}"
    ]
  })
}
```

### Kubernetes Manifests
```t
# templates/k8s-deployment.yaml.tftpl
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${app_name}
  namespace: ${namespace}
  labels:
    app: ${app_name}
    environment: ${environment}
spec:
  replicas: ${replicas}
  selector:
    matchLabels:
      app: ${app_name}
  template:
    metadata:
      labels:
        app: ${app_name}
        version: ${app_version}
    spec:
      containers:
      - name: ${app_name}
        image: ${image}:${app_version}
        ports:
        - containerPort: ${container_port}
%{ if environment_vars != {} ~}
        env:
%{ for key, value in environment_vars ~}
        - name: ${key}
          value: "${value}"
%{ endfor ~}
%{ endif ~}
%{ if resource_limits != null ~}
        resources:
          limits:
            cpu: "${resource_limits.cpu}"
            memory: "${resource_limits.memory}"
%{ endif ~}

# Using the template
resource "kubernetes_manifest" "deployment" {
  manifest = yamldecode(templatefile("templates/k8s-deployment.yaml.tftpl", {
    app_name     = var.app_name
    namespace    = var.namespace
    environment  = var.environment
    replicas     = var.replica_count
    app_version  = var.app_version
    image        = var.container_image
    container_port = var.port
    environment_vars = var.env_vars
    resource_limits = var.enable_limits ? {
      cpu    = var.cpu_limit
      memory = var.memory_limit
    } : null
  }))
}
```

## Best Practices

### 1. Use the Right Tool
```t
# For structured data: use encode functions
locals {
  json_config = jsonencode(var.config)
  yaml_config = yamlencode(var.config)
}

# For large static files: use file()
locals {
  license = file("LICENSE.txt")
}

# For dynamic text: use templatefile()
locals {
  readme = templatefile("README.md.tpl", {
    version = var.app_version
    author  = var.author
  })
}
```

### 2. Keep Templates Readable
```t
# ✅ Good - Clear structure
%{ if enable_feature ~}
Feature: ${feature_name}
  Status: Enabled
  Config: ${feature_config}
%{ endif ~}

# ❌ Bad - Hard to read
%{if enable_feature~}Feature: ${feature_name} Status: Enabled Config: ${feature_config}%{endif~}
```

### 3. Validate Template Variables
```t
# Add validation to prevent template errors
variable "template_vars" {
  type = object({
    hostname = string
    port     = number
    ssl      = bool
  })
  
  validation {
    condition     = var.template_vars.port > 0 && var.template_vars.port < 65536
    error_message = "Port must be between 1 and 65535."
  }
}
```

## Key Takeaways

1. **file() for static content** - Load unchanged files into Terraform
2. **templatefile() for dynamic content** - Generate files with variable substitution
3. **Use path helpers** - `path.module` ensures correct file locations
4. **Template language is powerful** - Supports conditionals, loops, and functions
5. **Avoid templates for structured data** - Use jsonencode/yamlencode instead
6. **Strip markers control whitespace** - Use `~}` and `{~` for cleaner output
7. **Replace deprecated patterns** - Use templatefile() not template_file data source

Templates are powerful tools for generating configuration files, scripts, and other text-based resources, but should be used appropriately alongside Terraform's native data handling capabilities.
