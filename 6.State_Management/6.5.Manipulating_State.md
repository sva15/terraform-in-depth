# 6.5 State Manipulation

Sometimes you need to modify Terraform state without changing the actual infrastructure. Common scenarios include renaming resources, moving resources between modules, or removing resources from Terraform management without destroying them.

## When to Manipulate State

**Common Use Cases**:
- Renaming resources without recreating them
- Moving resources between modules during refactoring
- Removing resources from Terraform control (but keeping infrastructure)
- Importing existing infrastructure into Terraform
- Fixing state corruption issues

**Three Approaches Available**:
1. **Code-driven** (Recommended): Using `moved` and `removed` blocks
2. **CLI-driven**: Using `terraform state` commands
3. **Manual editing** (Last resort): Direct state file modification

## State Backup and Recovery

**‚ö†Ô∏è CRITICAL**: Always backup state before making any modifications!

### Creating Backups

```bash
# Create a backup of current state
terraform state pull > backup-$(date +%Y%m%d-%H%M%S).tfstate

# Verify backup was created
ls -la backup-*.tfstate
```

### Restoring from Backup

```bash
# Method 1: Direct file restore
terraform state push backup-20240118-143022.tfstate

# Method 2: Pipe from backup
cat backup-20240118-143022.tfstate | terraform state push -

# Method 3: Force restore (bypasses safety checks)
terraform state push -force backup-20240118-143022.tfstate
```

### Safety Mechanisms

Terraform includes built-in protections:
- **Lineage check**: Prevents mixing state from different projects
- **Serial check**: Prevents overwriting newer state with older versions
- Use `-force` flag only when intentionally reverting changes

### Best Practices

1. **Always backup before state operations**
2. **Use descriptive backup names with timestamps**
3. **Test backups in non-production environments first**
4. **Keep multiple backup versions for critical environments**

## Code-Driven State Changes (Recommended)

The best approach for state manipulation is using Terraform configuration blocks. This method is repeatable, version-controlled, and automatically applies to all environments.

### The `moved` Block

Use `moved` blocks to relocate resources without destroying them:

**Syntax**:
```hcl
moved {
  from = old_resource_address
  to   = new_resource_address
}
```

### Example: Renaming a Resource

```hcl
# New resource with updated name
resource "random_password" "main" {
  length = 12
}

# Move from old name to new name
moved {
  from = random_password.my_password
  to   = random_password.main
}
```

### The `removed` Block

Use `removed` blocks to remove resources from Terraform management without destroying the infrastructure:

**Syntax**:
```hcl
removed {
  from = resource_address
  
  lifecycle {
    destroy = false  # Keep infrastructure, remove from state
  }
}
```

### Example: Removing Resource from Management

```hcl
# Remove S3 bucket from Terraform control but keep the actual bucket
removed {
  from = aws_s3_bucket.legacy_bucket
  
  lifecycle {
    destroy = false
  }
}
```

**Important Notes**:
- `lifecycle` block is required with `removed`
- `destroy = false` keeps infrastructure intact
- `destroy = true` would destroy the infrastructure
- Resource definition must be removed from configuration

### Moving Resources to Modules

The `moved` block also works for moving resources between modules:

```hcl
# New module containing the resource
module "password" {
  source = "./modules/password"
}

# Move resource from root module to child module
moved {
  from = random_password.my_password
  to   = module.password.random_password.main
}
```

### Benefits of Code-Driven Approach

1. **Version Controlled**: Changes are tracked in your repository
2. **Repeatable**: Automatically applies to all environments
3. **Safe**: No risk of manual JSON editing errors
4. **Collaborative**: Team members see changes in code reviews
5. **Module Friendly**: Essential for shared module development

### Common Patterns

**Renaming Resources**:
```hcl
moved {
  from = aws_instance.web_server
  to   = aws_instance.app_server
}
```

**Moving to Modules**:
```hcl
moved {
  from = aws_vpc.main
  to   = module.networking.aws_vpc.main
}
```

**Refactoring Module Structure**:
```hcl
moved {
  from = module.old_structure.aws_instance.app
  to   = module.new_structure.aws_instance.app
}
```

## CLI-Driven State Changes

When code-driven approaches aren't suitable, Terraform provides CLI commands for state manipulation. Use these for one-off operations or emergency situations.

### Common State Commands

**List all resources in state**:
```bash
terraform state list
```

**Show detailed resource information**:
```bash
terraform state show aws_instance.web
```

**Remove resource from state** (keeps infrastructure):
```bash
terraform state rm aws_instance.web
```

**Move resource within state**:
```bash
terraform state mv aws_instance.web aws_instance.app
```

### When to Use CLI Commands

1. **Emergency situations** where code changes aren't practical
2. **One-time migrations** that won't be repeated
3. **Debugging state issues** during development
4. **Legacy cleanup** when `removed` blocks aren't suitable

‚ö†Ô∏è **Important**: CLI changes are not version-controlled and must be documented separately.

### Example: Removing Resources from State

```bash
# List all resources to find the correct address
$ terraform state list
module.my_password.data.null_data_source.values
module.my_password.random_password.main

# Remove specific resource from state (keeps infrastructure)
$ terraform state rm module.my_password.random_password.main
Removed module.my_password.random_password.main
Successfully removed 1 resource instance(s).
```

### Provider Replacement

Sometimes you need to change which provider manages existing resources:

```bash
# Replace provider in state
terraform state replace-provider \
  hashicorp/random \
  registry.custom.io/hashicorp/random
```

**Common scenarios**:
- Testing development provider versions
- Switching to custom provider registries
- Migrating between provider forks
- Using different provider configurations

### Legacy Commands (Avoid)

These commands exist but are superseded by code-driven approaches:

| Legacy Command | Modern Alternative | Reason |
|---------------|-------------------|---------|
| `terraform state mv` | `moved` block | Version controlled, repeatable |
| `terraform import` | `import` block | Declarative, team-friendly |

**Recommendation**: Always prefer code-driven approaches for maintainability and collaboration.

## Manual State Editing (Last Resort)

‚ö†Ô∏è **WARNING**: Manual state editing is extremely dangerous and should only be used as a last resort when other methods fail.

### When Manual Editing Might Be Necessary

- **State corruption** that can't be fixed with other tools
- **Emergency recovery** situations
- **Complex state repairs** not supported by CLI commands

### Manual Editing Process

```bash
# 1. Create backup
terraform state pull > emergency-backup.tfstate

# 2. Pull current state for editing
terraform state pull > current-state.tfstate

# 3. Edit the JSON file carefully
# (Use a proper JSON editor with validation)

# 4. Validate JSON syntax
jq . current-state.tfstate > /dev/null

# 5. Push modified state back
terraform state push current-state.tfstate
```

### Critical Safety Measures

1. **Always backup first** - Multiple backups in different locations
2. **Validate JSON syntax** - Use `jq` or online JSON validators
3. **Increment serial number** - Avoid using `-force` flag
4. **Test in non-production** - Never edit production state directly
5. **Document changes** - Record what was changed and why
6. **Verify results** - Run `terraform plan` to check for issues

### Common Risks

‚ùå **JSON syntax errors** - Can make state completely unreadable
‚ùå **Resource relationship corruption** - May cause unexpected recreations
‚ùå **Attribute mismatches** - Can lead to configuration drift
‚ùå **Serial/lineage issues** - May prevent future state operations
‚ùå **Data loss** - Accidental deletion of critical state information

### Better Alternatives

Before manual editing, try these approaches:
1. **State commands** - `terraform state mv`, `terraform state rm`
2. **Import blocks** - For bringing resources back into state
3. **Provider support** - Contact provider maintainers for guidance
4. **Community help** - Terraform forums and Stack Overflow
5. **Professional services** - HashiCorp or certified consultants

## Best Practices Summary

### Recommended Approach Priority

1. **ü•á Code-driven** (`moved`/`removed` blocks)
   - Version controlled and repeatable
   - Automatically applies to all environments
   - Safe and collaborative

2. **ü•à CLI-driven** (`terraform state` commands)
   - Good for one-off operations
   - Immediate feedback
   - Requires documentation

3. **ü•â Manual editing** (Emergency only)
   - High risk of errors
   - Not repeatable
   - Should be avoided

### Key Takeaways

- **Always backup state** before any manipulation
- **Prefer code-driven approaches** for maintainability
- **Test changes in non-production** environments first
- **Document all state modifications** for team awareness
- **Use manual editing only** when absolutely necessary