# Chapter 6.6: State Drift

## What This Chapter is About

This chapter explains **state drift** - what happens when your infrastructure changes outside of Terraform's control. It's like someone changing your LEGO creation when you weren't looking, and now your blueprint doesn't match reality.

## Key Concepts

### What is State Drift?
- Changes to infrastructure that happen outside of Terraform
- Detected during `terraform plan` or `terraform plan --refresh-only`
- Creates a mismatch between Terraform's state file and actual infrastructure

## Types of State Drift

### 1. Accidental Manual Changes
```hcl
# Example scenario: 
# A developer accidentally changes instance type in AWS console
# from t3.micro to t3.small

# Terraform will detect and try to revert:
resource "aws_instance" "web" {
  instance_type = "t3.micro"  # Will revert back to this
}
```

Key Points:
- Human mistakes (wrong clicks, commands)
- Usually easy to fix
- Prevent with access controls
- Let Terraform fix automatically

### 2. Intentional Manual Changes
```hcl
# Example: Emergency capacity increase
# On-call engineer manually adds servers during outage

resource "aws_autoscaling_group" "web" {
  desired_capacity = 2  # Original setting
  # Manual change set to 5 will be reverted unless updated here
}
```

Key Points:
- Deliberate changes for urgent needs
- Need to be added to Terraform code quickly
- Risk of being reverted
- Require policy for handling emergencies

### 3. Conflicting Automated Changes
```hcl
# Example: Handling automatic changes
resource "aws_instance" "main" {
  tags = {
    Name = "web-server"
  }

  lifecycle {
    ignore_changes = [
      tags,  # Ignore changes to tags
    ]
  }
}
```

Common Scenarios:
- New software versions/images
- External systems adding tags
- Autoscaling changes
- Automatic updates

### 4. Terraform Errors
```hcl
# Common scenarios:
# - Terraform crashes before saving state
# - Authentication expires
# - Corrupted state file
# - Container/machine crashes
```

## Handling State Drift

### Detection
```hcl
# Safe way to check for drift
terraform plan --refresh-only
```

### Resolution Process
```hcl
# 1. Review what changed
terraform show

# 2. Import if needed
terraform import aws_instance.example i-1234567

# 3. Update configuration if necessary
resource "aws_instance" "example" {
  # Update to match reality
  instance_type = "t3.large"
}
```

### Using ignore_changes
```hcl
# Ignore expected automated changes
resource "aws_autoscaling_group" "example" {
  desired_capacity = 2

  lifecycle {
    ignore_changes = [
      desired_capacity,  # Ignore scaling changes
      tags              # Ignore tag changes
    ]
  }
}
```

## Best Practices

### 1. Prevention
```hcl
# Document expected changes
resource "aws_instance" "web" {
  instance_type = "t3.micro"

  # Document why we're ignoring changes
  lifecycle {
    ignore_changes = [
      # Ignore tags as they're managed by our monitoring system
      tags,
      # Ignore AMI updates handled by automated patching
      ami
    ]
  }
}
```

### 2. Monitoring
```hcl
# Regular state validation
terraform plan --refresh-only

# Keep state backups
terraform {
  backend "s3" {
    bucket = "terraform-state"
    key    = "prod/terraform.tfstate"
    versioning = true  # Enable state versioning
  }
}
```

### 3. Documentation
```hcl
# Document manual intervention process
/*
  Emergency Change Process:
  1. Make required changes
  2. Document in ticket
  3. Update Terraform within 24 hours
  4. Run terraform plan to verify
*/
```

## Common Scenarios and Solutions

### Automated Changes
```hcl
# Handle auto-scaling changes
resource "aws_autoscaling_group" "web" {
  min_size = 2
  max_size = 10
  
  lifecycle {
    ignore_changes = [desired_capacity]
  }
}
```

### External Tags
```hcl
# Handle external tagging systems
resource "aws_instance" "app" {
  # ... other configuration ...

  lifecycle {
    ignore_changes = [tags]
  }
}
```

### Version Updates
```hcl
# Handle automatic version updates
resource "aws_db_instance" "database" {
  engine_version = "13.7"

  lifecycle {
    ignore_changes = [engine_version]
  }
}
```

## Key Takeaways

1. State drift is normal but needs management
2. Four types of drift:
   - Accidental manual changes
   - Intentional manual changes
   - Automated changes
   - Terraform errors
3. Use `ignore_changes` for expected changes
4. Always document why changes are ignored
5. Regular monitoring prevents surprises
6. Keep state backups
7. Have clear processes for emergencies

## Best Practices Summary

1. **Prevent**
   - Limit manual access
   - Use CI/CD pipelines
   - Document processes

2. **Detect**
   - Regular drift checks
   - Monitoring
   - State validation

3. **Resolve**
   - Quick documentation
   - Prompt code updates
   - Clear communication

Remember: The goal isn't to eliminate drift but to manage it effectively through good practices and processes.
