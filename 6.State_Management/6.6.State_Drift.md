# 6.6 State Drift Detection and Resolution

State drift occurs when your actual infrastructure differs from what Terraform believes exists in its state file. This happens when changes are made outside of Terraform's control, creating a mismatch between reality and Terraform's records.

## Understanding State Drift

**What is State Drift?**
- Infrastructure changes made outside Terraform
- Differences between actual resources and state file records
- Detected during `terraform plan` or `terraform plan -refresh-only`
- Can lead to unexpected behavior during deployments

**Common Detection Methods**:
```bash
# Detect drift with refresh-only plan (recommended)
terraform plan -refresh-only

# Legacy refresh command (avoid)
terraform refresh
```

**Why State Drift Matters**:
- Can cause deployment failures
- May lead to resource conflicts
- Indicates process or security issues
- Can result in unexpected costs or downtime

## Root Cause Analysis

When drift is detected, ask these critical questions:

1. **What changed?** - Identify specific resources and attributes
2. **When did it change?** - Check timestamps and logs
3. **Who made the change?** - Review access logs and team communications
4. **Why was it changed?** - Understand the business or technical reason

**Investigation Steps**:
```bash
# Compare current state with actual infrastructure
terraform plan -refresh-only

# Review detailed resource information
terraform state show <resource_address>

# Check provider-specific logs and audit trails
```

Once you’ve identified the problem, you can begin to resolve it. In general, there are four categories of state drift errors, shown in figure 6.2.

Figure 6.2: Types of state drift

## Types of State Drift

There are four main categories of state drift, each requiring different resolution strategies:

### 1. Accidental Manual Changes

**What happens**: Unintended changes made by human error
- Wrong account access
- Incorrect commands executed
- Misclicked buttons in cloud consoles
- Copy-paste errors in scripts

**Resolution Strategy**:
```bash
# Usually straightforward - let Terraform fix it
terraform plan
terraform apply
```

**Prevention Measures**:
- Implement strict access controls
- Use CI/CD pipelines for all changes
- Enable MFA for production accounts
- Provide clear documentation and training
- Use infrastructure guardrails and policies

**Key Point**: Focus on system improvements, not blame. Human error is inevitable and should be designed around.

### 2. Intentional Manual Changes

**What happens**: Deliberate changes made outside Terraform
- Emergency fixes during incidents
- Hotfixes applied directly to infrastructure
- Manual scaling during traffic spikes
- Security patches applied urgently

**The Challenge**: Someone wanted the change, but Terraform will revert it!

**Resolution Strategy**:
```bash
# 1. Document the change immediately
# 2. Update Terraform configuration to match
# 3. Plan to verify alignment
terraform plan

# 4. Apply to sync state
terraform apply
```

**Emergency Response Process**:
1. **Make the fix** - Resolve the immediate issue
2. **Document immediately** - Record what was changed
3. **Update Terraform ASAP** - Prevent reversion on next run
4. **Communicate to team** - Ensure everyone knows about the change
5. **Review process** - Improve pipeline for future emergencies

**Prevention Strategies**:
- Fast, reliable CI/CD pipelines
- Emergency change procedures
- On-call access to deployment tools
- Pre-approved emergency configurations

### 3. Expected Automated Changes

**What happens**: Infrastructure changes automatically as designed
- **Auto-scaling**: Instance counts change based on load
- **Auto-updates**: Database minor versions updated during maintenance
- **External tagging**: Monitoring or security tools add metadata
- **Image updates**: New AMIs or container images become available

**These are NOT errors** - they're expected behavior!

**Resolution Options**:

**Option 1: Accept and Apply Changes**
```bash
# Let Terraform update to latest state
terraform plan -refresh-only
terraform apply -refresh-only
```

**Option 2: Ignore Specific Changes**
```hcl
resource "aws_instance" "web" {
  ami           = data.aws_ami.latest.id
  instance_type = "t3.micro"
  
  tags = {
    Name        = "web-server"
    Environment = "production"
  }
  
  lifecycle {
    # Ignore external tag changes
    ignore_changes = [tags]
  }
}

resource "aws_autoscaling_group" "app" {
  min_size = 2
  max_size = 10
  
  lifecycle {
    # Ignore current capacity changes
    ignore_changes = [desired_capacity]
  }
}

{{ ... }}
    ignore_changes = [desired_capacity]
  }
}
```
**Common `ignore_changes` Patterns**:
- `[tags]` - External tagging systems
- `[desired_capacity]` - Auto-scaling groups
- `[ami]` - When using latest AMI data sources
- `[engine_version]` - Database auto-updates
- `[availability_zone]` - When AZ is auto-selected

**Decision Framework**:
- **Accept changes**: When you want Terraform to adopt the new values
- **Ignore changes**: When external systems should control specific attributes
- **Refresh only**: When you just need to update state without applying changes

Listing 6.18:
resource "aws_instance" "main" {
  tags = {                                  ①
    Name        = var.name                  ②
    Application = var.application           ③
  }
 
  lifecycle {
    ignore_changes = [tags]                 ④
  }
}

① Tags are regularly used to attach metadata to instances.

② The name tag is special in AWS, as it makes the name visible in the console.

③ A lot of teams use application tags to track expenses.

④ If the tags change outside of Terraform we will ignore that change.

For some attributes that change automatically, there isn’t anything that needs to be done at all. Thinking about the RDS example from earlier, there really isn’t a problem that comes from the state drift. A refresh-only plan will bring the state up to date again.

### 4. Terraform Execution Failures

**What happens**: Terraform itself fails during execution
- **Process crashes**: Terraform terminates unexpectedly
- **Infrastructure failures**: Container/VM running Terraform fails
- **Authentication expires**: Backend access tokens timeout
- **State corruption**: State file becomes unreadable
- **Network issues**: Connection lost during state save

**The Problem**: Resources created but not recorded in state!

**Symptoms**:
```bash
# Next run tries to create duplicate resources
$ terraform plan
Error: A resource with the identifier "my-resource" already exists
```

**Resolution Process**:

**Step 1: Investigate**
```bash
# Check Terraform logs for created resources
grep "Creation complete" terraform.log

# Check cloud provider logs/console
# Look for resources created around failure time
```

**Step 2: Reconcile Resources**

**Option A: Import Missing Resources**
```bash
# Import existing resource into state
terraform import aws_instance.web i-1234567890abcdef0
```

**Option B: Remove Orphaned Resources**
```bash
# Delete the orphaned resource
aws ec2 terminate-instances --instance-ids i-1234567890abcdef0

# Then run Terraform normally
terraform apply
```

**Step 3: Prevent Future Issues**
- Use reliable infrastructure for Terraform execution
- Implement proper error handling and retries
- Monitor Terraform execution logs
- Maintain regular state backups

**State Corruption Recovery**:
```bash
# If state is completely corrupted
terraform state pull > corrupted-state.tfstate

# Restore from backup
terraform state push backup-state.tfstate

# Verify restoration
terraform plan