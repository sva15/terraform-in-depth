# 6.8 State-only Resources
Some Terraform resources don't talk to any cloud or external system. Instead, they just store their data inside Terraform's state file. These are called **state-only resources**.

For example, when you create certificates or keys using the TLS provider, everything is stored in Terraform state. No outside servers or APIs are involved.

## 6.8.1 Random Provider
The **random provider** is one of the most popular state-only providers. It helps you generate random values like passwords, numbers, or names, but makes sure they don't change every time you run Terraform.

Why is this useful? In most programming languages, random functions return a new value every time. If Terraform did this, your configuration would always look like it needs to change. The random provider solves this by saving the random value in state, so it only changes when you tell it to (using a special option called `keepers`).

**Example:**
```hcl
resource "random_uuid" "example" {
  keepers = {
    name = var.name
  }
}
```
- This creates a random UUID and saves it in state.
- If the variable `name` changes, the UUID will be regenerated.

The random provider can create many types of random values, like numbers, UUIDs, or even funny pet names. It can also shuffle lists.

**Examples:**
```hcl
resource "random_integer" "number" {
  min = 0
  max = 10
}
output "number" {
  value = random_integer.number.result
}

resource "random_uuid" "uuid" {}
output "uuid" {
  value = random_uuid.uuid.result
}

resource "random_pet" "uniqueish_suffix" {
  length = 2
}
output "suffix" {
  value = random_pet.uniqueish_suffix.id
}
```
- `random_integer` gives a number between 0 and 10.
- `random_uuid` gives a unique ID.
- `random_pet` gives a fun, human-readable name like "sage-longhorn".

There is also a special random resource called random_password. The random_password resource is the only resource in the provider that is guaranteed to use a cryptographic random number generator, which means that it can be used to create passwords. The attribute for the password is marked as sensitive, so it should not show up in logs and will present a warning if it is used as a root-level module output.

Listing 6.25:
resource "random_password" "password" {
  length = 16
  lower   = true
  numeric = true
  special = true
  upper   = true
  min_lower   = 0
  min_numeric = 0
  min_special = 0
  min_upper   = 0
  override_special = "!@#$%&*()-_=+[]{}<>:?"
  length = 16                                  ①
 
  lower   = true                               ②
  numeric = true                               ②
  special = true                               ②
  upper   = true                               ②
 
  min_lower   = 0                              ③
  min_numeric = 0                              ③
  min_special = 0                              ③
  min_upper   = 0                              ③
 
  override_special = "!@#$%&*()-_=+[]{}<>:?"   ④
}

① The length field is the only required field.

② These parameters allow you to disable certain types of characters.

③ These parameters allow you to set requirements for the generated password.

④ You can also specify which specific special characters to include.

As a reminder, sensitive values do still get stored in state, so when you use the random_password resource to create actual credentials, you need to be extra careful about how you’re storing your state and who can access it.

## 6.8.2 Time Provider
The **time provider** lets you save timestamps and schedule changes in Terraform, without causing state drift. Instead of using a function that changes every time, these resources only update when you want them to.

There are different time resources:
- `time_static`: Saves the time when it's created.
- `time_rotating`: Updates after a set number of days.
- `time_offset`: Lets you set a time in the future.

**Examples:**
```hcl
resource "time_offset" "two_hours_after_now" {
  offset_hours = 2
}

resource "time_rotating" "every_two_days" {
  rotation_days = 2
}

resource "aws_instance" "rotating_machine" {
  lifecycle {
    replace_triggered_by = [time_rotating.every_two_days.id]
  }
}

resource "time_static" "on_creation" {
  triggers = {
    name = aws_instance.dependent.arn
  }
}
output "instance_last_update" {
  value = time_static.on_creation.rfc3339
}
```
- These resources help you schedule or track changes in your infrastructure.

There's also a `time_sleep` resource that lets you add a wait or delay between steps in your Terraform plan.

**Example:**
```hcl
resource "aws_instance" "main" {}

resource "time_sleep" "delay" {
  create_duration = "2m"
  depends_on = [aws_instance.main]
}

resource "aws_instance" "dependent" {
  depends_on = [time_sleep.delay]
}
```
- This creates a 2-minute delay between creating two resources.

## 6.8.3 Null Provider
The **null provider** lets you create resources that do nothing. These are called `null_resource`. They are useful for testing and for using Terraform features like triggers or dependencies, without needing a real resource.

**Example:**
```hcl
resource "null_resource" "nothing" {
  triggers = {
    rebuild = timestamp()
  }
}
```
- This resource does nothing, but will be recreated every run because the timestamp changes.

In older versions of Terraform, `null_resource` was often used to run scripts. Now, it's mostly used for testing or for simple triggers.

It's a great tool for testing pipelines or workflows, since you don't have to connect to any real infrastructure.

You can use `null_resource` in root modules for quick tests, and it works with any backend or CI/CD system.

Remember the null provider when building and testing your CI/CD pipelines.

## 6.8.4 terraform_data
The `terraform_data` resource is built into Terraform (since v1.4) and is meant to replace the null provider. It acts just like `null_resource`—it does nothing, but you can use it for testing, triggers, or running provisioners.

**Example:**
```hcl
resource "terraform_data" "nothing" {
  triggers_replace = {
variable "user_input" {
  type = number
}

locals {
  is_even = var.user_input % 2 == 0
}

resource "terraform_data" "local_replacement" {
  triggers_replace = {
    is_even = local.is_even
  }
}

resource "aws_instance" "myinstance" {
  lifecycle {
    replace_triggered_by = [terraform_data.local_replacement]
  }
}
```
- This lets you trigger resource replacement based on local logic.

You can also use `terraform_data` to manage provisioners (custom scripts):
```hcl
resource "aws_instance" "main" {}

resource "time_sleep" "delay" {
  create_duration = "1m"
  depends_on      = [aws_instance.main]
}

resource "terraform_data" "provision" {
  depends_on = [time_sleep.delay]
  triggers_replace = {
    ami = aws_instance.main.arn
  }
  provisioner "run_script" {
    command = "provisioning_script.sh"
  }
}
```
- This lets you run scripts after resources are created or changed.

While `null_resource` is still around, `terraform_data` is the recommended choice for testing and CI/CD pipelines. Both are great for experimenting with Terraform code without affecting real infrastructure.