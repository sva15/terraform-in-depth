6.8 State-only resources
In chapter 5, we made a certificate authority using the TLS provider. For this we created keys, signing requests, and certificates. The interesting thing about all of this is that we didn’t connect to a third-party service: we didn’t have to use external APIs and the resources weren’t saved in files or on another system. Instead, everything for these resources was stored directly in state.

The TLS provider is an example of a state-only provider. State-only providers do not directly interact with other systems. Instead, they calculate their values programmatically and persist them in state.

6.8.1 Random provider
The random provider is probably the most-used state provider in the Terraform ecosystem. It is used to generate random data without having to regenerate that data every single time Terraform runs.

To understand why this is important, consider how most languages generate random data: via a function. Most languages have at least one function to generate randomness and often include entire libraries for it. The problem that Terraform would run into with this goes back to section 4.3.3 where we discussed pure versus impure functions. Random functions are impure functions, in that they will return different results every time they run. That means that every Terraform plan would generate a change, essentially causing state drift every run.

The random resources instead persist their randomness between runs. They will create their random data the first time they are called and then will only change that data if a parameter named keepers changes. The keepers parameter is an object that can have any values you want, and if any of those values change, it will trigger the random resource to create new data.

Listing 6.23:
resource "random_uuid" "example" {              ①
 
  keepers = {                                   ②
    "name" = var.name                           ③
  }
}

① Create a UUID.

② Keepers are optional, but when provided they allow the random values to be regenerated.

③ If the input variable name ever changes the number will be regenerated.

There are a lot of resources in the random provider. It can be used to generate bytes, integers, names (using the pets resource), or UUIDs. It can also be used to randomly shuffle lists of items.

Listing 6.24:
resource "random_integer" "number" {            ①
  min = 0
  max = 10
}
 
output "number" {
  value = random_integer.number.result          ②
}
 
resource "random_uuid" "uuid" {                 ③
 
}
 
output "uuid" {
  value = random_uuid.uuid.result               ④
}
 
resource "random_pet" "uniqueish-suffix" {      ⑤
  length = 2                                    ⑥
}
 
output "suffix" {
  value = random_pet.uniqueish-suffix.id        ⑦
}

① Create a number between 0 and 10, based on our passed parameters.

② The generated number is saved in the result attribute.

③ This UUID will be generated once and then persisted.

④ The UUID is in the result attribute.

⑤ Creates human-readable names like “sage-longhorn”

⑥ We are stating that our name should include at least two words.

⑦ Unlike the other resources, random_pet saves the results in the id attribute.

There is also a special random resource called random_password. The random_password resource is the only resource in the provider that is guaranteed to use a cryptographic random number generator, which means that it can be used to create passwords. The attribute for the password is marked as sensitive, so it should not show up in logs and will present a warning if it is used as a root-level module output.

Listing 6.25:
resource "random_password" "password" {
  length = 16                                  ①
 
  lower   = true                               ②
  numeric = true                               ②
  special = true                               ②
  upper   = true                               ②
 
  min_lower   = 0                              ③
  min_numeric = 0                              ③
  min_special = 0                              ③
  min_upper   = 0                              ③
 
  override_special = "!@#$%&*()-_=+[]{}<>:?"   ④
}

① The length field is the only required field.

② These parameters allow you to disable certain types of characters.

③ These parameters allow you to set requirements for the generated password.

④ You can also specify which specific special characters to include.

As a reminder, sensitive values do still get stored in state, so when you use the random_password resource to create actual credentials, you need to be extra careful about how you’re storing your state and who can access it.

6.8.2 Time provider
The time provider allows you to record the time of events without causing state drift. Back in chapter 4, when we introduced functions, we discussed how using the timestamp function creates problems because it returns a different value each time. The time provider avoids this problem by only generating a timestamp on creation or if the triggers parameter changes (similar to how the random resources re-create their values if their keepers parameter changes).

The time provider has four resources, three of which are used to record times. The time_offset, time_rotating, and time_static resources all record times but work slightly differently. The time_static resource is the simplest, as it just records its creation time (and regenerates it when triggers changes).

The time_rotating resource takes parameters that tell it how long to keep its value. When Terraform runs, the resource checks to see if the time has expired, and if so it generates a new value. The time_offset value works similarly to time_static except it lets you specify a time: for example, you can tell it to set a time that’s seven hours in the future and it will do so.

Listing 6.26:
resource "time_offset" "two_hours_after_now" {               ①
  offset_hours = 2                                           ②
}
 
resource "time_rotating" "every_two_days" {
  rotation_days = 2                                          ③
}
 
resource "aws_instance" "rotating_machine" {
                                                             ④
  lifecycle {
    replace_triggered_by = [time_rotating.every_two_days.id] ⑤
  }
}
 
resource "time_static" "on_creation" {                       ⑥
  triggers = {                                               ⑦
    "name" = aws_instance.dependent.arn                      ⑧
  }
}
 
output "instance_last_update" {
  value = time_static.on_creation.rfc3339                    ⑨
}

① This resource will record the current time plus any provided offsets.

② The saved time will be two hours after the resource is created.

③ This resource will get updated by Terraform if more than two days has passed.

④ Truncating aws_instance attributes.

⑤ When the time_rotating resource is updated it will trigger a replacement of this resource.

⑥ This resource always stores the current timestamp.

⑦ The triggers parameter forces the timestamp to update if it ever changes. Lifecycle rules can also be used.

⑧ When the ARN of the instance changes, update this resource.

⑨ RFC3339 is a standard for saving dates as strings.

The time provider has a fourth resource, time_sleep, that can be used to delay execution in Terraform. As an example, let’s say you have two AWS instances that you want to launch. The first one has to run some provisioning scripts, and you do not want the second machine to launch until those scripts have run. You can use a sleep resource between the first and second machine to add a delay.

Listing 6.27:
resource "aws_instance" "main" {                             ①
}
 
resource "time_sleep" "delay" {
  create_duration = "2m"                                     ②
 
  depends_on = [aws_instance.main]                           ③
}
 
resource "aws_instance" "dependent" {                        ④
 
  depends_on = [time_sleep.delay]                            ⑤
}

① Truncating attributes for this example.

② We want there to be a two-minute delay between aws_instance.main finishing and aws_instance.dependent starting.

③ This resource will not be created until aws_instance.main is created.

④ Truncating attributes for this example.

⑤ This dependency means that this resource won’t be created until after time_sleep.delay finishes creation.

6.8.3 Null provider
The null provider is one of my personal favorite providers, particularly when I’m trying to test out new automation or tools built on top of Terraform. It is a provider with a single resource, null resource, which creates resources that do absolutely nothing at all. They follow the complete resource lifecycle, in that they can be created, deleted, and updated, but they don’t do anything outside of that. Unlike other state-only resources, the null resource doesn’t even generate data. Although this seems fairly useless at first glance, the ability to do nothing (often called a “no op” in different languages, as in “no operation”) gives developers a great tool for testing and allows for the use of some Terraform features without attaching them to a specific real resource.

Listing 6.28:
resource "null_resource" "nothing" {                         ①
  triggers = {
    "rebuild" = timestamp()                                  ②
  }
}

① This resource has a full lifecycle, but does absolutely nothing.

② By setting the trigger to be the timestamp function we ensure this specific null_resource will get re-created every run.

Up until Terraform v1.4, the null resource was primarily used to run custom provisioners. This is a feature of Terraform that allows you to run custom programs and scripts on machines; we go over that in chapter 8. The use of provisioners for the null_resource is an older practice though, and there are more modern ways to handle that. This means that the null_resource really does nothing.

This makes it a fantastic tool for testing generic flows that aren’t tied to a specific project. When setting up CI/CD pipelines, generating code automatically, or building your own interfaces with Terraform, you need to have something to test with. Using real systems introduces another level of complexity that is not needed while testing these systems and generally makes the apply phase run longer. We talk about this more in chapters 10 and 11.

Utilizing the null_resource to build test workspaces allows you to run real Terraform code quickly, which should make it easier for you to test your systems. You can take the previous example and use it as a root-level module without any need to configure providers since the default configuration just works. You can then use that to test your pipelines (whether they’re in GitHub Actions or CircleCI or one of the TACOS like Terraform Cloud, Spacelift, or Env0) and state backend configuration independently of your actual infrastructure.

In the next chapter, we discuss CI/CD in detail. Keep the null provider in mind when you start building out the processes and workflows for your CI/CD platforms.

6.8.4 terraform_data
The terraform_data resource is a built-in resource that comes with Terraform itself, without the need for another provider. It was added in Terraform v1.4 and is meant as a replacement for the null provider. Just like the null_resource, the terraform_data resource implements the lifecycle of a resource without actually doing anything. Also just like the null resource, it can be used for testing and to run custom provisioners (which we discuss in chapter 8).

Listing 6.29:
resource "terraform_data" "nothing" {
  triggers_replace = {                                        ①
    "rebuild" = timestamp()                                   ②
  }
}

① This resource uses triggers_replace instead of triggers, but otherwise functions just like the null resource.

② Just like in the null example, we’re using a timestamp to force a re-creation each time.

The terraform_data resource can also be used to trigger replacements that would otherwise not be possible. The replace_triggered_by lifecycle parameter cannot take local or input variables as a value, which means that you’re limited in the logic you can apply inside of a local.

Listing 6.30:
variable "user_input" {
  type = number
}
 
locals {
  is_even = var.user_input % 2 == 0
}
 
resource "terraform_data" "local_replacement" {
  triggers_replace = {
    "is_even" = local.is_even                                 ①
  }
}
 
resource "aws_instance" "myinstance" {
  lifecycle {                                                 ②
    replace_triggered_by = [terraform_data.local_replacement] ③
  }
}

① If the local.is_even value changes then this resource is replaced.

② If the terraform_data resource is replaced then replace this resource.

③ Even though we can’t use locals directly we were able to use a local to trigger this replacement through terraform_data.

The final use of terraform_data is to manage provisioners. Provisioners are a feature of Terraform that allow you to write custom code that can run either locally or on a separate machine. They’re often used, as the name suggests, to provision infrastructure after launching. We talk about these more in chapter 10.

Listing 6.31:
resource "aws_instance" "main" {             ①
}
 
resource "time_sleep" "delay" {
  create_duration = "1m"                     ②
  depends_on      = [aws_instance.main]
}
 
resource "terraform_data" "provision" {
  depends_on = [time_sleep.delay]            ③
 
  triggers_replace = {
    "ami" = aws_instance.main.arn            ④
  }
 
  provisioner "run_script" {                 ⑤
    command = "provisioning_script.sh"
  }
}

① Like other examples we’re truncating parameters here.

② Delay for one minute to make sure the instance has finished launching.

③ This resource will not be created until the delay resource is finished.

④ If the instance is replaced we want to rerun this script.

⑤ The provisioner block lets us specify a script to run.

Although terraform_data can replace just about everything null_resource can, you are still likely to encounter null_resource. The terraform_data resource was added fairly recently, and the null provider has been installed over 9 million times in the first week of 2025.

Just like the null provider, the terraform_data source can also be used for testing CI/CD pipelines. In the next chapter, we explore how to apply CI/CD principles to our use of Terraform to increase the quality and security of the infrastructure it manages. This will build off our discussion of state storage to allow automated systems to access state so they can run Terraform in a centralized way.