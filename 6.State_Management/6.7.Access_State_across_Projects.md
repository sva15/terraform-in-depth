6.7 Accessing state across projects
As projects end up managing more and more resources, there is a performance hit that comes into play. Every time you run a plan, Terraform has to go through a refresh and then compare the results to your configuration. For small projects, this can happen pretty quickly, but when projects get into the hundreds or even thousands of resources, this can really add up. Splitting a project up into multiple smaller projects can let developers iterate faster, at the cost of having to manage more projects and coordinate data between them.

Even outside of large projects, there are times when splitting up a project can improve performance. Although many cloud resources are very rapidly deployed, there are some that take an extremely long time and force developers to wait. Cloud databases are fairly notorious for this, and this can drive a team to split out their database needs into a separate project from the rest of their application.

More often than performance, however, is Conway’s law: the idea that “The structure of any system designed by an organization is isomorphic to the structure of the organization.” As companies grow and evolve, they tend to split into more teams and more realms of responsibility. In a small company or startup, one team may be responsible for everything, but as companies grow, it’s more common to see groups take responsibility in certain areas. It’s pretty common for large companies to have network, security, DNS, and database teams (as well as many others) that are responsible for those respective areas. In companies with this structure, it’s common for teams to not directly manage their own network infrastructure, so they need a way to retrieve values like their virtual private cloud ID to use in their own systems (see figure 6.3).

6.7.1 terraform_remote_state
Accessing remote state is most commonly done with the terraform_remote_state data source. This data source is built directly into Terraform itself and does not come from a separate provider. It allows you to read the outputs of another Terraform state and bring them into your code. It is a read-only operation that does not change the other state in any way.

Figure 6.3: An example of how organization structure can mirror module ownership

When using terraform_remote_state, you have to configure a backend. This takes a different format than the generic backend block. There are two parameters, backend and config, that control the backend settings. The backend expects a string specifying which backend to use. The config parameter expects an object with the settings for the backend. In theory, the config parameter is optional, but you’ll need to use it in pretty much any case where it would actually be useful to you. The exact keys for the configuration depends on the specific backend you’re using.

Listing 6.19:
data "terraform_remote_state" "rds" {                         ①
  backend = "s3"                                              ②
 
  config = {                                                  ③
    bucket = var.state_bucket_name
    key    = var.rds_state_path
    region = var.state_region
  }
}
 
module "service" {
  source = "./modules/service"                                ④
  image  = "my_example_image"                                 ⑤
  env = {                                                     ⑥
    rds_uri : data.terraform_remote_state.rds.outputs.rds_uri ⑦
  }
}

① This resource reads from the state of other projects.

② The backend can be any Terraform backend.

③ Each backend will have its own configuration requirements.

④ This example module is a child module that runs locally.

⑤ In our mock example we pass an image name that points to a container.

⑥ Services usually get information from environment variables.

⑦ We pass the output from the other project in to our service.

An extremely important thing to remember is that the state you are reading has to come from a project that exposes outputs from the top-level module that you can use. If you need to access the RDS Amazon Resource Name (ARN), like we did earlier, the state file that generated the RDS instance needs to return the ARN as an output, as we see in listing 6.19 where the output of data.terraform_remote_state.rds is passed to the module.service environment parameter..

If possible, you should use the defaults parameter of terraform_remote_state. This parameter allows you to set values for if the remote state you’re accessing is either missing the outputs or is completely empty (which occurs with new projects). This turns a hard dependency against the remote state, where you can’t even launch your project until the remote project is up, into a soft dependency where you can set up resources and then later update when the other project is ready. This gives you a bit more robustness and flexibility, although there may be cases where it simply isn’t possible.

Listing 6.20:
data "terraform_remote_state" "rds" {
  backend = "s3"
 
  config = {
    bucket = var.state_bucket_name
    key    = var.rds_state_path
    region = var.state_region
  }
 
  defaults = {                          ①
    rds_uri : null                      ②
  }
}

① By setting these values we make sure it is present even if the remote state does not have it.

② A null value makes it so the output will exist, although it will be null.

6.7.2 Structuring for remote state
Although terraform_remote_state is powerful, it is possible to use it in a way that makes your code less maintainable over time. When values come from other projects, it can sometimes be difficult to trace back where these values are coming from, especially during an error. The additional dependency on another project’s state also makes your code less portable. There are some practices you can follow to avoid these pitfalls.

One method you can use is to treat your terraform_remote_state calls as another set of variables for your top-level module. In general, your top-level module is used to compose other modules together and has a more limited amount of direct logic in it. If you put your terraform_remote_state blocks in this top-level module, you can then feed the values into the modules with your actual logic. This keeps the terraform_remote_state out of those modules, which in turn makes them more reusable.

Listing 6.21:
data "terraform_remote_state" "network" {
  backend = "gcs"                                                        ①
 
  config = {                                                             ②
    bucket = var.state_bucket_name
    prefix = var.network_prefix
  }
}
 
module "service" {
  source     = "./modules/service"
  image      = "my_example_image"
  vpc_id     = terraform_remote_state.network.outputs.vpc_id             ③
  subnet_ids = terraform_remote_state.network.outputs.private_subnet_ids ③
}

① The GCS backend is used by teams on Google Cloud Platform.

② The configuration is similar, but slightly different, than the S3 configuration.

③ Since we didn’t use any defaults, Terraform will fail if these values aren’t present.

Another option that can work nicely is playing all of your terraform_remote_state calls into dedicated modules. This can be tricky because of the backend configuration requirements, and it doesn’t work well at all for modules you may want to open source. However, for modules that are only meant to be distributed inside of a single organization, these kinds of modules make more sense. If you have a team that generates networks separately from the rest of their infrastructure, for instance, they may create a module that makes it easier to read the state from those network projects.

Listing 6.22:
variable "network_name" {                                    ①
  type        = string
  description = "Name of the network to pull data in from."
}
 
data "terraform_remote_state" "network" {
  backend = "consul"
 
  config = {
    address = "consul.internal"                              ②
    scheme  = "https"                                        ③
    path    = "terraform/state/networks/${var.network_name}" ④
  }
}
 
output "vpc_id" {                                            ⑤
  value = data.terraform_remote_state.network.outputs.vpc_id
}
 
output "private_subnet_ids" {
  value = data.terraform_remote_state.network.outputs.private_subnet_ids
}
 
output "public_subnet_ids" {
  value = data.terraform_remote_state.network.outputs.public_subnet_ids
}

① This reusable module only needs a single variable instead of the full config.

② The team maintaining this can hardcode the server.

③ Since there is only one server the scheme can also be hardcoded.

④ The network name is added to complete the path to the state.

⑤ To make this available outside the module it has to be put in an output block.

6.7.3 Alternatives to terraform_remote_state
Before using remote state lookups, you should consider whether it really is the best approach. Allowing systems to access remote state brings up all of the problems that have been discussed in the security section: anyone with access to the state also has access to the attributes, including the sensitive values, that are in that state.

In general, people should first see if there are data sources that can be used to look up the resources instead of pulling the data from the remote state. For example, if you’re pulling in the IP address of a database using state, you could do a lookup of that database instance using data sources. This allows your code to be a bit more standalone while still allowing you to offload the creation and management of the resource from the module you’re working on.

The downside to this method is that it isn’t always easy to look up the resources you want to. In some cases there aren’t data sources you can use, or they don’t allow lookups that are as precise as you’d like. In chapter 10, we discuss some tagging strategies you can use when creating resources to make it easier for lookups to occur, but in the event that this isn’t an option, you’ll need to consider other options or fall back to accessing remote state.

Another alternative is to use input variables to fill in the values that you were considering looking up. This method is more secure than granting access to the remote state, but it also requires a bit more work and maintenance to keep all the values up to date. In general, I recommend minimizing the number of variables you’re pulling in this way and instead see if you can use data sources to pull the needed values in automatically for you.