# 6.7 Cross-Project State Access

As Terraform projects grow, teams often split them into smaller, focused projects for better performance, team ownership, and maintainability. This creates a need to share data between projects while maintaining clear boundaries.

## Why Split Terraform Projects?

### Performance Benefits
- **Faster planning**: Smaller state files mean quicker `terraform plan` operations
- **Reduced refresh time**: Fewer resources to check during state refresh
- **Parallel development**: Teams can work on different projects simultaneously
- **Isolated failures**: Issues in one project don't block others

### Organizational Benefits
- **Team ownership**: Different teams manage different infrastructure layers
- **Conway's Law**: Project structure mirrors organizational structure
- **Specialized expertise**: Database team manages databases, network team manages networking
- **Security boundaries**: Sensitive resources isolated in separate projects

### Common Project Split Patterns

**By Infrastructure Layer**:
```
├── networking/          # VPCs, subnets, security groups
├── databases/           # RDS, DynamoDB, Redis
├── applications/        # EC2, ECS, Lambda
└── monitoring/          # CloudWatch, alerts
```

**By Environment**:
```
├── shared-services/     # DNS, logging, monitoring
├── production/          # Prod applications
├── staging/             # Staging environment
└── development/         # Dev environment
```

**By Team Ownership**:
```
├── platform-team/       # Core infrastructure
├── data-team/           # Data pipelines, warehouses
├── web-team/            # Frontend applications
└── api-team/            # Backend services
```

## Using terraform_remote_state

The `terraform_remote_state` data source is the primary method for accessing outputs from other Terraform projects. It's built into Terraform core and provides read-only access to remote state files.

### How It Works

1. **Read-only access**: Never modifies the remote state
2. **Output-based**: Can only access values exposed as outputs
3. **Backend agnostic**: Works with any Terraform backend
4. **Real-time**: Reads current state during plan/apply

### Basic Syntax

```hcl
data "terraform_remote_state" "name" {
  backend = "backend_type"
  
  config = {
    # Backend-specific configuration
  }
}
```

### Configuration Requirements

- **backend**: String specifying the backend type (s3, gcs, azurerm, etc.)
- **config**: Object containing backend-specific settings
- **defaults** (optional): Fallback values when outputs are missing

### Practical Example: Database Connection

**Database Project** (`databases/main.tf`):
```hcl
resource "aws_db_instance" "main" {
  identifier = "app-database"
  engine     = "postgres"
  # ... other configuration
}

# CRITICAL: Must expose values as outputs
output "rds_endpoint" {
  value       = aws_db_instance.main.endpoint
  description = "RDS instance endpoint"
}

output "rds_port" {
  value       = aws_db_instance.main.port
  description = "RDS instance port"
}
```

**Application Project** (`applications/main.tf`):
```hcl
# Access database project state
data "terraform_remote_state" "database" {
  backend = "s3"
  
  config = {
    bucket = "my-terraform-state"
    key    = "databases/terraform.tfstate"
    region = "us-west-2"
  }
}

# Use database outputs in application
module "web_service" {
  source = "./modules/web-service"
  
  database_url = "postgresql://${data.terraform_remote_state.database.outputs.rds_endpoint}:${data.terraform_remote_state.database.outputs.rds_port}/app"
}

### Critical Requirements

⚠️ **Output Dependency**: Remote state can only access values that are explicitly defined as `output` blocks in the source project.

### Managing Dependencies with Defaults

Use the `defaults` parameter to handle missing or empty remote state gracefully:

**Benefits of Using Defaults**:
- **Soft dependencies**: Project can deploy before dependencies exist
- **Development flexibility**: Work on projects in any order
- **Error prevention**: Avoid crashes when remote state is missing
- **Gradual rollout**: Deploy infrastructure incrementally

### Example: Using Defaults

```hcl
data "terraform_remote_state" "networking" {
  backend = "s3"
  
  config = {
    bucket = "my-terraform-state"
    key    = "networking/terraform.tfstate"
    region = "us-west-2"
  }
  
  # Provide fallback values for missing outputs
  defaults = {
    vpc_id           = null
    private_subnets  = []
    public_subnets   = []
    security_groups  = {}
  }
}

# Use with conditional logic
resource "aws_instance" "app" {
  count = data.terraform_remote_state.networking.outputs.vpc_id != null ? 1 : 0
  
  subnet_id              = data.terraform_remote_state.networking.outputs.private_subnets[0]
  vpc_security_group_ids = [data.terraform_remote_state.networking.outputs.security_groups.app]
}

## Best Practices for Remote State

### Common Pitfalls to Avoid

❌ **Don't**:
- Put `terraform_remote_state` calls inside reusable modules
- Create deep chains of remote state dependencies
- Access remote state without proper error handling
- Hardcode backend configurations in modules

### Recommended Patterns

### Pattern 1: Root Module Composition

Keep `terraform_remote_state` calls in your root module and pass values to child modules:

```hcl
# Root module: main.tf
data "terraform_remote_state" "networking" {
  backend = "s3"
  config = {
    bucket = "my-terraform-state"
    key    = "networking/terraform.tfstate"
    region = "us-west-2"
  }
}

# Pass remote state values to modules
module "application" {
  source = "./modules/application"
  
  vpc_id     = data.terraform_remote_state.networking.outputs.vpc_id
  subnet_ids = data.terraform_remote_state.networking.outputs.private_subnets
}
```

**Benefits**:
- Modules remain reusable and portable
- Clear dependency tracking
- Easier testing and development



### Backend Configuration Examples

**Google Cloud Storage Backend**:
```hcl
data "terraform_remote_state" "network" {
  backend = "gcs"
  config = {
    bucket = "my-terraform-state"
    prefix = "network"
  }
}

module "service" {
  source = "./modules/service"
  vpc_id     = data.terraform_remote_state.network.outputs.vpc_id
  subnet_ids = data.terraform_remote_state.network.outputs.private_subnet_ids
}
```

**AWS S3 Backend**:
```hcl
data "terraform_remote_state" "shared" {
  backend = "s3"
  config = {
    bucket         = "my-terraform-state"
    key            = "shared/terraform.tfstate"
    region         = "us-west-2"
    dynamodb_table = "terraform-locks"
  }
}
```

**Azure Storage Backend**:
```hcl
data "terraform_remote_state" "shared" {
  backend = "azurerm"
  config = {
    resource_group_name  = "terraform-state-rg"
    storage_account_name = "terraformstate"
    container_name       = "tfstate"
    key                  = "shared.terraform.tfstate"
  }
}
```

---

### Pattern 2: Dedicated Data Modules

Create organization-specific modules that encapsulate remote state access:

**Example: Network Data Module** (`modules/network-data/main.tf`):
```hcl
variable "network_name" {
  type        = string
  description = "Name of the network to pull data from"
}

data "terraform_remote_state" "network" {
  backend = "s3"
  config = {
    bucket = "company-terraform-state"
    key    = "networks/${var.network_name}/terraform.tfstate"
    region = "us-west-2"
  }
  defaults = {
    vpc_id          = null
    private_subnets = []
    public_subnets  = []
  }
}

output "vpc_id" {
  value = data.terraform_remote_state.network.outputs.vpc_id
}
output "private_subnet_ids" {
  value = data.terraform_remote_state.network.outputs.private_subnet_ids
}
output "public_subnet_ids" {
  value = data.terraform_remote_state.network.outputs.public_subnet_ids
}
```

**Usage**:
```hcl
module "network_data" {
  source       = "./modules/network-data"
  network_name = "production"
}

module "application" {
  source = "./modules/application"
  vpc_id     = module.network_data.vpc_id
  subnet_ids = module.network_data.private_subnet_ids
}
```

**Benefits**:
- Simplified interface for consumers
- Centralized backend configuration
- Organization-specific optimizations
- Easier to maintain and update

---

## Alternatives to Remote State

### Security Considerations

⚠️ **Remote state access grants access to ALL sensitive values in that state file**

### Alternative 1: Data Sources (Recommended)

Use provider data sources instead of remote state when possible:

```hcl
# Instead of remote state
data "terraform_remote_state" "database" {
  backend = "s3"
  config = {
    bucket = "state-bucket"
    key    = "database/terraform.tfstate"
    region = "us-west-2"
  }
}

# Use data sources
data "aws_db_instance" "main" {
  db_instance_identifier = "app-database"
}

# Use the data source output
resource "aws_instance" "app" {
  user_data = templatefile("app-config.tpl", {
    db_endpoint = data.aws_db_instance.main.endpoint
    db_port     = data.aws_db_instance.main.port
  })
}
```

### Alternative 2: Input Variables

Pass values explicitly through variables:

```hcl
variable "database_endpoint" {
  type        = string
  description = "Database endpoint from infrastructure team"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID from network team"
}
```

### Decision Matrix

| Method         | Security | Complexity | Coupling | Best For           |
|----------------|----------|------------|----------|--------------------|
| Remote State   | Low      | Low        | High     | Quick prototypes   |
| Data Sources   | High     | Medium     | Low      | Production systems |
| Variables      | High     | Medium     | Medium   | Team boundaries    |

## Key Takeaways

- **Prefer data sources** over remote state when possible
- **Keep remote state calls in root modules** only
- **Use defaults** to handle missing dependencies
- **Consider security implications** of state access
- **Plan for migration** to more secure alternatives